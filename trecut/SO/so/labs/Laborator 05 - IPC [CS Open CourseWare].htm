<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0056)http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>
    Laborator 05 - IPC    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki">
<meta name="robots" content="index,follow">
<meta name="date" content="2013-03-26T12:15:45+0200">
<meta name="keywords" content="so,laboratoare,laborator-05">
<link rel="search" type="application/opensearchdescription+xml" href="http://ocw.cs.pub.ro/courses/lib/exe/opensearch.php" title="CS Open CourseWare">
<link rel="start" href="http://ocw.cs.pub.ro/courses/">
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="http://ocw.cs.pub.ro/courses/feed.php">
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://ocw.cs.pub.ro/courses/feed.php?mode=list&ns=so:laboratoare">
<link rel="alternate" type="text/html" title="Plain HTML" href="http://ocw.cs.pub.ro/courses/_export/xhtml/so/laboratoare/laborator-05">
<link rel="canonical" href="./Laborator 05 - IPC [CS Open CourseWare]_files/Laborator 05 - IPC [CS Open CourseWare].htm">
<link rel="stylesheet" type="text/css" href="./Laborator 05 - IPC [CS Open CourseWare]_files/css.php">
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare';var JSINFO = {"id":"so:laboratoare:laborator-05","namespace":"so:laboratoare"};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="./Laborator 05 - IPC [CS Open CourseWare]_files/js.php"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script><script src="./Laborator 05 - IPC [CS Open CourseWare]_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="./Laborator 05 - IPC [CS Open CourseWare]_files/menu.js"></script>
<script type="text/javascript" charset="utf-8" src="./Laborator 05 - IPC [CS Open CourseWare]_files/indexmenu.js"></script>
<script type="text/javascript" charset="utf-8">/*<![CDATA[*/var indexmenu_ID='so/laboratoare/laborator-05'
/*!]]>*/</script>

  <link rel="shortcut icon" href="http://ocw.cs.pub.ro/courses/lib/tpl/arctic/images/favicon.ico">

  
<script src="./Laborator 05 - IPC [CS Open CourseWare]_files/nojsindex.js" type="text/javascript" charset="utf-8"></script></head>
<body>
<div id="wrapper" class="show">
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="http://ocw.cs.pub.ro/courses/so/"><img height="70" src="./Laborator 05 - IPC [CS Open CourseWare]_files/sigla_so.png"> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="http://ocw.cs.pub.ro/courses/systems/"><img height="70" src="./Laborator 05 - IPC [CS Open CourseWare]_files/systems.png" name="dokuwiki__top"></a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05?do=login&sectok=86b5e794b6fc7ff30ead55e0316f8781" class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h1 class="sectionedit1" id="laborator_05_-_ipc">Laborator 05 - IPC</h1>
<div class="level1">

</div>

<h2 class="sectionedit2" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab05-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab05-slides.pdf" rel="nofollow"> lab05-slides.pdf</a></div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab05-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab05-refcard.pdf" rel="nofollow"> lab05-refcard.pdf</a></div>
</li>
</ul>

</div>

<h3 class="sectionedit3" id="nice_to_read">Nice to read</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> TLPI - Chapter 51, Introduction to POSIX IPC</div>
</li>
<li class="level1"><div class="li"> TLPI - Chapter 52, POSIX messages queues</div>
</li>
<li class="level1"><div class="li"> TLPI - Chapter 53, POSIX semaphores</div>
</li>
<li class="level1"><div class="li"> TLPI - Chapter 54, POSIX shared memory</div>
</li>
</ul>

</div>

<h2 class="sectionedit4" id="mecanisme_ipc">Mecanisme IPC</h2>
<div class="level2">

<p>
Comunicarea se poate realiza între procese de pe aceeași mașină sau de pe mașini diferite.  Exemple de mecanisme IPC:
</p>
<ul>
<li class="level1"><div class="li">obiecte de sincronizare (mutex, semafor)</div>
</li>
<li class="level1"><div class="li">cozi de mesaje</div>
</li>
<li class="level1"><div class="li">memorie partajată</div>
</li>
<li class="level1"><div class="li">pipe-uri</div>
</li>
<li class="level1"><div class="li">sockeți</div>
</li>
</ul>

<p>
Pipe-urile au fost prezentate deja în <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-03" class="wikilink1" title="so:laboratoare:laborator-03">laboratorul de procese</a>. În acest laborator ne vom concentra pe primele trei categorii.
</p>

<p>
<strong> Mecanisme de sincronizare </strong>
</p>
<ul>
<li class="level1"><div class="li"><strong>Mutex</strong> (<a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#mutex-uri" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Windows</a>)</div>
</li>
</ul>

<p>
Este un obiect de sincronizare care poate fi deținut (posedat, acaparat) doar de un singur proces/thread (în funcție de implementare) la un moment dat. Drept urmare, operațiile de bază cu mutex-uri sunt cele de obținere și de eliberare.
</p>

<p>
Odată obținut de un proces/thread, un mutex devine indisponibil pentru orice alt proces/thread. Orice proces/thread care încearcă să acapareze un mutex indisponibil, se va bloca (un timp definit sau nu) așteptând ca el să devină disponibil.
</p>

<p>
Mutex-urile sunt cel mai des folosite pentru a permite unui singur proces la un moment dat să acceseze o resursă.
</p>
<ul>
<li class="level1"><div class="li"><strong>Semafor</strong> (<a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#semafoare_posix" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Linux</a>, <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#semafoare" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Windows</a>)</div>
</li>
</ul>

<p>
Semafoarele sunt resurse IPC folosite pentru sincronizarea între procese/thread-uri (e.g., pentru controlul accesului la resurse). Un semafor poate fi privit ca un contor ce poate fi incrementat și decrementat, dar a cărui valoare nu poate scădea sub 0. Atât timp cât semaforul (contorul) are valori strict pozitive el este considerat disponibil. Când valoarea semaforului a ajuns la 0, el devine indisponibil și următoarea încercare de decrementare va duce la o blocare a threadului/procesului de pe care s-a făcut apelul până când semaforul devine disponibil. 
</p>
<ul>
<li class="level1"><div class="li"><strong>Cozi de mesaje</strong> (<a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#cozi_de_mesaje" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Linux</a>, <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#cozi_de_mesaje_mailslots" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Windows</a>)</div>
</li>
</ul>

<p>
Sunt folosite de procese pentru a comunica între ele prin mesaje. Aceste mesaje își păstrează ordinea în interiorul cozii de mesaje. Sunt mecanisme de comunicare unidirecționale atât pe Linux, cât și pe Windows. 
</p>
<ul>
<li class="level1"><div class="li"><strong> Memorie partajată </strong> (<a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#memoria_partajata" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Linux</a>, <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#memorie_partajata_filemapping" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Windows</a>)</div>
</li>
</ul>

<p>
Acest mecanism permite comunicarea între procese prin accesul direct și partajat la o zonă de memorie bine determinată. 
Este un mod mai rapid de comunicare între procese decât celelalte mijloace IPC, dar are un mare dezavantaj, procesele ce comunică trebuie să fie pe aceeași mașină (spre deosebire de sockeți, pipe-urile cu nume și cozile de mesaje din Windows)
</p>

</div>

<h2 class="sectionedit5" id="linux">Linux</h2>
<div class="level2">

<p>
Linux pune la dispoziție 2 seturi de <abbr title="Application Programming Interface">API</abbr>-uri referitoare la mecanismele de comunicare interprocese, ce țin de standarde diferite:
</p>
<ul>
<li class="level1"><div class="li"><a href="http://en.wikipedia.org/wiki/System_V_Interface_Definition" class="urlextern" title="http://en.wikipedia.org/wiki/System_V_Interface_Definition" rel="nofollow"> System V</a> Inter-Process Communication, derivat din distribuția de Unix System V release 4 AT&amp;T</div>
</li>
<li class="level1"><div class="li"><a href="http://en.wikipedia.org/wiki/POSIX" class="urlextern" title="http://en.wikipedia.org/wiki/POSIX" rel="nofollow">POSIX</a> (Portable Operating System Interface for Unix)</div>
</li>
</ul>

<p>
Ambele standarde specifică 3 mecanisme:
</p>
<ul>
<li class="level1"><div class="li"><code>mesaje</code> (messages) - realizează schimbul de mesaje cu orice proces sau server</div>
</li>
<li class="level1"><div class="li"><code>semafoare</code> (semaphores) - realizează sincronizarea execuțiilor proceselor</div>
</li>
<li class="level1"><div class="li"><code>memorie partajată</code> (shared memory) - realizează partajarea memoriei între procese </div>
</li>
</ul>

<p>
<abbr title="Application Programming Interface">API</abbr>-ul studiat în acest laborator este cel <a href="http://en.wikipedia.org/wiki/POSIX" class="urlextern" title="http://en.wikipedia.org/wiki/POSIX" rel="nofollow">POSIX</a>.
</p>

<p>
Obiectele de tip IPC pe care se concentrează laboratorul de față sunt gestionate global de sistem și rămân în viață chiar dacă procesul creator moare. Faptul că aceste resurse sunt globale în sistem are implicații contradictorii:
</p>
<ul>
<li class="level1"><div class="li">Dacă un proces se termină, datele plasate în obiecte IPC pot fi accesate ulterior de alte procese</div>
</li>
<li class="level1"><div class="li">Pe de altă parte, procesul proprietar trebuie să se ocupe și de dealocarea resurselor, altfel ele rămân în sistem până la ștergerea lor manuală sau până la repornirea sistemului. </div>
</li>
</ul>

<p>
Faptul că obiectele IPC sunt globale în sistem poate duce la apariția unor probleme: cum numărul de mesaje care se află în cozile de mesaje din sistem e limitat global, un proces care trimite multe asemenea mesaje poate bloca toate celelalte procese. 
</p>

<p>
<strong>Atenție!</strong> Pentru folosirea <abbr title="Application Programming Interface">API</abbr>-ului trebuie să includeți la linking biblioteca <code>rt</code> (-lrt).
</p>

</div>

<h3 class="sectionedit6" id="semafoare_posix">Semafoare POSIX</h3>
<div class="level3">

<p>
Semafoarele sunt resurse IPC folosite pentru sincronizarea între procese (e.g., pentru controlul accesului la resurse). Operațiile asupra unui semafor pot fi de <em><code>setare</code></em>, <em><code>verificare</code></em> a valorii ( care poate fi &gt;= 0 ), <em><code>test and set</code></em>. Un semafor poate fi privit ca un contor ce poate fi incrementat și decrementat, dar a cărui valoare nu poate scădea sub 0. 
</p>

<p>
Semafoarele POSIX sunt de 2 tipuri:
</p>
<ul>
<li class="level1"><div class="li"><code>cu nume</code> -  folosite în general pentru sincronizare între procese distincte;</div>
</li>
<li class="level1"><div class="li"><code>fără nume</code> - ce pot fi folosite pentru sincronizarea între firele de execuție ale aceluiași proces, sau între procese - cu condiția ca semaforul să fie într-o zonă de memorie partajată.</div>
</li>
</ul>

<p>
În continuare vor fi luate în discuție semafoarele <code>cu nume</code>. Diferențele față de cele fără nume apar în funcțiile de creare și distrugere, celelalte funcții fiind identice.
</p>
<ul>
<li class="level1"><div class="li">ambele tipuri de semafoare sunt reprezentate în cod prin tipul <code>sem_t</code>.</div>
</li>
<li class="level1"><div class="li">semafoarele cu nume sunt identificate la nivel de sistem printr-un șir de forma <code>”/nume”</code>.</div>
</li>
<li class="level1"><div class="li">fișierele antet necesare sunt <code>&lt;fcntl.h&gt;</code>, <code>&lt;sys/types.h&gt;</code> și <code>&lt;semaphore.h&gt;</code>.</div>
</li>
</ul>

</div>

<h4 id="crearea_si_deschiderea">Crearea și deschiderea</h4>
<div class="level4">

<p>
Un proces poate crea sau deschide un semafor existent cu funcția <a href="http://linux.die.net/man/3/sem_open" class="urlextern" title="http://linux.die.net/man/3/sem_open" rel="nofollow">sem_open</a>:
</p>
<pre class="code c"><span class="coMULTI">/* create semaphore */</span>
sem_t<span class="sy0">*</span> sem_open<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> oflag<span class="sy0">,</span> mode_t mode<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> value<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* open semaphore */</span>
sem_t<span class="sy0">*</span> sem_open<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> oflag<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Comportamentul este similar cu cel de la deschiderea fișierelor. Dacă flag-ul <code>O_CREAT</code> este prezent, trebuie folosită prima formă a funcției, specificând permisiunile și valoarea inițială.
</p>

<p>
Singurele posibilități pentru al doilea argument sunt:
</p>
<ul>
<li class="level1"><div class="li">0 - se deschide semaforul dacă există</div>
</li>
<li class="level1"><div class="li">O_CREAT - se creează semaforul dacă nu există; se deschide dacă există</div>
</li>
<li class="level1"><div class="li">O_CREAT | O_EXCL - se creează semaforul <strong>numai</strong> dacă nu există; se întoarce eroare dacă există</div>
</li>
</ul>

</div>

<h4 id="decrementare_incrementare_si_aflarea_valorii">Decrementare, incrementare și aflarea valorii</h4>
<div class="level4">

<p>
Valoarea unui semafor este decrementată cu funcția <a href="http://linux.die.net/man/3/sem_wait" class="urlextern" title="http://linux.die.net/man/3/sem_wait" rel="nofollow">sem_wait</a>:
</p>
<pre class="code c"><span class="kw4">int</span> sem_wait<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Dacă semaforul are valoarea 0, funcția blochează până când un alt proces “deblochează” (incrementează) semaforul.
</p>

<p>
Pentru a încerca decrementarea unui semafor fără riscul de a rămâne blocat la acesta, un proces poate apela <a href="http://linux.die.net/man/3/sem_trywait" class="urlextern" title="http://linux.die.net/man/3/sem_trywait" rel="nofollow">sem_trywait</a>:
</p>
<pre class="code c"><span class="kw4">int</span> sem_trywait<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
În cazul în care semaforul are deja valoarea zero, funcția va întoarce -1, iar <code>errno</code> va fi setat la <code>EAGAIN</code>.
</p>

<p>
Un semafor este incrementat cu funcția <a href="http://linux.die.net/man/3/sem_post" class="urlextern" title="http://linux.die.net/man/3/sem_post" rel="nofollow">sem_post</a>:
</p>
<pre class="code c"><span class="kw4">int</span> sem_post<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
În cazul în care semaforul avea valoarea zero, un proces blocat în <a href="http://linux.die.net/man/3/sem_wait" class="urlextern" title="http://linux.die.net/man/3/sem_wait" rel="nofollow">sem_wait</a> pe acesta va fi deblocat.
</p>

<p>
Valoarea unui semafor (a contorului) se poate afla cu <a href="http://linux.die.net/man/3/sem_getvalue" class="urlextern" title="http://linux.die.net/man/3/sem_getvalue" rel="nofollow">sem_getvalue</a>:
</p>
<pre class="code c"><span class="kw4">int</span> sem_getvalue<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>pvalue<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
În cazul în care există procese blocate la semafor, implementarea apelului pe Linux va returna <strong>zero</strong> în valoarea referință de <code>pvalue</code>. 
</p>

</div>

<h4 id="inchiderea_si_distrugerea">Închiderea și distrugerea</h4>
<div class="level4">

<p>
Un proces închide (notifică faptul că nu mai folosește) un semafor printr-un apel <a href="http://linux.die.net/man/3/sem_close" class="urlextern" title="http://linux.die.net/man/3/sem_close" rel="nofollow">sem_close</a>:
</p>
<pre class="code c"><span class="kw4">int</span> sem_close<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Un proces poate șterge un semafor printr-un apel <a href="http://linux.die.net/man/3/sem_unlink" class="urlextern" title="http://linux.die.net/man/3/sem_unlink" rel="nofollow">sem_unlink</a>:
</p>
<pre class="code c"><span class="kw4">int</span> sem_unlink<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Distrugerea efectivă a semaforului are loc după ce toate procesele care îl au deschis apelează <a href="http://linux.die.net/man/3/sem_close" class="urlextern" title="http://linux.die.net/man/3/sem_close" rel="nofollow">sem_close</a> sau se termină. Totuși, chiar și în acest caz, apelul <a href="http://linux.die.net/man/3/sem_unlink" class="urlextern" title="http://linux.die.net/man/3/sem_unlink" rel="nofollow">sem_unlink</a> nu se va bloca!
</p>

</div>

<h4 id="exemplu_de_utilizare">Exemplu de utilizare</h4>
<div class="level4">
<pre class="code c"><span class="co2">#include &lt;fcntl.h&gt;           /* For O_* constants */</span>
<span class="co2">#include &lt;sys/stat.h&gt;        /* For mode constants */</span>
<span class="co2">#include &lt;semaphore.h&gt;</span>
&nbsp;
<span class="co2">#include "utils.h"</span>
&nbsp;
<span class="co2">#define	SEM_NAME	"/my_semaphore"</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
	sem_t <span class="sy0">*</span>my_sem<span class="sy0">;</span>
	<span class="kw4">int</span> rc<span class="sy0">,</span> pvalue<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* create semaphore with initial value of 1 */</span>
	my_sem <span class="sy0">=</span> sem_open<span class="br0">(</span>SEM_NAME<span class="sy0">,</span> O_CREAT<span class="sy0">,</span> <span class="nu8">0644</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	DIE<span class="br0">(</span>my_sem <span class="sy0">==</span> SEM_FAILED<span class="sy0">,</span> <span class="st0">"sem_open failed"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
&nbsp;
	<span class="coMULTI">/* get the semaphore */</span>
	sem_wait<span class="br0">(</span>my_sem<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* do important stuff protected by the semaphore */</span>
	rc <span class="sy0">=</span> sem_getvalue<span class="br0">(</span>my_sem<span class="sy0">,</span> <span class="sy0">&amp;</span>pvalue<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"sem_getvalue"</span><span class="br0">)</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"sem is %d<span class="es1">\n</span>"</span><span class="sy0">,</span> pvalue<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* release the lock */</span>
	sem_post<span class="br0">(</span>my_sem<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	rc <span class="sy0">=</span> sem_close<span class="br0">(</span>my_sem<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"sem_close"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	rc <span class="sy0">=</span> sem_unlink<span class="br0">(</span>SEM_NAME<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"sem_unlink"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>

<p>
Semaforul va fi creat în ”/dev/shm” și va avea numele “sem.my_semaphore”
</p>

</div>

<h3 class="sectionedit7" id="cozi_de_mesaje">Cozi de mesaje</h3>
<div class="level3">

<p>
Acestea permit proceselor să interschimbe date sub formă de mesaje
</p>
<ul>
<li class="level1"><div class="li"> la nivel de sistem sunt identificabile printr-un string de forma ”<code>/nume</code>”.</div>
</li>
<li class="level1"><div class="li"> la nivelul codului, o coada de mesaje este reprezentată de un descriptor de tipul <code>mqd_t</code>.</div>
</li>
<li class="level1"><div class="li"> fișierele antet necesare sunt: <code>&lt;fcntl.h&gt;</code>, <code>&lt;sys/types.h&gt;</code> și <code>&lt;mqueue.h&gt;</code>.</div>
</li>
</ul>

</div>

<h4 id="crearea_si_deschiderea1">Crearea și deschiderea</h4>
<div class="level4">

<p>
Funcțiile de creare și deschidere sunt similare ca formă și semantică celor de la semafoare (<a href="http://linux.die.net/man/3/mq_open" class="urlextern" title="http://linux.die.net/man/3/mq_open" rel="nofollow">mq_open</a>):
</p>
<pre class="code c"><span class="coMULTI">/* create */</span>
mqd_t mq_open<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> oflag<span class="sy0">,</span> mode_t mode<span class="sy0">,</span> <span class="kw4">struct</span> mq_attr <span class="sy0">*</span>attr<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* open */</span>
mqd_t mq_open<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> oflag<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
În funcție de flag-uri (unul dintre cele de mai jos trebuie specificat), coada poate fi deschisă pentru:
</p>
<ul>
<li class="level1"><div class="li">recepționare (<code>O_RDONLY</code>)</div>
</li>
<li class="level1"><div class="li">trimitere (<code>O_WRONLY</code>)</div>
</li>
<li class="level1"><div class="li">recepționare și trimitere (<code>O_RDWR</code>) </div>
</li>
</ul>

<p>
Daca <code>attr</code> e <code>NULL</code>, coada va fi creată cu atribute implicite. Structura <code>mq_attr</code> arată astfel:
</p>
<pre class="code c"><span class="kw4">struct</span> mq_attr <span class="br0">{</span>
    <span class="kw4">long</span> mq_flags<span class="sy0">;</span>       <span class="coMULTI">/* 0 or O_NONBLOCK */</span>
    <span class="kw4">long</span> mq_maxmsg<span class="sy0">;</span>      <span class="coMULTI">/* Max. number of messages on queue */</span>
    <span class="kw4">long</span> mq_msgsize<span class="sy0">;</span>     <span class="coMULTI">/* Max. message size (bytes) */</span>
    <span class="kw4">long</span> mq_curmsgs<span class="sy0">;</span>     <span class="coMULTI">/* number of messages currently in queue */</span>
<span class="br0">}</span><span class="sy0">;</span></pre>

</div>

<h4 id="trimiterea_si_receptionarea_de_mesaje">Trimiterea și recepționarea de mesaje</h4>
<div class="level4">

<p>
Pentru a trimite un mesaj (de lungime cunoscută, stocat într-un buffer) în coadă se apelează <a href="http://linux.die.net/man/3/mq_send" class="urlextern" title="http://linux.die.net/man/3/mq_send" rel="nofollow">mq_send</a>:
</p>
<pre class="code c"><span class="kw4">int</span> mq_send<span class="br0">(</span>mqd_t mqdes<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>buffer<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="sy0">,</span> <span class="kw4">unsigned</span> priority<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Mesajele sunt ținute în coadă în ordinea descrescătoare a priorității. 
</p>

<p>
În cazul în care coada este plină, apelul blochează. Dacă este o coadă non-blocantă (<code>O_NONBLOCK</code>), funcția va întoarce -1, iar <code>errno</code> va fi setat la <code>EAGAIN</code>.
</p>

<p>
Pentru a primi un mesaj dintr-o coadă (și anume: cel mai vechi mesaj cu cea mai mare prioritate) se folosește <a href="http://linux.die.net/man/3/mq_receive" class="urlextern" title="http://linux.die.net/man/3/mq_receive" rel="nofollow">mq_receive</a>:
</p>
<pre class="code c">ssize_t mq_receive<span class="br0">(</span>mqd_t mqdes<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>buffer<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="sy0">*</span>priority<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Dacă <code>priority</code> este non-NULL, zona de memorie către care face referire va reține prioritatea mesajului extras. 
</p>

<p>
În cazul în care coada este vidă, apelul blochează. Dacă este o coadă non-blocantă (<code>O_NONBLOCK</code>), comportamentul este similar cu cel al <a href="http://linux.die.net/man/3/mq_send" class="urlextern" title="http://linux.die.net/man/3/mq_send" rel="nofollow">mq_send</a>.
</p>

<p>
<strong>Atenție!</strong> La primirea unui mesaj, lungimea buffer-ului trebuie să fie <strong>cel puțin egală</strong> cu dimensiunea maximă a mesajelor pentru coada respectivă, iar la trimitere <strong>cel mult egală</strong>. Dimensiunea maximă implicită se poate afla pe Linux din <code>/proc/sys/kernel/msgmax</code>.
</p>

</div>

<h4 id="inchiderea_si_stergerea">Închiderea și ștergerea</h4>
<div class="level4">

<p>
Închiderea (eliberarea “referinței”) unei cozi este posibilă prin apelul <a href="http://linux.die.net/man/3/mq_close" class="urlextern" title="http://linux.die.net/man/3/mq_close" rel="nofollow">mq_close</a>:
</p>
<pre class="code c"><span class="kw4">int</span> mq_close<span class="br0">(</span>mqd_t mqdes<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Ștergerea se realizează cu un apel <a href="http://linux.die.net/man/3/mq_unlink" class="urlextern" title="http://linux.die.net/man/3/mq_unlink" rel="nofollow">mq_unlink</a>:
</p>
<pre class="code c"><span class="kw4">int</span> mq_unlink<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Semantica este similară cu cea de la semafoare: coada nu va fi ștearsă efectiv decât după ce restul proceselor implicate o închid sau se termină.
</p>

</div>

<h4 id="exemplu_de_utilizare1">Exemplu de utilizare</h4>
<div class="level4">
<dl class="code">
<dt><a href="http://ocw.cs.pub.ro/courses/_export/code/so/laboratoare/laborator-05?codeblock=14" title="Download Snippet" class="mediafile mf_c">mqueue.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;mqueue.h&gt;</span>
<span class="co2">#include &lt;string.h&gt;</span>
<span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;errno.h&gt;</span>
&nbsp;
<span class="co2">#include "utils.h"</span>
&nbsp;
<span class="coMULTI">/* Set buffer size at least the default maxim size of the queue
  * found in/proc/sys/kernel/msgmax */</span>
<span class="co2">#define BUF_SIZE 	(1&lt;&lt;13)</span>
<span class="co2">#define TEXT		"test message"</span>
<span class="co2">#define NAME		"/test_queue"</span>
&nbsp;
<span class="kw4">char</span> buf<span class="br0">[</span>BUF_SIZE<span class="br0">]</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">int</span> argc<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">**</span>argv<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">unsigned</span> <span class="kw4">int</span> prio <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
	<span class="kw4">int</span> rc<span class="sy0">;</span>
	mqd_t m<span class="sy0">;</span>
&nbsp;
	m <span class="sy0">=</span> mq_open<span class="br0">(</span>NAME<span class="sy0">,</span> <span class="br0">(</span>argc<span class="sy0">&gt;</span><span class="nu0">1</span> <span class="sy0">?</span> O_CREAT <span class="sy0">:</span> <span class="nu0">0</span><span class="br0">)</span> <span class="sy0">|</span> O_RDWR<span class="sy0">,</span> <span class="nu8">0666</span><span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>m <span class="sy0">==</span> <span class="br0">(</span>mqd_t<span class="br0">)</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"mq_open"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>argc <span class="sy0">&gt;</span> <span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
		<span class="coMULTI">/* server sending message */</span>
&nbsp;
		rc <span class="sy0">=</span> mq_send<span class="br0">(</span>m<span class="sy0">,</span> TEXT<span class="sy0">,</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/strlen.html"><span class="kw3">strlen</span></a><span class="br0">(</span>TEXT<span class="br0">)</span><span class="sy0">,</span> prio<span class="br0">)</span><span class="sy0">;</span>
		DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"mq_send"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
		rc <span class="sy0">=</span> mq_close<span class="br0">(</span>m<span class="br0">)</span><span class="sy0">;</span>
		DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"mq_close"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
		<span class="coMULTI">/* client receiving message */</span>
&nbsp;
		rc <span class="sy0">=</span> mq_receive<span class="br0">(</span>m<span class="sy0">,</span> buf<span class="sy0">,</span> BUF_SIZE<span class="sy0">,</span> <span class="sy0">&amp;</span>prio<span class="br0">)</span><span class="sy0">;</span>
		DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"mq_receive"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"received: %s<span class="es1">\n</span>"</span><span class="sy0">,</span> buf<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
		rc <span class="sy0">=</span> mq_close<span class="br0">(</span>m<span class="br0">)</span><span class="sy0">;</span>
		DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"mq_close"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
		rc <span class="sy0">=</span> mq_unlink<span class="br0">(</span>NAME<span class="br0">)</span><span class="sy0">;</span>
		DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"mq_unlink"</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</dd></dl>

</div>

<h3 class="sectionedit8" id="memoria_partajata">Memoria partajată</h3>
<div class="level3">

<p>
Acest mecanism permite comunicarea între procese prin accesul direct și partajat la o zonă de memorie bine determinată.
</p>
<ul>
<li class="level1"><div class="li">la nivelul sistemului, o zonă este identificată printr-un string de forma ”<code>/nume</code>”;</div>
</li>
<li class="level1"><div class="li">la nivelul codului, o zonă este reprezentată printr-un file descriptor (<code>int</code>). </div>
</li>
<li class="level1"><div class="li">fișierele antet necesare sunt: <code>&lt;fcntl.h&gt;</code>, <code>&lt;sys/types.h&gt;</code> și <code>&lt;sys/mman.h&gt;</code>.</div>
</li>
</ul>

</div>

<h4 id="crearea_si_deschiderea2">Crearea și deschiderea</h4>
<div class="level4">

<p>
Apelul de creare/deschidere este similar cu semantica apelului <a href="http://linux.die.net/man/2/open" class="urlextern" title="http://linux.die.net/man/2/open" rel="nofollow">open</a> pentru fișiere “obișnuite”, și returnează un descriptor:
</p>
<pre class="code c"><span class="kw4">int</span> shm_open<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="sy0">,</span> mode_t mode<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Ca flag de acces trebuie specificat fie <code>O_RDONLY</code>, fie <code>O_RDWR</code>. 
</p>

</div>

<h4 id="redimensionarea">Redimensionarea</h4>
<div class="level4">

<p>
O zonă de memorie partajată nou creată are dimensiunea inițială zero. Pentru a o dimensiona se folosește <a href="http://linux.die.net/man/2/ftruncate" class="urlextern" title="http://linux.die.net/man/2/ftruncate" rel="nofollow">ftruncate</a>, unde <code>fd</code> este descriptorul iar <code>length</code> este dimensiunea în bytes:
</p>
<pre class="code c"><span class="kw4">int</span> ftruncate<span class="br0">(</span><span class="kw4">int</span> fd<span class="sy0">,</span> <span class="kw4">off_t</span> length<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h4 id="maparea_si_eliberarea">Maparea și eliberarea</h4>
<div class="level4">

<p>
Pentru a putea utiliza o zonă de memorie partajată după deschidere, aceasta trebuie mapată în spațiul de memorie al procesului. Maparea se realizează printr-un apel <a href="http://linux.die.net/man/2/mmap" class="urlextern" title="http://linux.die.net/man/2/mmap" rel="nofollow">mmap</a>:
</p>
<pre class="code c"><span class="kw4">void</span> <span class="sy0">*</span>mmap<span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span>address<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="sy0">,</span> <span class="kw4">int</span> protection<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="sy0">,</span> <span class="kw4">int</span> fd<span class="sy0">,</span> <span class="kw4">off_t</span> offset<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Valoarea întoarsă reprezintă un pointer către începutul zonei de memorie sau <code>MAP_FAILED</code> în caz de eșec.
Acest apel are o largă aplicabilitate și va fi discutat în cadrul laboratorului de <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-07" class="wikilink1" title="so:laboratoare:laborator-07">memorie virtuală</a>. Momentan, pentru a mapa întregul conținut al unei zone (<code>shm_fd</code>) de dimensiune cunoscută (<code>shm_len</code>), recomandăm folosirea apelului:
</p>
<pre class="code c">mem <span class="sy0">=</span> mmap<span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span> shm_len<span class="sy0">,</span> PROT_READ <span class="sy0">|</span> PROT_WRITE<span class="sy0">,</span> MAP_SHARED<span class="sy0">,</span> shm_fd<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Când maparea nu mai este necesară, prin apelul <a href="http://linux.die.net/man/2/munmap" class="urlextern" title="http://linux.die.net/man/2/munmap" rel="nofollow">munmap</a> se realizează demaparea:
</p>
<pre class="code c"><span class="kw4">int</span> munmap<span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span>address<span class="sy0">,</span> <span class="kw4">size_t</span> length<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h4 id="inchiderea_si_stergerea1">Închiderea și ștergerea</h4>
<div class="level4">

<p>
Închiderea unei zone de memorie partajată este identică cu închiderea unui fișier -  apelul <a href="http://linux.die.net/man/2/close" class="urlextern" title="http://linux.die.net/man/2/close" rel="nofollow">close</a>, care primește ca parametru un descriptor. 
</p>

<p>
Odată ce o zonă de memorie a fost demapată și închisă în toate procesele implicate, se poate șterge prin <a href="http://linux.die.net/man/3/shm_unlink" class="urlextern" title="http://linux.die.net/man/3/shm_unlink" rel="nofollow">shm_unlink</a>:
</p>
<pre class="code c"><span class="kw4">int</span> shm_unlink<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Semantica este identică cu cea de la funcțiile <code>*_unlink</code> anterioare - ștergerea efectivă este amânată până ce toate procesele implicate închid zona în cauză sau se termină.
</p>

</div>

<h4 id="exemplu_de_utilizare2">Exemplu de utilizare</h4>
<div class="level4">
<pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;sys/mman.h&gt;</span>
<span class="co2">#include &lt;sys/stat.h&gt;        /* For mode constants */</span>
<span class="co2">#include &lt;fcntl.h&gt;           /* For O_* constants */</span>
<span class="co2">#include &lt;unistd.h&gt;</span>
&nbsp;
<span class="co2">#include "utils.h"</span>
&nbsp;
<span class="co2">#define SHM_NAME	"my_shm"</span>
<span class="co2">#define SHM_SIZE	1024</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">void</span> <span class="sy0">*</span>mem<span class="sy0">;</span>	<span class="coMULTI">/* map address */</span>
	<span class="kw4">int</span> shm_fd<span class="sy0">;</span>	<span class="coMULTI">/* memory descriptor */</span>
	<span class="kw4">int</span> rc<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* create shm */</span>
	shm_fd <span class="sy0">=</span> shm_open<span class="br0">(</span>SHM_NAME<span class="sy0">,</span> O_CREAT <span class="sy0">|</span> O_RDWR<span class="sy0">,</span> <span class="nu8">0644</span><span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>shm_fd <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"shm_open"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* resize shm to fit our needs */</span>
	rc <span class="sy0">=</span> ftruncate<span class="br0">(</span>shm_fd<span class="sy0">,</span> SHM_SIZE<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"ftruncate"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	mem <span class="sy0">=</span> mmap<span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span> SHM_SIZE<span class="sy0">,</span> PROT_WRITE <span class="sy0">|</span> PROT_READ<span class="sy0">,</span> MAP_SHARED<span class="sy0">,</span> shm_fd<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>mem <span class="sy0">==</span> MAP_FAILED<span class="sy0">,</span> <span class="st0">"mmap"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* write number in shm */</span>
	<span class="br0">(</span><span class="br0">(</span><span class="kw4">int</span><span class="sy0">*</span><span class="br0">)</span>mem<span class="br0">)</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">2011</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"mem[0] = %d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="br0">(</span><span class="br0">(</span><span class="kw4">int</span><span class="sy0">*</span><span class="br0">)</span>mem<span class="br0">)</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* unmap shm */</span>
	rc <span class="sy0">=</span> munmap<span class="br0">(</span>mem<span class="sy0">,</span> SHM_SIZE<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"munmap"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* close descriptor */</span>
	rc <span class="sy0">=</span> close<span class="br0">(</span>shm_fd<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"close"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	rc <span class="sy0">=</span> shm_unlink<span class="br0">(</span>SHM_NAME<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>rc <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"unlink"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>

</div>

<h3 class="sectionedit9" id="depanare_posix_ipc">Depanare POSIX IPC</h3>
<div class="level3">

</div>

<h4 id="memoria_partajata1">Memoria partajată</h4>
<div class="level4">

<p>
În Linux, zonele pot fi regăsite în <code>/dev/shm</code>, ca intrări formate din numele dat la creare + suffixul ”.shm”.
</p>

</div>

<h4 id="cozi_de_mesaje1">Cozi de mesaje</h4>
<div class="level4">

<p>
Conținutul cozilor (conținutul mesajelor) nu poate fi vizualizat, însă informații statistice pot fi obținute prin montarea unui pseudo-sistem de fișiere:
</p>
<pre class="code bash"><span class="co4">so@spook$ </span><span class="kw2">sudo</span> <span class="kw2">mkdir</span> <span class="sy0">/</span>mnt<span class="sy0">/</span>cozi<span class="sy0">/</span>
<span class="co4">so@spook$ </span><span class="kw2">sudo</span> <span class="kw2">mount</span> <span class="re5">-t</span> mqueue none <span class="sy0">/</span>mnt<span class="sy0">/</span>cozi<span class="sy0">/</span>
<span class="co4">so@spook$ </span><span class="kw2">cat</span> <span class="sy0">/</span>mnt<span class="sy0">/</span>cozi<span class="sy0">/</span>q_name 
QSIZE:<span class="nu0">12</span>         NOTIFY:<span class="nu0">0</span>     SIGNO:<span class="nu0">0</span>     NOTIFY_PID:<span class="nu0">0</span> </pre>

</div>

<h2 class="sectionedit10" id="windows">Windows</h2>
<div class="level2">

<p>
Sistemul de operare Windows pune la dispoziție o serie de mecanisme de comunicare și schimb de date între aplicații. Cazul de care ne vom ocupa este doar cel în care aceste aplicații sunt procese care rulează pe aceeași mașină.
</p>

<p>
Înainte de a fi prezentate mecanismele de comunicare în sine trebuie introduse <strong>mecanismele de sincronizare</strong>, care sunt folosite pentru controlul accesului la resurse.
</p>

<p>
Mecanismele de sincronizare oferite de sistemul de operare Windows sunt mai multe și mai complexe decât cele din Linux. Pentru sincronizare sunt necesare:
</p>
<ul>
<li class="level1"><div class="li"> unul sau mai multe <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#obiecte_de_sincronizare" title="so:laboratoare:laborator-05 ↵" class="wikilink1">obiecte de sincronizare</a> (<a href="http://msdn.microsoft.com/en-us/library/ms686364%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686364%28VS.85%29.aspx" rel="nofollow">Synchronization Objects</a>) </div>
</li>
<li class="level1"><div class="li"> o <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#functii_de_asteptare" title="so:laboratoare:laborator-05 ↵" class="wikilink1">funcție de așteptare</a> (<a href="http://msdn.microsoft.com/en-us/library/ms687069%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687069%28VS.85%29.aspx" rel="nofollow">Wait Functions</a>).</div>
</li>
</ul>

</div>

<h3 class="sectionedit11" id="functii_de_asteptare">Funcții de așteptare</h3>
<div class="level3">

</div>

<h4 id="asteptare_dupa_un_singur_obiect">Așteptare după un singur obiect</h4>
<div class="level4">

<p>
Aceste funcții așteaptă după un singur obiect de sincronizare. Execuția lor se termină când una dintre următoarele condiții este adevărată :
</p>
<ul>
<li class="level1"><div class="li">Obiectul de sincronizare este în starea <code>signaled</code></div>
</li>
<li class="level1"><div class="li">Timpul de așteptare (time-out) a expirat. Acest timp poate fi setat ca <code>INFINITE</code> - timpul de așteptare nu expiră niciodată.</div>
</li>
</ul>

<p>
<a href="http://msdn.microsoft.com/en-us/library/ms687032(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687032(VS.85).aspx" rel="nofollow">WaitForSingleObject</a> așteaptă după un singur obiect și are sintaxa:
</p>
<pre class="code c"> DWORD  WaitForSingleObject<span class="br0">(</span>
 	HANDLE  hHANDLE<span class="sy0">,</span>
 	DWORD  dwMilliseconds
 <span class="br0">)</span><span class="sy0">;</span></pre>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Funcții de așteptare
</p>
</div><div class="hiddenOnVisible">
<p>
Funcții de așteptare
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Funcții de așteptare
</p>
</div><div class="hiddenBody" style="display: none;">
<p>
Rezultatul întors de aceste funcții poate fi :
</p>
<ul>
<li class="level1"><div class="li"><code>WAIT_OBJECT_0</code> - Succes</div>
</li>
<li class="level1"><div class="li"><code>WAIT_ABANDONED</code> - Obiectul specificat este un mutex care a fost abandonat, adică thread-ul care-l deținea s-a terminat fără să-l elibereze. În acest caz threadul curent va deveni deținătorul mutexului iar starea mutexului va fi <em>nonsignaled</em> (mutex ocupat).</div>
</li>
<li class="level1"><div class="li"><code>WAIT_IO_COMPLETION</code> - Așteptarea a fost întreruptă de un apel asincron de procedură.</div>
</li>
<li class="level1"><div class="li"><code>WAIT_TIMEOUT</code> - Timpul de expirare s-a scurs.</div>
</li>
<li class="level1"><div class="li"><code>WAIT_FAILED</code> - Funcția a eșuat. Informații despre eroare pot fi obținute folosind funcția <code>GetLastError()</code>.</div>
</li>
</ul>

<p>
În continuare sunt prezentate pe larg alte funcții care fac parte din această categorie:
</p>

<p>
<a href="http://msdn.microsoft.com/en-us/library/ms686293(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686293(VS.85).aspx" rel="nofollow">SignalObjectAndWait</a> semnalizează un obiect și așteaptă după altul. Funcția are sintaxa:
</p>
<pre class="code c"> DWORD  SignalObjectAndWait<span class="br0">(</span>
 	HANDLE  hObjectToSignal<span class="sy0">,</span>
 	HANDLE  hObjectToWaitOn<span class="sy0">,</span>
 	DWORD  dwMilliseconds<span class="sy0">,</span>
 	BOOL  bAlertable
 <span class="br0">)</span><span class="sy0">;</span></pre>

<p>
<a href="http://msdn.microsoft.com/en-us/library/ms687036(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687036(VS.85).aspx" rel="nofollow">WaitForSingleObjectEx</a> permite o așteptare alertabilă după un singur obiect și are sintaxa:
</p>
<pre class="code c"> DWORD  WaitForSingleObjectEx<span class="br0">(</span>
 	HANDLE  hHandle<span class="sy0">,</span>
 	DWORD  dwMilliseconds<span class="sy0">,</span>
 	BOOL  bAlertable
 <span class="br0">)</span><span class="sy0">;</span></pre>

<p>
<strong>Așteptare după mai multe obiecte</strong>
</p>

<p>
Aceste funcții așteaptă după mai multe obiecte de sincronizare. Execuția lor se termină când una din următoarele condiții este adevărată:
</p>
<ul>
<li class="level1"><div class="li">Starea unui obiect de sincronizare SAU starea tuturor obiectelor de sincronizare este 'signaled' (depinde de parametri)</div>
</li>
<li class="level1"><div class="li">Timpul de așteptare (time-out) a expirat. Acest timp poate fi setat ca <code>INFINITE</code> pentru a specifica faptul că timpul de așteptare nu va expiră niciodată</div>
</li>
</ul>

<p>
<a href="http://msdn.microsoft.com/en-us/library/ms687025(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687025(VS.85).aspx" rel="nofollow">WaitForMultipleObjects</a> așteaptă după mai multe obiecte și are sintaxa:
</p>
<pre class="code c"> DWORD  WaitForMultipleObjects<span class="br0">(</span>
 	DWORD  nCount<span class="sy0">,</span>
 	<span class="kw4">const</span>  HANDLE<span class="sy0">*</span>  lpHandles<span class="sy0">,</span>
 	BOOL  bWaitAll<span class="sy0">,</span>
	DWORD  dwMilliseconds
 <span class="br0">)</span><span class="sy0">;</span></pre>

<p>
<a href="http://msdn.microsoft.com/en-us/library/ms687028(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687028(VS.85).aspx" rel="nofollow">WaitForMultipleObjectsEx</a> permite o așteptare alertabilă după mai multe obiecte și are sintaxa:
</p>
<pre class="code c"> DWORD  WaitForMultipleObjectsEx<span class="br0">(</span>
 	DWORD  nCount<span class="sy0">,</span>
 	<span class="kw4">const</span>  HANDLE<span class="sy0">*</span>  lpHandles<span class="sy0">,</span>
 	BOOL  bWaitAll<span class="sy0">,</span>
 	DWORD  dwMilliseconds<span class="sy0">,</span>
 	BOOL  bAlertable
 <span class="br0">)</span><span class="sy0">;</span></pre>

<p>
<strong>Așteptare alertabilă și așteptare înregistrată</strong>
</p>

<p>
Funcțiile de așteptare alertabilă sunt:
</p>
<ul>
<li class="level1"><div class="li"><code>WaitForSingleObjectEx()</code></div>
</li>
<li class="level1"><div class="li"><code>WaitForMultipleObjectsEx()</code></div>
</li>
<li class="level1"><div class="li"><code>SignalObjectAndWait()</code></div>
</li>
</ul>

<p>
Aceste funcții oferă posibilitatea de a efectua operații de așteptare alertabile. O operație de așteptare alertabilă se poate termina când:
</p>
<ul>
<li class="level1"><div class="li">condițiile specificate sunt adevărate</div>
</li>
<li class="level1"><div class="li">sistemul programează o rutină de tratare a operațiilor de I/O terminate</div>
</li>
<li class="level1"><div class="li">sistemul programează o rutină de tratare a unui apel asincron terminat</div>
</li>
</ul>

<p>
Controlul alertabilității se realizează prin parametrul <code>BOOL bAlertable</code> pe care aceste funcții îl acceptă.
</p>

<p>
Funcțiile de așteptare înregistrate sunt folosite de programele cu thread-uri și vor fi explicate în laboratoarele care tratează thread-urile.
</p>
</div></div>
<p>
<strong>Atenție!</strong> Obiectele de sincronizare nu pot fi folosite fără funcții de sincronizare.
</p>

</div>

<h3 class="sectionedit12" id="obiecte_de_sincronizare">Obiecte de sincronizare</h3>
<div class="level3">

</div>

<h4 id="mutex-uri">Mutex-uri</h4>
<div class="level4">

</div>

<h5 id="crearea_si_deschiderea3">Crearea și deschiderea</h5>
<div class="level5">

<p>
Sunt operații prin care se  obține un <code>HANDLE</code> al unui obiect de tip mutex. Este necesar doar un singur apel, fie el de creare sau de deschidere (se presupune ca alt proces a creat deja mutex-ul). 
</p>

<p>
Pentru a crea un mutex se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/ms682411(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682411(VS.85).aspx" rel="nofollow">CreateMutex</a> cu sintaxa :
</p>
<table class="columns-plugin" style="width:100%">
<tbody><tr><td class="columns-plugin first" style="width:50%;">
<pre class="code c">HANDLE  CreateMutex<span class="br0">(</span>
     LPSECURITY_ATTRIBUTES lpAttributes<span class="sy0">,</span>
     BOOL bInitialOwner<span class="sy0">,</span>
     LPCTSTR lpName
<span class="br0">)</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last">
<pre class="code c">hMutex <span class="sy0">=</span> CreateMutex<span class="br0">(</span> 
     NULL<span class="sy0">,</span>  <span class="coMULTI">/* default security attributes */</span>
     FALSE<span class="sy0">,</span> <span class="coMULTI">/* initially not owned */</span>
     NULL<span class="sy0">,</span>  <span class="coMULTI">/* unnamed mutex */</span>
<span class="br0">)</span><span class="sy0">;</span> </pre>
</td></tr></tbody></table>

<p>
Pentru a deschide un mutex deja existent este definită funcția <a href="http://msdn.microsoft.com/en-us/library/ms684315(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684315(VS.85).aspx" rel="nofollow">OpenMutex</a> cu sintaxa :
</p>
<table class="columns-plugin" style="width:100%">
<tbody><tr><td class="columns-plugin first" style="width:50%;">
<pre class="code c"> HANDLE  OpenMutex<span class="br0">(</span>
 	DWORD  dwDesiredAccess<span class="sy0">,</span>
 	BOOL  bInheritHandle<span class="sy0">,</span>
 	LPCTSTR  lpName
 <span class="br0">)</span><span class="sy0">;</span></pre>
</td><td class="columns-plugin last">
<pre class="code c">hMutex <span class="sy0">=</span> OpenMutex<span class="br0">(</span> 
        MUTEX_ALL_ACCESS<span class="sy0">,</span>  <span class="coMULTI">/* request full access */</span>
        FALSE<span class="sy0">,</span>             <span class="coMULTI">/* handle not inheritable */</span>
        <span class="st0">"MyMutex"</span>          <span class="coMULTI">/* object name */</span>
<span class="br0">)</span><span class="sy0">;</span>        </pre>
</td></tr></tbody></table>

</div>

<h5 id="obtinerea">Obținerea</h5>
<div class="level5">

<p>
Obținerea unui mutex se realizează folosind una din funcțiile de așteptare tratate anterior.
</p>

<p>
Încercarea de acaparare a unui mutex presupune următorii pași:
</p>
<ul>
<li class="level1"><div class="li"> se verifică daca mutex-ul este disponibil</div>
</li>
<li class="level1"><div class="li"> daca da, îl pot acapara și devine indisponibil, și funcția întoarce succes</div>
</li>
<li class="level1"><div class="li"> daca nu, aștept să devină disponibil, după care îl acaparez, și funcția întoarce succes</div>
</li>
<li class="level1"><div class="li"> la time-out funcția întoarce eroare (atenție: e posibil să nu existe time-out)</div>
</li>
</ul>

<p>
Încercarea de obținere se poate face cu sau fară timp de expirare (time-out) în funcție de parametrii dați funcțiilor de așteptare. Cea mai des folosită funcție de așteptare este <a href="http://msdn.microsoft.com/en-us/library/ms687032%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687032%28VS.85%29.aspx" rel="nofollow">WaitForSingleObject</a>.
</p>

</div>

<h5 id="cedarea">Cedarea</h5>
<div class="level5">

<p>
Folosind funcția <a href="http://msdn.microsoft.com/en-us/library/ms685066(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms685066(VS.85).aspx" rel="nofollow">ReleaseMutex</a> se cedează posesia mutex-ului, el devenind iar disponibil. Funcția are următoarea sintaxa :
</p>
<pre class="code c"> BOOL  ReleaseMutex<span class="br0">(</span>
 	HANDLE  hMutex
 <span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Funcția va eșua dacă procesul nu deține mutex-ul.
</p>

<p>
<strong>Atenție!</strong> pentru a putea folosi această funcție <code>HANDLE</code>-ul trebuie să aibă cel puțin dreptul de acces <code>MUTEX_MODIFY_STATE</code>.
</p>

</div>

<h5 id="distrugerea">Distrugerea</h5>
<div class="level5">

<p>
Operația de <strong>distrugere</strong> a unui mutex este aceeași ca pentru orice <code>HANDLE</code>. Se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/ms724211%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms724211%28VS.85%29.aspx" rel="nofollow">CloseHandle</a>. După ce toate <code>HANDLE</code>-urile unui mutex au fost închise, mutexul este distrus și resursele ocupate de acesta eliberate.
</p>

<p>
<strong>Atenție!</strong> La terminarea execuției unui program toate <code>HANDLE</code>-urile folosite de acesta sunt automat închise. Deci, spre deosebire de semafoarele IPC din Linux, este imposibil ca un mutex (sau semafor) în Windows să mai existe în sistem după ce programele care l-au folosit/creat s-au terminat.
</p>

</div>

<h4 id="semafoare">Semafoare</h4>
<div class="level4">

<p>
Un semafor este un obiect de sincronizare care are intern un contor ce ia doar valori pozitive. Atât timp cât semaforul (contorul) are valori strict pozitive el este considerat disponibil (<em>signaled</em>). Când valoarea semaforului a ajuns la zero el devine indisponibil (<em>nonsignaled</em>) și următoarea încercare de decrementare va duce la o blocare a threadului/procesului de pe care s-a făcut apelul până când semaforul devine disponibil.
</p>

<p>
Operația de decrementare se realizează doar cu o singură unitate (la fel ca în <abbr title="Application Programming Interface">API</abbr>-ul POSIX), în timp ce incrementarea se poate realiza cu orice valoare în limita maximă.
</p>

</div>

<h5 id="crearea_si_deschiderea4">Crearea și deschiderea</h5>
<div class="level5">

<p>
Funcția de creare a semafoarelor este <a href="http://msdn.microsoft.com/en-us/library/ms682438(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682438(VS.85).aspx" rel="nofollow">CreateSemaphore</a> și are sintaxa :
</p>
<pre class="code c"> HANDLE  CreateSemaphore<span class="br0">(</span>
 	LPSECURITY_ATTRIBUTES  lpSemaphoreAttributes<span class="sy0">,</span>
 	LONG  lInitialCount<span class="sy0">,</span>
 	LONG  lMaximumCount<span class="sy0">,</span>
 	LPCTSTR  lpNAME
 <span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Această funcție se poate folosi și pentru deschiderea unui semafor deja existent. Alternativ, pentru a folosi un semafor deja existent, este necesar obținerea <code>HANDLE</code>-ului semaforului, operație ce se realizează folosind funcția <a href="http://msdn.microsoft.com/en-us/library/ms684326.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms684326.aspx" rel="nofollow">OpenSemaphore</a> cu următoarea sintaxă :
</p>
<pre class="code c"> HANDLE  OpenSemaphore<span class="br0">(</span>
 	DWORD  dwDesiredAccess<span class="sy0">,</span>
 	BOOL  bInheritHandle<span class="sy0">,</span>
 	LPCTSTR  lpNAME
 <span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h5 id="decrementarea_asteptarea">Decrementarea (așteptarea)</h5>
<div class="level5">

<p>
Operația de decrementare a semaforului cu sau fără așteptare se realizează folosind una din funcțiile de așteptare. Cea mai des folosită este funcția <a href="http://msdn.microsoft.com/en-us/library/ms687032(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687032(VS.85).aspx" rel="nofollow">WaitForSingleObject</a>.
</p>

</div>

<h5 id="incrementarea">Incrementarea</h5>
<div class="level5">

<p>
Incrementarea semaforului se realizează folosind funcția <a href="http://msdn.microsoft.com/en-us/library/ms685071(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms685071(VS.85).aspx" rel="nofollow">ReleaseSemaphore</a> cu sintaxa :
</p>
<pre class="code c"> BOOL  ReleaseSemaphore<span class="br0">(</span>
 	HANDLE  hSemaphore<span class="sy0">,</span>
 	LONG  lReleaseCount<span class="sy0">,</span>
 	LPLONG  lpPreviousCount
 <span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h5 id="distrugerea1">Distrugerea</h5>
<div class="level5">

<p>
Operația de distrugere a unui semafor este similară cu cea de distrugere a unui mutex. Se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/ms724211%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms724211%28VS.85%29.aspx" rel="nofollow">CloseHandle</a>. După ce toate <code>HANDLE</code>-urile unui semafor au fost închise, semaforul este distrus și resursele ocupate de acesta eliberate.
</p>

</div>

<h3 class="sectionedit13" id="cozi_de_mesaje_mailslots">Cozi de mesaje (Mailslots)</h3>
<div class="level3">

<p>
Cozile de mesaje sunt un fel de pseudo-fișiere care rezidă în memorie. De aceea, pot fi gestionate prin intermediul funcțiilor standard de acces la fișiere. Fiind păstrate în memorie, toate aceste date au un caracter volatil, spre deosebire de fișiere, iar când toate handle-urile la un mailslot sunt distruse, acesta la rândul său, este distrus împreună cu datele, iar memoria este eliberată (spre deosebire de cozile de mesaje de pe Linux).
</p>

<p>
Au următoarele caracteristici:
</p>
<ul>
<li class="level1"><div class="li">Sunt unidrecționale.</div>
</li>
<li class="level1"><div class="li">Pot exista mai mulți cititori și mai mulți scriitori, dar cel mai frecvent se folosește o arhitectură one-to-many.</div>
</li>
<li class="level1"><div class="li">Un scriitor nu știe sigur dacă mesajul său a ajuns la cititor.</div>
</li>
<li class="level1"><div class="li">Dimensiunea mesajelor e limitată.</div>
</li>
<li class="level1"><div class="li">Datorită modului de numire, se pot transmite mesaje prin rețea. </div>
</li>
</ul>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Detalii despre limitări
</p>
</div><div class="hiddenOnVisible">
<p>
Detalii despre limitări
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Detalii despre limitări
</p>
</div><div class="hiddenBody" style="display: none;"><ul>
<li class="level1"><div class="li">Mesajele de tip broadcast sunt limitate la maximum 424 bytes, iar încercarea de a trimite un mesaj broadcast mai mare va eșua, iar funcția va întoarce eroare.</div>
</li>
<li class="level1"><div class="li"><strong>NU</strong> pot fi trimise mesaje de lungime 425 bytes sau 426 bytes.</div>
</li>
<li class="level1"><div class="li">Lungimea maximă a unui mesaj este 64 Kbytes.</div>
</li>
</ul>
</div></div>
<p>
<br>

</p>

<p>
Un exemplu tipic de folosire este următorul:
</p>
<ul>
<li class="level1"><div class="li"> <code>serverul mailslot</code> creează coada folosind <code>CreateMailslot</code>, apoi așteaptă să primească un mesaj folosind un apel <code>ReadFile</code></div>
</li>
<li class="level1"><div class="li"> <code>clientul mailslot</code> deschide coada folosind <code>CreateFile</code>, apoi transmite un mesaj folosind un apel <code>WriteFile</code>.</div>
</li>
</ul>

</div>

<h4 id="crearea">Crearea</h4>
<div class="level4">

<p>
Când un proces creează un mailslot, trebuie să-i atribuie o <strong>denumire</strong> de forma:
</p>
<pre class="code c"> \\.\mailslot\<span class="br0">[</span>path<span class="br0">]</span><span class="sy0">&lt;</span>nume<span class="sy0">&gt;</span></pre>

<p>
<strong>Atenție!</strong> Prefixul “\\.\mailslot\” trebuie să existe exact în această formă, el fiind urmat de un nume, care eventual va fi precedat de o cale. Calea este asemănătoare cu cea a fișierelor. Un exemplu valid: “\\.\mailslot\test\commands”.
</p>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Click to display ⇲
</p>
</div><div class="hiddenBody" style="display: none;">
<p>
Cozile de mesaje pot fi folosite și pentru a comunica cu procese care rulează pe alte calculatoare. În acest caz, clientul va folosi denumiri care au structura:
</p>
<pre class="code c"> \\<span class="sy0">&lt;</span>ComputerName<span class="sy0">&gt;</span>\mailslot\<span class="br0">[</span>path<span class="br0">]</span><span class="sy0">&lt;</span>Nume<span class="sy0">&gt;</span></pre>

<p>
Pentru a trimite mesaje unui întreg domeniu, denumirea va avea structura:
</p>
<pre class="code c"> \\<span class="sy0">&lt;</span>DomainName<span class="sy0">&gt;</span>\mailslot\<span class="br0">[</span>path<span class="br0">]</span><span class="sy0">&lt;</span>Nume<span class="sy0">&gt;</span></pre>

<p>
Pentru a trimite mesaje tuturor, denumirea va avea structura:
</p>
<pre class="code c"> \\<span class="sy0">*</span>\mailslot\<span class="br0">[</span>path<span class="br0">]</span><span class="sy0">&lt;</span>Nume<span class="sy0">&gt;</span></pre>
</div></div>
<p>
Pentru a crea o coadă de mesaje, se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/aa365147(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365147(VS.85).aspx" rel="nofollow">CreateMailslot</a> care are următoarea sintaxă și întoarce un handle:
</p>
<pre class="code c">HANDLE  CreateMailslot<span class="br0">(</span>
 	LPCTSTR  lpName<span class="sy0">,</span>
 	DWORD  nMaxMessageSize<span class="sy0">,</span>
 	DWORD  lReadTimeout<span class="sy0">,</span>
 	LPSECURITY_ATTRIBUTES  lpSecurityAttributes
<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
În cazul în care se încearcă crearea unei cozi de mesaje cu o denumire deja existentă, se va întoarce <code>INVALID_HANDLE_VALUE</code>.
</p>

<p>
<strong>Atenție!</strong> Handle-ul întors de această funcție poate fi folosit pentru a efectua doar operații de citire (nu și de scriere) cu coada de mesaje.
</p>

</div>

<h4 id="deschiderea_unei_cozi_existente">Deschiderea unei cozi existente</h4>
<div class="level4">

<p>
Pentru a deschide o coada de mesaje pentru scriere, se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/aa363858%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa363858%28VS.85%29.aspx" rel="nofollow">CreateFile</a> care va primi în loc de numele fișierului denumirea cozii de mesaje care se dorește a fi deschisă și flagul <code>FILE_SHARE_READ</code>. Pentru a permite accesul concomitent al mai multor clienți, trebuie adăugat și flagul <code>FILE_SHARE_WRITE</code>.
</p>

</div>

<h4 id="scrierea_si_citirea">Scrierea și citirea</h4>
<div class="level4">

<p>
Citirea, respectiv scrierea din/în cozile de mesaje sunt asemănătoare cu operațiile cu fișiere, folosindu-se aceleași funcții:
</p>
<ul>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365467%28VS.85%29.aspx" rel="nofollow">ReadFile</a> și <a href="http://msdn.microsoft.com/en-us/library/aa365468%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365468%28VS.85%29.aspx" rel="nofollow">ReadFileEx</a> - pentru citire</div>
</li>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365747%28VS.85%29.aspx" rel="nofollow">WriteFile</a> și <a href="http://msdn.microsoft.com/en-us/library/aa365748%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365748%28VS.85%29.aspx" rel="nofollow">WriteFileEx</a> - pentru scriere</div>
</li>
</ul>

</div>

<h4 id="obtinerea_de_informatii_despre_o_coada_de_mesaje">Obținerea de informații despre o coada de mesaje</h4>
<div class="level4">

<p>
Pentru a obține informații despre o coadă de mesaje, se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/aa365435%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365435%28VS.85%29.aspx" rel="nofollow">GetMailslotInfo</a> ce are următoarea sintaxă:
</p>
<pre class="code c">BOOL  GetMailslotInfo<span class="br0">(</span>
 	HANDLE  hMailslot<span class="sy0">,</span>
 	LPDWORD  lpMaxMessageSize<span class="sy0">,</span>
 	LPDWORD  lpNextSize<span class="sy0">,</span>
 	LPDWORD  lpMessageCount<span class="sy0">,</span>
 	LPDWORD  lpReadTimeout
<span class="br0">)</span><span class="sy0">;</span></pre>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Detalii despre schimbarea timpului de expirare
</p>
</div><div class="hiddenOnVisible">
<p>
Detalii despre schimbarea timpului de expirare
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Detalii despre schimbarea timpului de expirare
</p>
</div><div class="hiddenBody" style="display: none;">
<p>
<br>

</p>

<p>
<strong>Schimbarea timpului de expirare</strong>
</p>

<p>
Singura caracteristică a unei cozi de mesaje, care poate fi schimbată după ce coada a fost creată, este timpul de expirare. (Dimensiunea maximă a mesajelor acceptate de o coadă <strong>nu</strong> mai poate fi schimbată după ce aceasta a fost creată)
</p>

<p>
Funcția care setează această caracteristică este <a href="http://msdn.microsoft.com/en-us/library/aa365786%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365786%28VS.85%29.aspx" rel="nofollow">SetMailslotInfo</a> și are următoarea sintaxă:
</p>
<pre class="code c">BOOL  SetMailslotInfo<span class="br0">(</span>
 	HANDLE  hMailslot<span class="sy0">,</span>
 	DWORD  lReadTimeout
 <span class="br0">)</span><span class="sy0">;</span></pre>
</div></div>
</div>

<h4 id="exemplu_de_utilizare3">Exemplu de utilizare</h4>
<div class="level4">
<dl class="code">
<dt><a href="http://ocw.cs.pub.ro/courses/_export/code/so/laboratoare/laborator-05?codeblock=43" title="Download Snippet" class="mediafile mf_c">MailslotServer.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;windows.h&gt;</span>
<span class="co2">#include "utils.h"</span>
&nbsp;
LPSTR lpszSlotName <span class="sy0">=</span> <span class="st0">"<span class="es1">\\</span><span class="es1">\\</span>.<span class="es1">\\</span>mailslot<span class="es1">\\</span>sample_mailslot"</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
	DWORD cbMessage<span class="sy0">,</span> cMessage<span class="sy0">,</span> cbRead<span class="sy0">,</span> dwRet<span class="sy0">;</span> 
	HANDLE hMailslot<span class="sy0">;</span>
	BOOL bRet<span class="sy0">;</span>
	LPSTR lpszBuffer<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Create Mailslot */</span>
	hMailslot <span class="sy0">=</span> CreateMailslot<span class="br0">(</span>
		lpszSlotName<span class="sy0">,</span>
		<span class="nu0">0</span><span class="sy0">,</span>                     <span class="coMULTI">/* no maximum message size */</span>
		MAILSLOT_WAIT_FOREVER<span class="sy0">,</span> <span class="coMULTI">/* no expiration period */</span>
		NULL<span class="br0">)</span><span class="sy0">;</span>                 <span class="coMULTI">/* no security attributes */</span>
	DIE<span class="br0">(</span>hMailslot <span class="sy0">==</span> INVALID_HANDLE_VALUE<span class="sy0">,</span> <span class="st0">"CreateMailSlot"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
        <span class="coMULTI">/* Timeout - waiting for clients */</span>
	Sleep<span class="br0">(</span><span class="nu0">5000</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Get number of messages form Mailslot */</span>
	bRet <span class="sy0">=</span> GetMailslotInfo<span class="br0">(</span> 
		hMailslot<span class="sy0">,</span>             <span class="coMULTI">/* mailslot handle */</span>
		<span class="br0">(</span>LPDWORD<span class="br0">)</span> NULL<span class="sy0">,</span>        <span class="coMULTI">/* no maximum message size */</span>
		<span class="sy0">&amp;</span>cbMessage<span class="sy0">,</span>            <span class="coMULTI">/* size of next message */</span>
		<span class="sy0">&amp;</span>cMessage<span class="sy0">,</span>             <span class="coMULTI">/* number of messages */</span>
		<span class="br0">(</span>LPDWORD<span class="br0">)</span> NULL<span class="br0">)</span><span class="sy0">;</span>       <span class="coMULTI">/* no read time-out */</span>
	DIE<span class="br0">(</span>bRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"GetMailslotInfo"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Read all messages from Mailslot */</span>
	<span class="kw1">while</span> <span class="br0">(</span>cMessage <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
&nbsp;
 		lpszBuffer <span class="sy0">=</span> HeapAlloc<span class="br0">(</span>GetProcessHeap<span class="br0">(</span><span class="br0">)</span><span class="sy0">,</span> HEAP_ZERO_MEMORY<span class="sy0">,</span> cbMessage<span class="br0">)</span><span class="sy0">;</span>
		DIE<span class="br0">(</span>lpszBuffer <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">"HeapAlloc"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		bRet <span class="sy0">=</span> ReadFile<span class="br0">(</span>
			hMailslot<span class="sy0">,</span>
 			lpszBuffer<span class="sy0">,</span>
 			cbMessage<span class="sy0">,</span>
 			<span class="sy0">&amp;</span>cbRead<span class="sy0">,</span>
 			<span class="br0">(</span>LPOVERLAPPED<span class="br0">)</span> NULL<span class="br0">)</span><span class="sy0">;</span>
		DIE<span class="br0">(</span>bRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"ReadFile from Mailslot"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"Received: %s<span class="es1">\n</span>"</span><span class="sy0">,</span> lpszBuffer<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		HeapFree<span class="br0">(</span>GetProcessHeap<span class="br0">(</span><span class="br0">)</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> lpszBuffer<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		bRet <span class="sy0">=</span> GetMailslotInfo<span class="br0">(</span> 
			hMailslot<span class="sy0">,</span>     <span class="coMULTI">/* mailslot handle */</span>
			NULL<span class="sy0">,</span>          <span class="coMULTI">/* no maximum message size */</span>
			<span class="sy0">&amp;</span>cbMessage<span class="sy0">,</span>    <span class="coMULTI">/* size of next message */</span>
			<span class="sy0">&amp;</span>cMessage<span class="sy0">,</span>     <span class="coMULTI">/* number of messages */</span>
			NULL<span class="br0">)</span><span class="sy0">;</span>         <span class="coMULTI">/* no read time-out */</span>
		DIE<span class="br0">(</span>bRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"GetMailslotInfo"</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span> <span class="coMULTI">/* end while */</span>
&nbsp;
	dwRet <span class="sy0">=</span> CloseHandle<span class="br0">(</span>hMailslot<span class="br0">)</span><span class="sy0">;</span>
	DIE <span class="br0">(</span>dwRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"CloseHandle"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</dd></dl>
<dl class="code">
<dt><a href="http://ocw.cs.pub.ro/courses/_export/code/so/laboratoare/laborator-05?codeblock=44" title="Download Snippet" class="mediafile mf_c">MailslotClient.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;windows.h&gt;</span>
<span class="co2">#include "utils.h"</span>
&nbsp;
LPSTR lpszSlotName <span class="sy0">=</span> <span class="st0">"<span class="es1">\\</span><span class="es1">\\</span>.<span class="es1">\\</span>mailslot<span class="es1">\\</span>sample_mailslot"</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
	HANDLE hMailslot<span class="sy0">;</span>
	BOOL bRet<span class="sy0">;</span>
	DWORD cbWritten<span class="sy0">,</span> dwRet<span class="sy0">;</span>
	LPSTR lpszBuffer <span class="sy0">=</span> <span class="st0">"Testing Mailslot"</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Open Mailslot */</span>
	hMailslot <span class="sy0">=</span> CreateFile<span class="br0">(</span>
		lpszSlotName<span class="sy0">,</span>
 		GENERIC_WRITE<span class="sy0">,</span>  
 		FILE_SHARE_READ<span class="sy0">,</span>
 		NULL<span class="sy0">,</span>		
 		OPEN_EXISTING<span class="sy0">,</span>  
 		FILE_ATTRIBUTE_NORMAL<span class="sy0">,</span>
 		NULL<span class="br0">)</span><span class="sy0">;</span>		
	DIE<span class="br0">(</span>hMailslot <span class="sy0">==</span> INVALID_HANDLE_VALUE<span class="sy0">,</span> <span class="st0">"CreateFile"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Send message */</span>
	bRet <span class="sy0">=</span> WriteFile<span class="br0">(</span>
		hMailslot<span class="sy0">,</span>
 		lpszBuffer<span class="sy0">,</span>
 		<span class="br0">(</span>DWORD<span class="br0">)</span> lstrlen<span class="br0">(</span>lpszBuffer<span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span>
 		<span class="sy0">&amp;</span>cbWritten<span class="sy0">,</span>
 		NULL<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>bRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"Write file to Mailslot"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"Message successfully send<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* Close Mailslot */</span>
	dwRet <span class="sy0">=</span> CloseHandle<span class="br0">(</span>hMailslot<span class="br0">)</span><span class="sy0">;</span>
	DIE <span class="br0">(</span>dwRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"CloseHandle"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</dd></dl>

</div>

<h3 class="sectionedit14" id="memorie_partajata_filemapping">Memorie partajată (FileMapping)</h3>
<div class="level3">

<p>
Memoria partajată permite accesul mai multor procese la un fișier ca și când fișierul ar fi o zonă de memorie. Astfel se pot folosi toate operațiile aplicabile asupra memoriei, inclusiv pointeri.
</p>

<p>
O facilitate specială a <code>FileMapping</code> este aceea de memorie partajată identificată printr-un nume (<code>named shared memory</code>).
</p>

<p>
<strong>Atenție!</strong> Accesul la o zonă de memorie partajată trebuie reglementat folosind unul din mecanismele de sincronizare descrise mai sus!
</p>

</div>

<h4 id="crearea_unei_zone_de_memorie_partajata">Crearea unei zone de memorie partajată</h4>
<div class="level4">

<p>
Pentru crearea unei zone de memorie partajată se folosesc două funcții care trebuie apelate în această ordine :
</p>
<ol>
<li class="level1"><div class="li"> <a href="http://msdn.microsoft.com/en-us/library/aa366537(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366537(VS.85).aspx" rel="nofollow">CreateFileMapping</a> - este o funcție pregătitoare care creează un obiect de tipul <code>File Mapping</code>, reprezentat de un <code>HANDLE</code>.</div>
</li>
<li class="level1"><div class="li"> <a href="http://msdn.microsoft.com/en-us/library/aa366761(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366761(VS.85).aspx" rel="nofollow">MapViewOfFile</a> - pentru a mapa efectiv zona de memorie. Funcția întoarce un pointer la zona de memorie partajată.</div>
</li>
</ol>

<p>
<a href="http://msdn.microsoft.com/en-us/library/aa366537(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366537(VS.85).aspx" rel="nofollow">CreateFileMapping</a> creează o resursă (un obiect) de tipul <code>FileMapping</code> și are următoarea sintaxă :
</p>
<pre class="code c">HANDLE  CreateFileMapping<span class="br0">(</span>
 	HANDLE  hFile<span class="sy0">,</span>
 	LPSECURITY_ATTRIBUTES  lpAttributes<span class="sy0">,</span>
 	DWORD  flProtect<span class="sy0">,</span>
 	DWORD  dwMaximumSizeHigh<span class="sy0">,</span>
 	DWORD  dwMaximumSizeLow<span class="sy0">,</span>
 	LPCTSTR  lpName
<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Dacă există un obiect cu același nume, dar de alt tip, funcția va eșua și va întoarce <code>NULL</code>.
</p>

<p>
<a href="http://msdn.microsoft.com/en-us/library/aa366761(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366761(VS.85).aspx" rel="nofollow">MapViewOfFile</a> întoarce un pointer la zona de memorie partajată și are sintaxa :
</p>
<pre class="code c">LPVOID  MapViewOfFile<span class="br0">(</span>
 	HANDLE  hFileMappingObject<span class="sy0">,</span>
 	DWORD  dwDesiredAccess<span class="sy0">,</span>
 	DWORD  dwFileOffsetHigh<span class="sy0">,</span>
 	DWORD  dwFileOffsetLow<span class="sy0">,</span>
 	SIZE_T  dwNumberOfBytesToMap
<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h4 id="accesul_la_o_zona_de_memorie_partajata_deja_creata">Accesul la o zonă de memorie partajată deja creată</h4>
<div class="level4">

<p>
Pentru a accesa o zonă de memorie partajată, creată de alt proces, se utilizează următoarele funcții (în ordinea specificată) :
</p>
<ol>
<li class="level1"><div class="li"> <code>OpenFileMapping</code> - o funcție pregătitoare care accesează (deschide) un obiect de tipul <code>File Mapping</code>.</div>
</li>
<li class="level1"><div class="li"> <code>MapViewOfFile</code> - pentru a mapa efectiv zona de memorie.</div>
</li>
</ol>

<p>
<a href="http://msdn.microsoft.com/en-us/library/aa366791(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366791(VS.85).aspx" rel="nofollow">OpenFileMapping</a> accesează o resursă/obiect deja existent de tipul <code>FileMapping</code> și are sintaxa :
</p>
<pre class="code c">HANDLE  OpenFileMapping<span class="br0">(</span>
 	DWORD  dwDesiredAccess<span class="sy0">,</span>
 	BOOL  bInheritHandle<span class="sy0">,</span>
 	LPCTSTR  lpName
<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h4 id="demaparea_unei_zone_de_memorie_partajata">Demaparea unei zone de memorie partajată</h4>
<div class="level4">

<p>
Pentru a demapa o zonă de memorie partajată, care a fost anterior mapată folosind funcția <code>MapViewOfFile()</code>, se folosește funcția <a href="http://msdn.microsoft.com/en-us/library/aa366882%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa366882%28VS.85%29.aspx" rel="nofollow">UnmapViewOfFile</a> care are următoarea sintaxă :
</p>
<pre class="code c">BOOL UnmapViewOfFile<span class="br0">(</span>
 	LPCVOID lpBaseAddress
<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h4 id="exemple_de_utilizare">Exemple de utilizare</h4>
<div class="level4">

<p>
Serverul creează o zonă de memorie partajată, iar apoi așteaptă un interval de timp. Clientul deschide zona de memorie partajată și scrie un mesaj la începutul ei. Serverul termină așteptarea și afișează conținutul zonei de memorie.
</p>
<dl class="code">
<dt><a href="http://ocw.cs.pub.ro/courses/_export/code/so/laboratoare/laborator-05?codeblock=49" title="Download Snippet" class="mediafile mf_c">ServerSHM.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;windows.h&gt;</span>
<span class="co2">#include "utils.h"</span>
&nbsp;
<span class="co2">#define BUF_SIZE 256</span>
LPSTR szMapName <span class="sy0">=</span> <span class="st0">"MyFileMappingObject"</span><span class="sy0">;</span>
LPSTR szMsg <span class="sy0">=</span> <span class="st0">"Testing shared memory on windows"</span><span class="sy0">;</span>
&nbsp;
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
	HANDLE hMapFile<span class="sy0">;</span>
	LPVOID lpMapAddress<span class="sy0">;</span>
	BOOL bRet<span class="sy0">;</span>
&nbsp;
	hMapFile <span class="sy0">=</span> CreateFileMapping<span class="br0">(</span>
		INVALID_HANDLE_VALUE<span class="sy0">,</span>         <span class="coMULTI">/* use swap, not a particular file */</span>
		NULL<span class="sy0">,</span>		              <span class="coMULTI">/* default security */</span>
		PAGE_READWRITE<span class="sy0">,</span>	              <span class="coMULTI">/* read/write access */</span>
		<span class="nu0">0</span><span class="sy0">,</span>	                      <span class="coMULTI">/* maximum object size (high-order DWORD) */</span>
		<span class="nu0">1024</span><span class="sy0">,</span>		              <span class="coMULTI">/* maximum object size (low-order DWORD) */</span>
		szMapName<span class="br0">)</span><span class="sy0">;</span>	              <span class="coMULTI">/* name of mapping object */</span>
	DIE<span class="br0">(</span>hMapFile <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">"CreateFileMapping"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	lpMapAddress <span class="sy0">=</span> MapViewOfFile<span class="br0">(</span>
			hMapFile<span class="sy0">,</span>	      <span class="coMULTI">/* handle to map object */</span>
			FILE_MAP_ALL_ACCESS<span class="sy0">,</span>  <span class="coMULTI">/* read/write permission */</span>
			<span class="nu0">0</span><span class="sy0">,</span>		      <span class="coMULTI">/* offset (high-order) */</span>
			<span class="nu0">0</span><span class="sy0">,</span>		      <span class="coMULTI">/* offset (low-order) */</span>
			<span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>lpMapAddress <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">"MapViewOfFile"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	ZeroMemory<span class="br0">(</span>lpMapAddress<span class="sy0">,</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/strlen.html"><span class="kw3">strlen</span></a><span class="br0">(</span>szMsg<span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
	CopyMemory<span class="br0">(</span>lpMapAddress<span class="sy0">,</span> szMsg<span class="sy0">,</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/strlen.html"><span class="kw3">strlen</span></a><span class="br0">(</span>szMsg<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	Sleep<span class="br0">(</span><span class="nu0">5000</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	bRet <span class="sy0">=</span> UnmapViewOfFile<span class="br0">(</span>lpMapAddress<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>bRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"UnampViewOfFile"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	bRet <span class="sy0">=</span> CloseHandle<span class="br0">(</span>hMapFile<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>bRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"CloseHandle"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</dd></dl>
<dl class="code">
<dt><a href="http://ocw.cs.pub.ro/courses/_export/code/so/laboratoare/laborator-05?codeblock=50" title="Download Snippet" class="mediafile mf_c">ClientSHM.c</a></dt>
<dd><pre class="code C"><span class="co2">#include &lt;windows.h&gt;</span>
<span class="co2">#include "utils.h"</span>
&nbsp;
<span class="co2">#define BUF_SIZE 256</span>
LPSTR szMapName <span class="sy0">=</span> <span class="st0">"MyFileMappingObject"</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
	HANDLE hMapFile<span class="sy0">;</span>
	LPVOID lpMapAddress<span class="sy0">;</span>
	BOOL bRet<span class="sy0">;</span>
&nbsp;
	hMapFile <span class="sy0">=</span> OpenFileMapping<span class="br0">(</span>
           FILE_MAP_ALL_ACCESS<span class="sy0">,</span>                 <span class="coMULTI">/* read/write access */</span>
           FALSE<span class="sy0">,</span>                               <span class="coMULTI">/* do not inherit the name */</span>
           szMapName<span class="br0">)</span><span class="sy0">;</span>                          <span class="coMULTI">/* name of mapping object */</span> 
	DIE<span class="br0">(</span>hMapFile <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">"CreateFileMapping"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	lpMapAddress <span class="sy0">=</span> MapViewOfFile<span class="br0">(</span>
			hMapFile<span class="sy0">,</span>		<span class="coMULTI">/* handle to map object */</span>
			FILE_MAP_ALL_ACCESS<span class="sy0">,</span>	<span class="coMULTI">/* read/write permission */</span>
			<span class="nu0">0</span><span class="sy0">,</span>			<span class="coMULTI">/* offset (high-order) */</span>
			<span class="nu0">0</span><span class="sy0">,</span>			<span class="coMULTI">/* offset (low-order) */</span>
			<span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>lpMapAddress <span class="sy0">==</span> NULL<span class="sy0">,</span> <span class="st0">"MapViewOfFile"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"Message in shm is: &lt;%s&gt;<span class="es1">\n</span>"</span><span class="sy0">,</span> lpMapAddress<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	bRet <span class="sy0">=</span> UnmapViewOfFile<span class="br0">(</span>lpMapAddress<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>bRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"UnampViewOfFile"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	bRet <span class="sy0">=</span> CloseHandle<span class="br0">(</span>hMapFile<span class="br0">)</span><span class="sy0">;</span>
	DIE<span class="br0">(</span>bRet <span class="sy0">==</span> FALSE<span class="sy0">,</span> <span class="st0">"CloseHandle"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</dd></dl>

</div>

<h2 class="sectionedit15" id="exercitii_de_laborator">Exerciții de laborator</h2>
<div class="level2">

<p>
În rezolvarea laboratorului folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab05-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab05-tasks.zip" rel="nofollow"> lab05-tasks.zip</a>
</p>

<p>
</p><p></p><div class="noteimportant"><strong>Platforma pe care rezolvați exercițiile este la alegere</strong>
</div><p></p>
<p></p>

</div>

<h3 class="sectionedit16" id="linux1">Linux</h3>
<div class="level3">

<p>
<strong>Atenție!</strong>
</p>
<ul>
<li class="level1"><div class="li"> Asigurați-vă că în timpul rulării exercițiilor nu există resurse IPC cu același nume create anterior. Folosiți comanda <code>make clean</code> care va șterge resursele alocate (și eventual prost eliberate)</div>
</li>
<li class="level1"><div class="li"> Nu confundați variabila globală <code>errno</code> cu valoarea de retur a unei funcții. Un apel de sistem va întoarce o anumită valoare de return în caz de eroare și va seta variabila globală <code>errno</code> astfel încât să indice motivul erorii.</div>
</li>
</ul>

<p>
Întrucât  la toate exercițiile veți avea nevoie de două console deschise în paralel, pe Linux, este recomandat să vă instalați <strong>terminator</strong>. 
</p>
<pre class="code bash"><span class="kw2">sudo</span> <span class="kw2">apt-get install</span> terminator
Ctrl+Shift+O -<span class="sy0">&gt;</span> open hOrizontal tab
Ctrl+Shift+E -<span class="sy0">&gt;</span> open vErtical tab
Ctrl+Shift+N -<span class="sy0">&gt;</span> move to Next tab
Ctrl+Shift+P -<span class="sy0">&gt;</span> move to Previous tab
Ctrl+Shift+W -<span class="sy0">&gt;</span> close current tab</pre>
<ol>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Intrați în directorul <code>1-fun/</code>:</div>
<ul>
<li class="level2"><div class="li">Programul <code>sem.c</code> creează un semafor și îl incrementează de fiecare dată când apăsați o tastă.</div>
</li>
<li class="level2"><div class="li">Rulați programul și observați cum se schimbă conținutul fișierului <code>/dev/shm/sem.my_sem</code> la apăsarea unei taste. Ce se întâmplă cu fișierul <code>/dev/shm/sem.my_sem</code> când terminați normal programul? Dar când îl terminați folosind <code>Ctrl+C</code>?<pre class="code bash"><span class="co4">console1$ </span>.<span class="sy0">/</span>sem 
Press any key to <span class="kw3">continue</span> <span class="br0">(</span>E<span class="sy0">/</span>e to <span class="kw3">exit</span><span class="br0">)</span></pre>
<pre class="code bash"><span class="co4">console2$ </span><span class="kw2">watch</span> <span class="re5">-n</span> <span class="nu0">1</span> <span class="re5">-d</span> <span class="st_h">'cat /dev/shm/sem.my_sem | hexdump -d -n 1'</span></pre>
</div>
</li>
<li class="level2"><div class="li">Programul <code>shm.c</code> creează o zonă de memorie partajată și scrie  în ea un șir de caractere. Analizați conținutul fișierului <code>/dev/shm/my_shm</code>. Observați ce se întâmplă cu zona de memorie partajată când programul <code>shm.c</code> se încheie normal (apăsați orice tastă) sau când este întrerupt folosind <code>Ctrl+C</code>.<pre class="code bash"><span class="co4">console1$ </span>.<span class="sy0">/</span>shm 
Press any key to continue...</pre>
<pre class="code bash"><span class="co4">console2$ </span><span class="kw2">cat</span> <span class="sy0">/</span>dev<span class="sy0">/</span>shm<span class="sy0">/</span>my_shm <span class="sy0">|</span> <span class="kw2">hexdump</span> <span class="re5">-c</span> </pre>
</div>
</li>
<li class="level2"><div class="li">Programul <code>mq.c</code> creează o coadă de mesaje și pune un mesaj în coadă la fiecare apăsare a unei taste. În Linux cozile de mesaje sunt create într-un sistem de fișiere virtual. Acest sistem de fișiere poate fi montat în ierarhia voastră de fișiere astfel:<pre class="code bash">$ <span class="kw2">sudo</span> <span class="kw2">mkdir</span> <span class="sy0">/</span>dev<span class="sy0">/</span>mqueue
$ <span class="kw2">sudo</span> <span class="kw2">mount</span> <span class="re5">-t</span> mqueue none <span class="sy0">/</span>dev<span class="sy0">/</span>mqueue</pre>
</div>
</li>
<li class="level2"><div class="li">Rulați programul <code>mq</code> și observați cum crește dimensiunea cozii la fiecare mesaj pus în coadă.<pre class="code bash"><span class="co4">console1$ </span>.<span class="sy0">/</span>mq
Press any key to <span class="kw3">continue</span> <span class="br0">(</span>E<span class="sy0">/</span>e <span class="kw3">exit</span><span class="br0">)</span></pre>
<pre class="code bash"><span class="co4">console2$ </span><span class="kw2">watch</span> <span class="re5">-n</span> <span class="nu0">1</span> <span class="kw2">cat</span> <span class="sy0">/</span>dev<span class="sy0">/</span>mqueue<span class="sy0">/</span>my_mqueue </pre>
</div>
</li>
</ul>
</li>
</ol>

</div>

<h3 class="sectionedit17" id="windows1">Windows</h3>
<div class="level3">
<ol>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) IPC între calculatoare</div>
<ol>
<li class="level2"><div class="li"> Initial setup</div>
<ul>
<li class="level3"><div class="li"> Deschideți mașina virtuală Windows 2003 Server din VMware </div>
</li>
<li class="level3"><div class="li"> Setați numele mașinii cu numele vostru și workgroup-ul la <code>SO</code></div>
<ul>
<li class="level4"><div class="li"> Click dreapta <code>Computer</code> → <code>Properties</code></div>
</li>
<li class="level4"><div class="li"> Alegeți <code>Computer Name, domain and workgroup settings</code> → <code>Change settings</code></div>
</li>
<li class="level4"><div class="li"> Alegeți <code>Computer Name</code> → <code>Change</code></div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Închideți mașina virtuală - <code>Shut Down</code> (<strong>NU</strong> restart)</div>
</li>
<li class="level3"><div class="li"> Asigurați-vă ca mașina virtuală este conectata la rețea </div>
<ul>
<li class="level4"><div class="li"> Edit setting → Network Addapter → Bridged connection</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Reporniți mașina virtuală</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Porniți proiectul <code>win\lab05.sln</code></div>
<ul>
<li class="level3"><div class="li"> Compilați proiectele <code>1-fun-client</code> și <code>1-fun-server</code></div>
</li>
<li class="level3"><div class="li"> Alegeți un coleg cu care să faceți echipă: </div>
<ul>
<li class="level4"><div class="li"> Unul din voi va rula <strong>serverul</strong> din proiectul <code>1-fun-server</code></div>
<ul>
<li class="level5"><div class="li"> serverul poate primi mesaje de la orice client</div>
</li>
</ul>
</li>
<li class="level4"><div class="li"> Celălalt va rula <strong>clientul</strong> din proiectul <code>1-fun-client</code> și va introduce numele stației colegului care a pornit serverul</div>
<ul>
<li class="level5"><div class="li"> Clientul poate transmite și mesaje broadcast (la tot workgroup-ul) setând '*' ca nume al stației server</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Test it! :)</div>
</li>
</ul>
</li>
</ol>
</li>
</ol>

<p>
Exercițiul următor e independent de platformă, iar platforma e la alegere.
</p>

</div>

<h3 class="sectionedit18" id="linuxwindows">Linux / Windows</h3>
<div class="level3">

<p>
Să se implementeze un protocol simplu client-server folosind mecanisme IPC. Serverul întreține o tabelă de dispersie (hashtable), conținând cuvinte, în care se fac inserări și ștergeri comandate de mesajele primite de la clienți. Inserarea într-un tablou (bucket) se face la finalul acestuia.
</p>

<p>
Clienții primesc operațiile prin argumentele primite în linia de comanda la lansarea în execuție. Exemplu:
</p>
<pre class="code bash"> .<span class="sy0">/</span>client a vincent c a <span class="kw3">test</span> p </pre>

<p>
În acest caz, clientul va trimite serverului, în ordine, mesajele: <em>a vincent</em> pentru adăugarea în hashtable a cuvântul “vincent”, <em>c</em> pentru golirea tabelei, <em>a test</em> pentru adăugarea cuvântului “test” și <em>p</em> pentru afișarea conținutului tabelei.
</p>

<p>
Exercițiul se compune din 3 părți:
</p>
<ul>
<li class="level1"><div class="li"><strong>comunicarea prin mesaje</strong> - clienții trimit comenzi serverului prin intermediul unei cozi de mesaje</div>
</li>
<li class="level1"><div class="li"><strong>tabela de dispersie</strong> - serverul va menține tabela în memoria partajată, iar clientul va citi din această zonă de memorie de fiecare dată când are nevoie să printeze </div>
</li>
<li class="level1"><div class="li"><strong>sincronizarea accesului la tabelă</strong> -  se va realiza prin semafoare</div>
</li>
</ul>
<ol>
<li class="level1"><div class="li"> (<strong>0.5 puncte</strong>) Înțelegerea codului deja existent</div>
<ul>
<li class="level2"><div class="li"> Urmăriți sursele din proiect:</div>
<ul>
<li class="level4"><div class="li"> <code>sever.c</code> - conține codul rulat de server</div>
</li>
<li class="level4"><div class="li"> <code>client.c</code> - conține codul rulat de client</div>
</li>
<li class="level4"><div class="li"> <code>common.h</code> - conține structurile necesare protocolului</div>
</li>
<li class="level4"><div class="li"> <code>generic_queue.h</code> - header cu funcțiile generale pentru lucrul cu coada de mesaje</div>
</li>
<li class="level4"><div class="li"> <code>generic_shm.h</code> - header cu funcțiile generale pentru lucrul cu memoria partajată</div>
</li>
<li class="level4"><div class="li"> <code>generic_sem.h</code> - header cu funcțiile generale pentru lucrul cu semafoare</div>
</li>
<li class="level4"><div class="li"> <code>unix_*.c</code> - conține implementarea unix a funcțiilor din <code>generic_*.h</code></div>
</li>
<li class="level4"><div class="li"> <code>win_*.c</code> - conține implementarea windows a funcțiilor din <code>generic_*.h</code></div>
</li>
<li class="level4"><div class="li"> <code>hashtable.h</code>, <code>hashtable.c</code> - reprezintă interfața și implementarea funcțiilor de lucru cu tabela de dispersie</div>
</li>
<li class="level4"><div class="li"> <code>hash.h</code>, <code>hash.c</code> - reprezintă interfața și implementarea funcției de hash</div>
</li>
<li class="level4"><div class="li"> <strong>Atenție!</strong> Fișierul <code>common.h</code> conține structurile necesare la următoarele exerciții</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Se vor implementa functionalitatile din exercitiile urmatoare astfel incat serverul și clientul să comunice prin comenzile:</div>
<ul>
<li class="level3"><div class="li"> <code>'a S</code>':  trimite serverului mesajul de adăugare în hashtable a cuvântului S (add);</div>
</li>
<li class="level3"><div class="li"> <code>'c</code>':    trimite serverului mesajul de golire a conținutului tabelei (clear);</div>
</li>
<li class="level3"><div class="li"> <code>'p</code>':    clientul afișează la standard output conținutul tabelei - formatul este precizat mai jos (print);</div>
</li>
<li class="level3"><div class="li"> <code>'e</code>':    clientul îi spune serverului să își încheie execuția (exit). </div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Compilați și rulați serverul și clientul în două console diferite</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Comunicare prin mesaje </div>
<ul>
<li class="level2"><div class="li"> Trebuie să completați funcțiile msgq_* din fișierul <em>unix_queue.c</em><em>/win_queue.c</em> relativ la interfața din fișierele <em>common.h</em> și <em>generic_queue.h</em></div>
</li>
<li class="level2"><div class="li"> Funcțiile de <code>msgq_send</code> și <code>msgq_receive</code> trebuie să trimită/primească <strong>toată</strong> structura <code>message_t</code> primită ca parametru (nu doar unul din câmpuri).</div>
</li>
<li class="level2"><div class="li"> Aceste funcții sunt deja apelate din codul de server - <em>server.c</em>, respectiv client - <em>client.c</em></div>
</li>
<li class="level2"><div class="li"> Hint:</div>
<ul>
<li class="level3"><div class="li"> Urmăriți în sursa <em>unix_queue.c</em><em>/win_queue.c</em> comentariile <em>TODO 1</em></div>
</li>
<li class="level3"><div class="li"> În această fază trebuie să funcționeze doar trimiterea mesajelor</div>
</li>
<li class="level3"><div class="li"> Reveniți la secțiunea de <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#cozi_de_mesaje" title="so:laboratoare:laborator-05 ↵" class="wikilink1"> Cozi de mesaje POSIX</a> / <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#cozi_de_mesaje_mailslots" title="so:laboratoare:laborator-05 ↵" class="wikilink1">Mailslots</a></div>
</li>
<li class="level3"><div class="li"> Linux:</div>
<ul>
<li class="level4"><div class="li"> în funcția <em>msgq_create</em> va trebui să creați coada de mesaje. Aveți grijă ce dimensiuni alegeți! (<a href="http://linux.die.net/man/7/mq_overview" class="urlextern" title="http://linux.die.net/man/7/mq_overview" rel="nofollow"> mq_overview</a>, sectiunea <code>/proc interfaces</code>)</div>
</li>
<li class="level4"><div class="li"> <strong>Atentie</strong>: Asa cum este precizat in exercitiul anterior, in Linux cozile de mesaje sunt create într-un sistem de fișiere virtual. Acest sistem de fișiere trebuie montat în ierarhia voastră de fișiere. </div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Testați trimițând mesaje de la client la server:</div>
<ul>
<li class="level4"><div class="li"> Porniți serverul și clientul în două console diferite: <pre class="code bash">.<span class="sy0">/</span>server</pre>
<pre class="code bash">.<span class="sy0">/</span>client a <span class="kw3">test</span></pre>
</div>
</li>
<li class="level4"><div class="li"> Pentru a închide serverul: <pre class="code bash">.<span class="sy0">/</span>client e</pre>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Tabela de dispersie</div>
<ul>
<li class="level3"><div class="li"> Completați funcțiile shm_* din <em>unix_shm.c</em><em>/win_shm.c</em> relativ la intefața din fișierele <em>common.h</em> și <em>generic_shm.h</em>.</div>
</li>
<li class="level3"><div class="li"> Aceste funcții sunt deja apelate din codul de server - <em>server.c</em>, respectiv client - <em>client.c</em></div>
</li>
<li class="level3"><div class="li"> <strong>Hints</strong>:</div>
<ul>
<li class="level4"><div class="li"> Urmăriți în sursa <em>unix_shm.c</em><em>/win_shm.c</em> comentariile <em>TODO 2</em></div>
</li>
<li class="level4"><div class="li"> Reveniți la secțiunea de <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#memoria_partajata" title="so:laboratoare:laborator-05 ↵" class="wikilink1"> Memoria partajată POSIX</a> / <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#memorie_partajata_filemapping" title="so:laboratoare:laborator-05 ↵" class="wikilink1"> File Mappings</a></div>
</li>
<li class="level4"><div class="li"> Testați funcționalitatea:<pre class="code bash">.<span class="sy0">/</span>server</pre>
<pre class="code bash">.<span class="sy0">/</span>client a test1 a test2
.<span class="sy0">/</span>client p
.<span class="sy0">/</span>client c 
.<span class="sy0">/</span>client p
.<span class="sy0">/</span>client e</pre>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>3.5 puncte</strong>) Sincronizare prin semafoare</div>
<ul>
<li class="level3"><div class="li"> Sincronizarea trebuie să fie <strong>“fine grained”</strong>, adică la nivel de bucket. </div>
<ul>
<li class="level4"><div class="li"> Operațiile de 'print' și 'clear' nu trebuie să ia toate semafoarele în același timp.</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Nu este acceptabilă existența unui <strong>singur</strong> obiect de sincronizare pentru toată tabela.</div>
<ol>
<li class="level4"><div class="li"> (<strong>2 puncte</strong>) Implementarea codului pentru semafoare</div>
<ul>
<li class="level5"><div class="li"> Completați funcțiile din <em>unix_sem.c</em><em>/win_sem.c</em> relativ la interfața din fișierul <em>common.h</em> și <em>generic_sem.h</em></div>
</li>
<li class="level5"><div class="li"> Aceste funcții sunt deja apelate din codul de server - server.c, respectiv client - client.c</div>
</li>
<li class="level5"><div class="li"> <strong>Hints</strong>:</div>
<ul>
<li class="level6"><div class="li"> Urmăriți comentariile cu <em>TODO 3</em></div>
</li>
<li class="level6"><div class="li"> Reveniți la secțiunea de <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#semafoare_posix" title="so:laboratoare:laborator-05 ↵" class="wikilink1"> Semafoare POSIX</a> / <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#obiecte_de_sincronizare" title="so:laboratoare:laborator-05 ↵" class="wikilink1"> Semafoare Windows</a></div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level4"><div class="li"> (<strong>1.5 puncte</strong>) Realizarea accesului exclusiv</div>
<ul>
<li class="level5"><div class="li"> De data aceasta trebuie să decideți voi <strong>unde</strong> se aplică funcțiile mai sus implementate pentru a asigura sincronizarea</div>
</li>
<li class="level5"><div class="li"> Testați funcționalitatea</div>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>

</div>

<h3 class="sectionedit19" id="bonus">BONUS</h3>
<div class="level3">
<ol>
<li class="level1"><div class="li">  (<strong>1 so karma</strong>) Funny semaphores</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>3-funny_sem</code></div>
</li>
<li class="level2"><div class="li"> Clientul (<code>client.c</code>) vrea să trimită serverului o valoare magică, considerată a fi <a href="http://en.wikipedia.org/wiki/42_%28number%29" class="urlextern" title="http://en.wikipedia.org/wiki/42_%28number%29" rel="nofollow"> "the answer to the Ultimate Question of Life, the Universe, and Everything"</a></div>
</li>
<li class="level2"><div class="li"> Pentru asta, clientul trebuie să folosească o metodă mai neobișnuită - numărul trebuie transmis doar prin intermediul unui semafor.</div>
</li>
</ul>
</li>
</ol>

</div>

<h3 class="sectionedit20" id="extra">EXTRA</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"><strong>EXTRA</strong> IPC în Python</div>
<ul>
<li class="level2"><div class="li"> Rulați și citiți codul din arhiva <a href="http://ocw.cs.pub.ro/courses/_media/so/laboratoare/pyshm.zip" class="media mediafile mf_zip" title="so:laboratoare:pyshm.zip">PySHM</a> - server în C și client în Python</div>
</li>
<li class="level2"><div class="li"> Instalați modulul de Python <a href="http://semanchuk.com/philip/posix_ipc/" class="urlextern" title="http://semanchuk.com/philip/posix_ipc/" rel="nofollow"> ipc_posix</a> și studiați exemple din <a href="http://semanchuk.com/philip/posix_ipc/posix_ipc-0.8.1.tar.gz" class="urlextern" title="http://semanchuk.com/philip/posix_ipc/posix_ipc-0.8.1.tar.gz" rel="nofollow"> arhiva de instalare</a></div>
</li>
</ul>
</li>
</ul>

</div>

<h2 class="sectionedit21" id="solutii">Soluții</h2>
<div class="level2">

<p>
<a href="http://elf.cs.pub.ro/so/res/laboratoare/lab05-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab05-sol.zip" rel="nofollow"> lab05-sol.zip</a>
</p>

</div>

<h2 class="sectionedit22" id="resurse_utile">Resurse utile</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="https://www.kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf" class="urlextern" title="https://www.kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf" rel="nofollow"> Fast User-level Locking In Linux</a></div>
</li>
<li class="level1"><div class="li"><a href="http://msdn.microsoft.com/en-us/library/aa365574%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/aa365574%28VS.85%29.aspx" rel="nofollow"> Windows IPC</a></div>
</li>
<li class="level1"><div class="li"><a href="http://www.wlug.org.nz/ipc%285%29" class="urlextern" title="http://www.wlug.org.nz/ipc%285%29" rel="nofollow">Linux ipc(5) man page describing System V IPC</a></div>
</li>
<li class="level1"><div class="li"><a href="http://beej.us/guide/bgipc/output/print/bgipc_USLetter_2.pdf" class="urlextern" title="http://beej.us/guide/bgipc/output/print/bgipc_USLetter_2.pdf" rel="nofollow">Beej's Guide to Unix IPC</a></div>
</li>
</ul>

</div>

        </div>
        <div class="right_sidebar">
          <form action="http://ocw.cs.pub.ro/courses/start" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search"><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]"><input type="submit" value="Search" class="button" title="Search"><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#laborator_05_-_ipc">Laborator 05 - IPC</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#materiale_ajutatoare">Materiale ajutătoare</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#nice_to_read">Nice to read</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#mecanisme_ipc">Mecanisme IPC</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#linux">Linux</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#semafoare_posix">Semafoare POSIX</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#crearea_si_deschiderea">Crearea și deschiderea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#decrementare_incrementare_si_aflarea_valorii">Decrementare, incrementare și aflarea valorii</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#inchiderea_si_distrugerea">Închiderea și distrugerea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#exemplu_de_utilizare">Exemplu de utilizare</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#cozi_de_mesaje">Cozi de mesaje</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#crearea_si_deschiderea1">Crearea și deschiderea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#trimiterea_si_receptionarea_de_mesaje">Trimiterea și recepționarea de mesaje</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#inchiderea_si_stergerea">Închiderea și ștergerea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#exemplu_de_utilizare1">Exemplu de utilizare</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#memoria_partajata">Memoria partajată</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#crearea_si_deschiderea2">Crearea și deschiderea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#redimensionarea">Redimensionarea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#maparea_si_eliberarea">Maparea și eliberarea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#inchiderea_si_stergerea1">Închiderea și ștergerea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#exemplu_de_utilizare2">Exemplu de utilizare</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#depanare_posix_ipc">Depanare POSIX IPC</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#memoria_partajata1">Memoria partajată</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#cozi_de_mesaje1">Cozi de mesaje</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#windows">Windows</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#functii_de_asteptare">Funcții de așteptare</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#asteptare_dupa_un_singur_obiect">Așteptare după un singur obiect</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#obiecte_de_sincronizare">Obiecte de sincronizare</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#mutex-uri">Mutex-uri</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#semafoare">Semafoare</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#cozi_de_mesaje_mailslots">Cozi de mesaje (Mailslots)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#crearea">Crearea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#deschiderea_unei_cozi_existente">Deschiderea unei cozi existente</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#scrierea_si_citirea">Scrierea și citirea</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#obtinerea_de_informatii_despre_o_coada_de_mesaje">Obținerea de informații despre o coada de mesaje</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#exemplu_de_utilizare3">Exemplu de utilizare</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#memorie_partajata_filemapping">Memorie partajată (FileMapping)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#crearea_unei_zone_de_memorie_partajata">Crearea unei zone de memorie partajată</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#accesul_la_o_zona_de_memorie_partajata_deja_creata">Accesul la o zonă de memorie partajată deja creată</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#demaparea_unei_zone_de_memorie_partajata">Demaparea unei zone de memorie partajată</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#exemple_de_utilizare">Exemple de utilizare</a></div></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#exercitii_de_laborator">Exerciții de laborator</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#linux1">Linux</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#windows1">Windows</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#linuxwindows">Linux / Windows</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#bonus">BONUS</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#extra">EXTRA</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#solutii">Soluții</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#resurse_utile">Resurse utile</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
<div class="namespace_sidebar sidebar_box">



<h1 class="sectionedit23" id="informatii_generale_so">Informații generale SO</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_169000882551b89b49417c8',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_169000882551b89b49417c8" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/documentatie" class="wikilink1" title="so:info:documentatie">Documentație și alte resurse</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/feed" class="wikilink1" title="so:info:feed">Feed-uri RSS</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/hall" class="wikilink1" title="so:info:hall">Hall of SO</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/lista-discutii" class="wikilink1" title="so:info:lista-discutii">Listă de discuții</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/mv" class="wikilink1" title="so:info:mv">Mașini virtuale</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/trimitere-teme" class="wikilink1" title="so:info:trimitere-teme">Trimitere teme</a></div></li>
</ul>
</div>

</div>
<!-- EDIT23 SECTION "Informații generale SO" [12-175] -->
<h1 class="sectionedit24" id="informatii_so_2012-2013">Informații SO 2012-2013</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_3629347651b89b4943bed',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_3629347651b89b4943bed" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare" class="indexmenu_idx_head">Reguli generale și notare</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare/reguli-notare-ca-cc" class="wikilink1" title="so:2012-2013:notare:reguli-notare-ca-cc">Notare CA/CC</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare/reguli-notare-cb" class="wikilink1" title="so:2012-2013:notare:reguli-notare-cb">Notare CB</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/anunturi" class="wikilink1" title="so:2012-2013:anunturi">Anunțuri</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/calendar" class="wikilink1" title="so:2012-2013:calendar">Calendar</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/catalog" class="wikilink1" title="so:2012-2013:catalog">Catalog</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen" class="wikilink1" title="so:2012-2013:examen">Examen</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/need-to-know" class="wikilink1" title="so:2012-2013:need-to-know">SO Need to Know</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/orar" class="wikilink1" title="so:2012-2013:orar">Orar și împărțire pe semigrupe</a></div></li>
</ul>
</div>

</div>
<!-- EDIT24 SECTION "Informații SO 2012-2013" [176-248] -->
<h1 class="sectionedit25" id="laboratoare">Laboratoare</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_50912080451b89b4948944',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_50912080451b89b4948944" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse" class="indexmenu_idx_head">Resurse</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/c_tips" class="wikilink1" title="so:laboratoare:resurse:c_tips">C/SO Tips</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/die" class="wikilink1" title="so:laboratoare:resurse:die">Macro-ul DIE</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/gdb" class="wikilink1" title="so:laboratoare:resurse:gdb">GDB</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/home" class="wikilink1" title="so:laboratoare:resurse:home">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/injections" class="wikilink1" title="so:laboratoare:resurse:injections">Function Hooking and Windows Dll Injection</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/oprofile" class="wikilink1" title="so:laboratoare:resurse:oprofile">Oprofile</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/recapitulare" class="wikilink1" title="so:laboratoare:resurse:recapitulare">Recapitulare</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/threaduri_extra" class="wikilink1" title="so:laboratoare:resurse:threaduri_extra">Thread-uri - Extra</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/vs_tips" class="wikilink1" title="so:laboratoare:resurse:vs_tips">Visual Studio Tips and Tricks</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/windows-video" class="wikilink1" title="so:laboratoare:resurse:windows-video">windows-video</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-01" class="wikilink1" title="so:laboratoare:laborator-01">Laborator 01 - Introducere</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-02" class="wikilink1" title="so:laboratoare:laborator-02">Laborator 02 - Operații I/O simple</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-03" class="wikilink1" title="so:laboratoare:laborator-03">Laborator 03 - Procese</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-04" class="wikilink1" title="so:laboratoare:laborator-04">Laborator 04 - Gestiunea memoriei</a></div></li>
<li class="level1"><div class="li"><span class="curid"><a href="./Laborator 05 - IPC [CS Open CourseWare]_files/Laborator 05 - IPC [CS Open CourseWare].htm" class="wikilink1" title="so:laboratoare:laborator-05">Laborator 05 - IPC</a></span></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06" class="wikilink1" title="so:laboratoare:laborator-06">Laborator 06 - Semnale</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-07" class="wikilink1" title="so:laboratoare:laborator-07">Laborator 07 - Memoria virtuală</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08" class="wikilink1" title="so:laboratoare:laborator-08">Laborator 08 - Thread-uri Linux</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-09" class="wikilink1" title="so:laboratoare:laborator-09">Laborator 09 - Thread-uri Windows</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-10" class="wikilink1" title="so:laboratoare:laborator-10">Laborator 10 - Operații IO avansate - Windows</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-11" class="wikilink1" title="so:laboratoare:laborator-11">Laborator 11 - Operații IO avansate - Linux</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-12" class="wikilink1" title="so:laboratoare:laborator-12">Laborator 12 - Profiling</a></div></li>
</ul>
</div>

</div>
<!-- EDIT25 SECTION "Laboratoare" [249-309] -->
<h1 class="sectionedit26" id="cursuri">Cursuri</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_161716681451b89b494f3a8',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_161716681451b89b494f3a8" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-01" class="indexmenu_idx_head">Curs 01 - Introducere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-02" class="indexmenu_idx_head">Curs 02 - Sistemul de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-03" class="indexmenu_idx_head">Curs 03 - Procese</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-04" class="indexmenu_idx_head">Curs 04 - Planificarea execuției</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-05" class="indexmenu_idx_head">Curs 05 - Sincronizarea proceselor</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-06" class="indexmenu_idx_head">Curs 06 - Gestiunea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-07" class="indexmenu_idx_head">Curs 07 - Memoria virtuală</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-08" class="indexmenu_idx_head">Curs 08 - Fire de execuție</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-09" class="indexmenu_idx_head">Curs 09 - Dispozitive de intrare/ieșire</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-10" class="indexmenu_idx_head">Curs 10 - Implementarea sistemelor de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-11" class="indexmenu_idx_head">Curs 11 - Virtualizare</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-12" class="indexmenu_idx_head">Curs 12 - Securitatea sistemelor de operare</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-13" class="indexmenu_idx_head">Curs 13 - Android</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/quiz?idx=so:cursuri:quiz" class="indexmenu_idx">quiz</a></div></li>
</ul>
</div>

</div>
<!-- EDIT26 SECTION "Cursuri" [310-362] -->
<h1 class="sectionedit27" id="teme">Teme</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_71511494351b89b4950ad7',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_71511494351b89b4950ad7" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-asist" class="indexmenu_idx_head">Tema Asistenți - Guardian process</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/echipe" class="wikilink1" title="so:teme:echipe">Echipe tema 5</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/general" class="wikilink1" title="so:teme:general">Indicații generale teme</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-0" class="wikilink1" title="so:teme:tema-0">Tema 0 HashTable</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-1" class="wikilink1" title="so:teme:tema-1">Tema 1 Mini-shell</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-2" class="wikilink1" title="so:teme:tema-2">Tema 2 MPI</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-3" class="wikilink1" title="so:teme:tema-3">Tema 3 Memorie virtuală</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-4" class="wikilink1" title="so:teme:tema-4">Tema 4 Planificator de threaduri</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-5" class="wikilink1" title="so:teme:tema-5">Tema 5 Server web asincron</a></div></li>
</ul>
</div>

</div>
<!-- EDIT27 SECTION "Teme" [363-] -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          so/laboratoare/laborator-05.txt · Last modified: 2013/03/26 12:15 by larisa.grigore          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
        <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05?do=revisions" class="action revs" accesskey="o" rel="nofollow" title="Old revisions [O]">Old revisions</a>      </div>
      <div class="bar-right">
        <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05?do=media" class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05#dokuwiki__top" class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="./Laborator 05 - IPC [CS Open CourseWare]_files/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported"></a></div>
  <a target="_blank" href="http://www.chimeric.de/" title="www.chimeric.de"><img src="./Laborator 05 - IPC [CS Open CourseWare]_files/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0"></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="./Laborator 05 - IPC [CS Open CourseWare]_files/button-css.png" width="80" height="15" alt="Valid CSS" border="0"></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="./Laborator 05 - IPC [CS Open CourseWare]_files/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0"></a>

  <a target="_blank" href="http://www.firefox-browser.de/" title="do yourself a favour and use a real browser - get firefox"><img src="./Laborator 05 - IPC [CS Open CourseWare]_files/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0"></a>
  
  <a target="_blank" href="http://ocw.cs.pub.ro/courses/feed.php" title="Recent changes RSS feed"><img src="./Laborator 05 - IPC [CS Open CourseWare]_files/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0"></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="./Laborator 05 - IPC [CS Open CourseWare]_files/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0"></a>
</div>

  </div>
</div>

<div class="no"><img src="./Laborator 05 - IPC [CS Open CourseWare]_files/indexer.php" width="2" height="1" alt=""></div>


</body></html>