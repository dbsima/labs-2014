<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0056)http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>
    Laborator 06 - Semnale    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki">
<meta name="robots" content="index,follow">
<meta name="date" content="2013-04-02T08:50:36+0300">
<meta name="keywords" content="so,laboratoare,laborator-06">
<link rel="search" type="application/opensearchdescription+xml" href="http://ocw.cs.pub.ro/courses/lib/exe/opensearch.php" title="CS Open CourseWare">
<link rel="start" href="http://ocw.cs.pub.ro/courses/">
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="http://ocw.cs.pub.ro/courses/feed.php">
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://ocw.cs.pub.ro/courses/feed.php?mode=list&ns=so:laboratoare">
<link rel="alternate" type="text/html" title="Plain HTML" href="http://ocw.cs.pub.ro/courses/_export/xhtml/so/laboratoare/laborator-06">
<link rel="canonical" href="./Laborator 06 - Semnale [CS Open CourseWare]_files/Laborator 06 - Semnale [CS Open CourseWare].htm">
<link rel="stylesheet" type="text/css" href="./Laborator 06 - Semnale [CS Open CourseWare]_files/css.php">
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare';var JSINFO = {"id":"so:laboratoare:laborator-06","namespace":"so:laboratoare"};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="./Laborator 06 - Semnale [CS Open CourseWare]_files/js.php"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script><script src="./Laborator 06 - Semnale [CS Open CourseWare]_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="./Laborator 06 - Semnale [CS Open CourseWare]_files/menu.js"></script>
<script type="text/javascript" charset="utf-8" src="./Laborator 06 - Semnale [CS Open CourseWare]_files/indexmenu.js"></script>
<script type="text/javascript" charset="utf-8">/*<![CDATA[*/var indexmenu_ID='so/laboratoare/laborator-06'
/*!]]>*/</script>

  <link rel="shortcut icon" href="http://ocw.cs.pub.ro/courses/lib/tpl/arctic/images/favicon.ico">

  
<script src="./Laborator 06 - Semnale [CS Open CourseWare]_files/nojsindex.js" type="text/javascript" charset="utf-8"></script></head>
<body>
<div id="wrapper" class="show">
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="http://ocw.cs.pub.ro/courses/so/"><img height="70" src="./Laborator 06 - Semnale [CS Open CourseWare]_files/sigla_so.png"> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="http://ocw.cs.pub.ro/courses/systems/"><img height="70" src="./Laborator 06 - Semnale [CS Open CourseWare]_files/systems.png" name="dokuwiki__top"></a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06?do=login&sectok=86b5e794b6fc7ff30ead55e0316f8781" class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h1 class="sectionedit1" id="laborator_06_-_semnale">Laborator 06 - Semnale</h1>
<div class="level1">

</div>

<h2 class="sectionedit2" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab06-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab06-slides.pdf" rel="nofollow"> lab06-slides.pdf</a></div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab06-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab06-refcard.pdf" rel="nofollow"> lab06-refcard.pdf</a></div>
</li>
</ul>

</div>

<h3 class="sectionedit3" id="nice_to_read">Nice to read</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> TLPI - Chapter 20, Signals: Fundamental Concepts</div>
</li>
<li class="level1"><div class="li"> TLPI - Chapter 21: Signals: Signal Handlers</div>
</li>
</ul>

</div>

<h2 class="sectionedit4" id="semnale_in_linux">Semnale în Linux</h2>
<div class="level2">

<p>
În lumea reală, un proces poate cunoaște o multitudine de situații neprevăzute, care-i afectează cursul normal de execuție. Dacă procesul nu le poate trata, ele sunt pasate, mai departe, sistemului de operare. Cum sistemul de operare nu poate ști dacă procesul își poate continua execuția în mod normal, fără efecte secundare nedorite, este obligat să termine procesul în mod forțat. O rezolvare a acestei probleme o reprezintă semnalele.
</p>

<p>
Semnalele sunt un concept specific sistemelor de operare UNIX. Un semnal este o <strong>întrerupere software</strong>, în fluxul normal de execuție a unui proces. Sistemul de operare le folosește pentru a semnala procesului apariția unor situații excepționale oferindu-i procesului posibilitatea de a reacționa. Fiecare semnal este asociat cu o clasă de evenimente care pot apărea și care respectă anumite criterii. Procesele pot trata, bloca, ignora sau lăsa sistemul de operare să efectueze acțiunea implicită la primirea unui semnal (de obicei acțiunea implicită este <strong>terminarea</strong> procesului).
</p>
<ul>
<li class="level1"><div class="li">Dacă un proces dorește să <strong>ignore</strong> un semnal, sistemul de operare nu va mai trimite acel semnal procesului.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">Dacă un proces specifică faptul că dorește să <strong>blocheze</strong> un semnal, sistemul de operare nu va mai trimite semnalele de acel tip spre procesul în cauză, dar va salva numai primul semnal de acel tip, restul pierzându-se. Când procesul hotărăște că vrea să primească, din nou, semnale de acel tip, dacă există vreun semnal în așteptare, acesta va fi trimis. </div>
</li>
</ul>

<p>
Mulțimea tipurilor de semnale este finită; sistemul de operare ține, pentru fiecare proces, o <strong>tabelă cu acțiunile</strong> alese de acesta, pentru fiecare tip de semnal. La fiecare moment de timp aceste acțiuni sunt bine determinate. La pornirea procesului tabela de acțiuni este inițializată cu valorile implicite. Modul de tratare a semnalului nu este decis la primirea semnalului de către proces, ci se alege, în mod automat, din tabelă.
</p>

<p>
Semnalele sunt sincrone/asincrone cu fluxul de execuție al procesului care primește semnalul dacă evenimentul care cauzează trimiterea semnalului este sincron/asincron cu fluxul de execuție al procesului.
</p>
<ul>
<li class="level1"><div class="li">Un eveniment este <strong>sincron</strong> cu fluxul de execuție al procesului dacă apare de fiecare dată la rularea programului, în același punct al fluxului de execuție. Exemple în acest sens sunt încercarea de accesare a unei locații de memorie nevalide sau nepermise, împărțire la zero etc. </div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">Un eveniment este <strong>asincron</strong> dacă nu este sincron. Exemple de evenimente asincrone: un semnal trimis de un alt proces (semnalul de terminare unui proces copil), sau o cerere de terminare externă (utilizatorul dorește să reseteze calculatorul).</div>
</li>
</ul>

<p>
Un semnal primit de un proces poate fi generat:
</p>
<ul>
<li class="level1"><div class="li">fie direct de <strong>sistemul de operare</strong> - în cazul în care acesta raportează diferite erori;</div>
</li>
<li class="level1"><div class="li">fie de un <strong>proces</strong> - care-și poate trimite și singur semnale (semnalul va trece tot prin sistemul de operare). </div>
</li>
</ul>

<p>
Dacă două semnale sunt prea apropiate în timp ele se pot confunda într-unul singur. Astfel, în mod normal, nu există niciun mecanism care să garanteze celui care trimite semnalul că acesta a ajuns la destinație.
</p>

<p>
În anumite cazuri, există nevoia de a ști, în mod sigur, că un semnal trimis a ajuns la destinație și, implicit, că procesul va răspunde la el (efectuând una din acțiunile posibile). Sistemul de operare oferă un alt mod de a trimite un semnal, prin care se <strong>garantează</strong> fie că semnalul a ajuns la destinație, fie că această acțiune a eșuat. Acest lucru este realizat prin crearea unei stive de semnale, de o anumită capacitate (ea trebuie să fie finită, pentru a nu produce situații de overflow). La trimiterea unui semnal, sistemul de operare verifică dacă stiva este plină. În acest caz, cererea eșuează, altfel semnalul este pus în stivă și operația se termină cu succes. Modul clasic de a trimite semnale este analog cu acesta (stiva are dimensiunea 1) cu excepția faptului că nu se oferă informații despre ajungerea la destinație a unui semnal.
</p>

<p>
Noțiunea de semnal este folosită pentru a indica alternativ fie un anumit tip de semnal, fie efectiv obiectele de acest tip.
</p>

</div>

<h3 class="sectionedit5" id="generarea_semnalelor">Generarea semnalelor</h3>
<div class="level3">

<p>
În general, evenimentele care generează semnale se încadrează în trei categorii majore: 
</p>
<ul>
<li class="level1"><div class="li">O <strong>eroare</strong> indică faptul că un program a făcut o operație nepermisă și nu-și poate continua execuția. Însă, nu toate tipurile de erori generează semnale (de fapt, cele mai multe nu o fac). De exemplu, deschiderea unui fișier inexistent este o eroare, dar nu generează un semnal; în schimb, apelul de sistem <code>open</code> returnează -1, indicând că apelul s-a terminat cu eroare. În general, erorile asociate cu anumite biblioteci sunt raportate prin întoarcerea unei valori speciale. Erorile care generează semnale sunt cele care pot apărea oriunde în program, nu doar în apelurile din biblioteci. Ele includ împărțirea cu zero și accesarea nevalidă a memoriei.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">Un <strong>eveniment extern</strong> este, în general, legat de I/O și de alte procese. Exemple: apariția de noi date de intrare, expirarea unui timer, terminarea execuției unui proces copil.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">O <strong>cerere explicită</strong> indică utilizarea unui apel de sistem, cum ar fi <code>kill</code>, pentru a genera un semnal.</div>
</li>
</ul>

<p>
Semnalele pot fi generate sincron sau asincron:
</p>
<ul>
<li class="level1"><div class="li">Un semnal <strong>sincron</strong> se raportează la o acțiune specifică din program, și este trimis (dacă nu este blocat) în timpul acelei acțiuni. Cele mai multe erori generează semnale în mod sincron. De asemenea, semnalele pot fi generate în mod sincron și prin anumite cereri explicite trimise de un proces lui însuși. Pe anumite mașini, anumite tipuri de erori hardware (de obicei, excepțiile în virgulă mobilă) nu sunt raportate complet sincron, și pot ajunge câteva instrucțiuni mai târziu.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">Semnalele <strong>asincrone</strong> sunt generate de evenimente necontrolabile de către procesul care le primește. Aceste semnale ajung la momente de timp impredictibile. Evenimentele externe generează semnale în mod asincron, la fel ca și cererile explicite trimise de alte procese.</div>
</li>
</ul>

<p>
Un tip de semnal dat este fie sincron, fie asincron. De exemplu, semnalele pentru erori sunt, în general, sincrone deoarece erorile generează semnale în mod sincron. Însă, orice tip de semnal poate fi generat sincron sau asincron cu o cerere explicită.
</p>

</div>

<h3 class="sectionedit6" id="transmiterea_si_primirea_semnalelor">Transmiterea și primirea semnalelor</h3>
<div class="level3">

<p>
Când un semnal este generat, el intră într-o stare de așteptare (pending). În mod normal, el rămâne în această stare pentru o perioadă de timp foarte mică și apoi este trimis procesului destinație. Însă, dacă acel tip de semnal este, în momentul de față, blocat, el ar putea rămâne în starea de așteptare nedefinit, până când semnalele de acel tip sunt deblocate. O dată deblocat acel tip de semnale, el va fi trimis imediat.
</p>

<p>
Când semnalul a fost primit, fie imediat, fie cu întârziere, acțiunea specificată pentru acel semnal este executată. Pentru anumite semnale, cum ar fi <code>SIGKILL</code> și <code>SIGSTOP</code>, acțiunea este <strong>fixată</strong> (procesul este terminat), dar, pentru majoritatea semnalelor, programul poate alege să:
</p>
<ul>
<li class="level1"><div class="li"><strong>ignore</strong> semnalul</div>
</li>
<li class="level1"><div class="li">specifice o funcție de tip <strong>handler</strong></div>
</li>
<li class="level1"><div class="li">accepte <strong>acțiunea implicită</strong> pentru acel tip de semnal. </div>
</li>
</ul>

<p>
Programul își specifică alegerea utilizând funcții precum <a href="http://linux.die.net/man/2/signal" class="urlextern" title="http://linux.die.net/man/2/signal" rel="nofollow"> signal</a> sau <a href="http://linux.die.net/man/2/sigaction" class="urlextern" title="http://linux.die.net/man/2/sigaction" rel="nofollow"> sigaction</a>. În timp ce handler-ul rulează, acel tip de semnal este în mod normal <strong>blocat</strong> (deblocarea se va face printr-o cerere explicită în handler-ul care tratează semnalul).
</p>

<p>
Dacă acțiunea specificată pentru un tip de semnal este să îl <strong>ignore</strong>, atunci orice semnal de acest tip, care este generat pentru procesul în cauză, este ignorat. Același lucru se întâmplă dacă semnalul este blocat în acel moment. Un semnal neglijat în acest mod nu va fi primit niciodată, nici dacă programul specifică ulterior o acțiune diferită pentru acel tip de semnal și apoi îl deblochează.
</p>

<p>
Dacă este primit un semnal pentru care nu s-a specificat niciun tip de acțiune, se execută <strong>acțiunea implicită</strong>. Fiecare tip de semnal are propria lui acțiune implicită. Pentru majoritatea semnalelor acțiunea implicită este <strong>terminarea</strong> procesului. Pentru anumite tipuri de procese, care reprezintă evenimente fără consecințe majore, acțiunea implicită este să nu se facă nimic.
</p>

<p>
Când un semnal forțează terminarea unui proces, părintele procesului poate determina cauza terminării examinând codul de terminare raportat de funcțiile <code>wait</code> și <code>waitpid</code>. Informațiile pe care le poate obține includ faptul că terminarea procesului a fost cauzată de un semnal, precum și tipul semnalului. Dacă un program pe care îl rulați din linia de comandă este terminat de un semnal, shell-ul afișează, de obicei, niște mesaje de eroare.
</p>

<p>
Semnalele care în mod normal reprezintă erori de program au o proprietate specială: când unul din aceste semnale termină procesul, el scrie și un fișier <strong><em>core dump</em></strong> care înregistrează starea procesului în momentul terminării. Puteți examina fișierul cu un debugger, pentru a afla ce anume a cauzat eroarea.
</p>

<p>
Dacă generați un semnal, care reprezintă o eroare de program, printr-o cerere explicită, și acesta termină procesul, fișierul este generat ca și cum semnalul ar fi fost generat de o eroare.
</p>

<p>
<strong>Important</strong>: În cazul în care un semnal este trimis procesului, în timp ce acesta execută un apel de sistem <strong>blocant</strong>, procesul va suspenda apelul, va executa handler-ul de tratare și apoi fie operația va eșua (cu <code>errno</code> setat pe <code>EINTR</code>), fie se va reporni operația. Sistemele System V se comportă ca în primul caz, cele BSD ca în cel de-al doilea.
</p>

</div>

<h3 class="sectionedit7" id="tipuri_standard_de_semnale">Tipuri standard de semnale</h3>
<div class="level3">

<p>
Această secțiune prezintă numele pentru diferite tipuri standard de semnale și descrie ce fel de evenimente indică. Fiecare nume de semnal este o <strong>macrodefiniție</strong> care reprezintă, de fapt, un număr întreg pozitiv (numărul pentru acel tip de semnal). Un program nu ar trebui să facă niciodată presupuneri despre codul numeric al unui tip particular de semnal, ci, mai degrabă, să le refere, întotdeauna, prin nume. Acest lucru este din cauza faptului că un număr pentru un tip de semnal poate <strong>varia</strong> de la un sistem la altul, dar numele sunt standard. Pentru lista completă de semnale suportate de un sistem se poate rula în linia de comandă:
</p>
<pre class="code bash">$ <span class="kw2">kill</span> <span class="re5">-l</span>
&nbsp;
     <span class="nu0">1</span><span class="br0">)</span> SIGHUP       <span class="nu0">2</span><span class="br0">)</span> SIGINT       <span class="nu0">3</span><span class="br0">)</span> SIGQUIT      <span class="nu0">4</span><span class="br0">)</span> SIGILL
     <span class="nu0">5</span><span class="br0">)</span> SIGTRAP      <span class="nu0">6</span><span class="br0">)</span> SIGABRT      <span class="nu0">7</span><span class="br0">)</span> SIGBUS       <span class="nu0">8</span><span class="br0">)</span> SIGFPE
     <span class="nu0">9</span><span class="br0">)</span> SIGKILL     <span class="nu0">10</span><span class="br0">)</span> SIGUSR1     <span class="nu0">11</span><span class="br0">)</span> SIGSEGV     <span class="nu0">12</span><span class="br0">)</span> SIGUSR2
    <span class="nu0">13</span><span class="br0">)</span> SIGPIPE     <span class="nu0">14</span><span class="br0">)</span> SIGALRM     <span class="nu0">15</span><span class="br0">)</span> SIGTERM     <span class="nu0">17</span><span class="br0">)</span> SIGCHLD
    <span class="nu0">18</span><span class="br0">)</span> SIGCONT     <span class="nu0">19</span><span class="br0">)</span> SIGSTOP     <span class="nu0">20</span><span class="br0">)</span> SIGTSTP     <span class="nu0">21</span><span class="br0">)</span> SIGTTIN
    <span class="nu0">22</span><span class="br0">)</span> SIGTTOU     <span class="nu0">23</span><span class="br0">)</span> SIGURG      <span class="nu0">24</span><span class="br0">)</span> SIGXCPU     <span class="nu0">25</span><span class="br0">)</span> SIGXFSZ
    <span class="nu0">26</span><span class="br0">)</span> SIGVTALRM   <span class="nu0">27</span><span class="br0">)</span> SIGPROF     <span class="nu0">28</span><span class="br0">)</span> SIGWINCH    <span class="nu0">29</span><span class="br0">)</span> SIGIO
    <span class="nu0">30</span><span class="br0">)</span> SIGPWR      <span class="nu0">31</span><span class="br0">)</span> SIGSYS      <span class="nu0">33</span><span class="br0">)</span> SIGRTMIN    <span class="nu0">34</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">1</span>
    <span class="nu0">35</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">2</span>  <span class="nu0">36</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">3</span>  <span class="nu0">37</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">4</span>  <span class="nu0">38</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">5</span>
    <span class="nu0">39</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">6</span>  <span class="nu0">40</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">7</span>  <span class="nu0">41</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">8</span>  <span class="nu0">42</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">9</span>
    <span class="nu0">43</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">10</span> <span class="nu0">44</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">11</span> <span class="nu0">45</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">12</span> <span class="nu0">46</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">13</span>
    <span class="nu0">47</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">14</span> <span class="nu0">48</span><span class="br0">)</span> SIGRTMIN+<span class="nu0">15</span> <span class="nu0">49</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">15</span> <span class="nu0">50</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">14</span>
    <span class="nu0">51</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">13</span> <span class="nu0">52</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">12</span> <span class="nu0">53</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">11</span> <span class="nu0">54</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">10</span>
    <span class="nu0">55</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">9</span>  <span class="nu0">56</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">8</span>  <span class="nu0">57</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">7</span>  <span class="nu0">58</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">6</span>
    <span class="nu0">59</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">5</span>  <span class="nu0">60</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">4</span>  <span class="nu0">61</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">3</span>  <span class="nu0">62</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">2</span>
    <span class="nu0">63</span><span class="br0">)</span> SIGRTMAX-<span class="nu0">1</span>  <span class="nu0">64</span><span class="br0">)</span> SIGRTMAX</pre>

<p>
Numele de semnale sunt definite în header-ul <code>signal.h</code>. În general, semnalele au roluri predefinite, dar acestea pot fi suprascrise de programator. 
</p>

<p>
Cele mai cunoscute sunt următoarele semnale:
</p>
<ul>
<li class="level1"><div class="li"><code>SIGINT</code> - transmis la apăsarea combinației <code>CTRL+C</code>;</div>
</li>
<li class="level1"><div class="li"><code>SIGQUIT</code> - transmis la apăsarea combinației de taste <code>CTRL+\</code>;</div>
</li>
<li class="level1"><div class="li"><code>SIGSEGV</code> - transmis în momentul accesării unei locații nevalide de memorie, etc;</div>
</li>
<li class="level1"><div class="li"><code>SIGKILL</code> - <strong>nu</strong> poate fi ignorat sau suprascris. Transmiterea acestui semnal are ca efect terminarea procesului, indiferent de context.</div>
</li>
</ul>

</div>

<h3 class="sectionedit8" id="mesaje_pentru_descrierea_semnalelor">Mesaje pentru descrierea semnalelor</h3>
<div class="level3">

<p>
Cel mai bun mod de a afișa un mesaj de descriere a unui semnal este utilizarea funcțiilor <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/strsignal.3.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man3/strsignal.3.html" rel="nofollow">strsignal</a> și <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/psignal.3.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man3/psignal.3.html" rel="nofollow">psignal</a>. Aceste funcții folosesc un număr de semnal pentru a specifica tipul de semnal care trebuie descris. Mai jos este prezentat un exemplu de folosire a acestor funcții:
</p>
<dl class="code">
<dt><a href="http://ocw.cs.pub.ro/courses/_export/code/so/laboratoare/laborator-06?codeblock=1" title="Download Snippet" class="mediafile mf_c">msg_signal.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;stdlib.h&gt;</span>
&nbsp;
<span class="co2">#define __USE_GNU</span>
<span class="co2">#include &lt;string.h&gt;</span>
&nbsp;
<span class="co2">#include &lt;signal.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">char</span> <span class="sy0">*</span>sig_p <span class="sy0">=</span> strsignal<span class="br0">(</span>SIGKILL<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"signal %d is %s<span class="es1">\n</span>"</span><span class="sy0">,</span> SIGKILL<span class="sy0">,</span> sig_p<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    psignal<span class="br0">(</span>SIGKILL<span class="sy0">,</span> <span class="st0">"death and decay"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</dd></dl>

<p>
Pentru compilare și rulare secvența este:
</p>
<pre class="code bash"><span class="co4">so@spook$ </span><span class="kw2">gcc</span> <span class="re5">-Wall</span> <span class="re5">-g</span> <span class="re5">-o</span> msg_signal msg_signal.c
<span class="co4">so@spook$ </span>.<span class="sy0">/</span>msg_signal 
signal <span class="nu0">9</span> is Killed
death and decay: Killed</pre>

</div>

<h3 class="sectionedit9" id="masti_de_semnale_blocarea_semnalelor">Măști de semnale. Blocarea semnalelor</h3>
<div class="level3">

<p>
Pentru a putea efectua operații de blocare/deblocare semnale avem nevoie să știm, la fiecare pas din fluxul de execuție, starea fiecărui semnal. Sistemul de operare are, de asemenea, nevoie de același lucru pentru a putea lua o decizie asupra unui semnal care trebuie trimis unui proces (el are nevoie de acest gen de informație pentru fiecare proces în parte). În acest scop se folosește o mască de semnale proprie fiecărui proces.
</p>

<p>
O <strong>mască de semnale</strong> are fiecare bit asociat unui tip de semnal. Masca de biți este folosită de mai multe funcții, printre care și funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigprocmask.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigprocmask.2.html" rel="nofollow">sigprocmask</a>, folosită pentru schimbarea măștii de semnale a procesului curent.
</p>
<pre class="code c"><span class="kw4">int</span> sigprocmask<span class="br0">(</span><span class="kw4">int</span> how<span class="sy0">,</span> <span class="kw4">const</span> sigset_t <span class="sy0">*</span>set<span class="sy0">,</span> sigset_t <span class="sy0">*</span>oldset<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Tipul de date folosit de sistemele UNIX pentru a reprezenta măștile de semnale este <code>sigset_t</code>. Variabilele de acest tip sunt neinițializate. Operațiile pe acest tip de date sunt de inițializare cu biți de 0 (toate semnalele neblocate) sau biți de 1 (toate semnalele blocate), de blocare a unui semnal, deblocare și detectare a blocării unui semnal:
</p>
<pre class="code c"><span class="kw4">int</span> sigemptyset<span class="br0">(</span>sigset_t <span class="sy0">*</span>set<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> sigfillset <span class="br0">(</span>sigset_t <span class="sy0">*</span>set<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> sigaddset  <span class="br0">(</span>sigset_t <span class="sy0">*</span>set<span class="sy0">,</span> <span class="kw4">int</span> signo<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> sigdelset  <span class="br0">(</span>sigset_t <span class="sy0">*</span>set<span class="sy0">,</span> <span class="kw4">int</span> signo<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> sigismember<span class="br0">(</span>sigset_t <span class="sy0">*</span>set<span class="sy0">,</span> <span class="kw4">int</span> signo<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Secvența de mai jos constituie un caz de utilizare a funcțiilor de lucru cu masca de semnale, în care, la fiecare 5 secunde, se blochează/deblochează semnalul <code>SIGINT</code>:
</p>
<pre class="code c">sigset_t set<span class="sy0">;</span>
&nbsp;
sigemptyset<span class="br0">(</span><span class="sy0">&amp;</span>set<span class="br0">)</span><span class="sy0">;</span>
sigaddset<span class="br0">(</span><span class="sy0">&amp;</span>set<span class="sy0">,</span> SIGINT<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">while</span> <span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
    sleep<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
    sigprocmask<span class="br0">(</span>SIG_BLOCK<span class="sy0">,</span> <span class="sy0">&amp;</span>set<span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
    sleep<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
    sigprocmask<span class="br0">(</span>SIG_UNBLOCK<span class="sy0">,</span> <span class="sy0">&amp;</span>set<span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>

</div>

<h3 class="sectionedit10" id="tratarea_semnalelor">Tratarea semnalelor</h3>
<div class="level3">

<p>
Tratarea semnalelor se realizează prin asocierea unei funcții (<strong>handler</strong>) unui semnal. Funcția va fi apelată în momentul în care procesul recepționează semnalul.
</p>

<p>
În mod tradițional, funcția folosită pentru asocierea de handler-e pentru tratarea unui semnal era <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/signal.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/signal.2.html" rel="nofollow">signal</a>. Pentru a preîntâmpina deficiențele acestei funcții, standardul POSIX a definit funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html" rel="nofollow">sigaction</a> pentru asocierea unui handler cu un semnal. <code>sigaction</code> oferă mai mult control, cu prețul unui grad de complexitate mai mare.
</p>
<pre class="code c"><span class="kw4">int</span> sigaction<span class="br0">(</span><span class="kw4">int</span> signum<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">struct</span> sigaction <span class="sy0">*</span>act<span class="sy0">,</span> <span class="kw4">struct</span> sigaction <span class="sy0">*</span>oldact<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Componenta importantă a funcției <code>sigaction</code> este structura cu același nume, descrisă în pagina de manual a funcției:
</p>
<pre class="code c"> <span class="kw4">struct</span> sigaction <span class="br0">{</span>
               <span class="kw4">void</span>     <span class="br0">(</span><span class="sy0">*</span>sa_handler<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy0">;</span>
               <span class="kw4">void</span>     <span class="br0">(</span><span class="sy0">*</span>sa_sigaction<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="sy0">,</span> siginfo_t <span class="sy0">*,</span> <span class="kw4">void</span> <span class="sy0">*</span><span class="br0">)</span><span class="sy0">;</span>
               sigset_t   sa_mask<span class="sy0">;</span>
               <span class="kw4">int</span>        sa_flags<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span></pre>

<p>
Dacă în câmpul <code>sa_flags</code> se precizează flag-ul <code>SA_SIGINFO</code>, handler-ul folosit este cel specificat de <code>sa_sigaction</code>. Altfel, handler-ul folosit este <code>sa_handler</code>. Masca de semnale care ar trebui blocate în timpul execuției handler-ului este reprezentată de <code>sa_mask</code>.
</p>

<p>
Un exemplu de asociere a unui handler de tratare a unui semnal este prezentat mai jos:
</p>
<pre class="code c"><span class="co2">#include &lt;signal.h&gt;</span>
...
&nbsp;
<span class="coMULTI">/* SIGUSR2 handler */</span>
<span class="kw4">static</span> <span class="kw4">void</span> usr2_handler<span class="br0">(</span><span class="kw4">int</span> signum<span class="br0">)</span> <span class="br0">{</span>
    ...
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">struct</span> sigaction sa<span class="sy0">;</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/memset.html"><span class="kw3">memset</span></a><span class="br0">(</span><span class="sy0">&amp;</span>sa<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">(</span>sa<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    sa.<span class="me1">sa_flags</span>   <span class="sy0">=</span> SA_RESETHAND<span class="sy0">;</span>   <span class="coMULTI">/* restore handler to previous state */</span>
    sa.<span class="me1">sa_handler</span> <span class="sy0">=</span> usr2_handler<span class="sy0">;</span>
    sigaction<span class="br0">(</span>SIGUSR2<span class="sy0">,</span> <span class="sy0">&amp;</span>sa<span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>

<p>
<strong>Atenție!</strong> Se poate opta pentru configurarea unui handler propriu sau se poate folosi unul predefinit. Se poate folosi <code>SIG_IGN</code> pentru ignorarea semnalului sau <code>SIG_DFL</code> pentru rularea acțiunii implicite (terminarea procesului, ignorarea semnalului etc).
</p>

</div>

<h4 id="structura_siginfo_t">Structura siginfo_t</h4>
<div class="level4">

<p>
În cazul prezenței <code>SA_SIGINFO</code>, se folosește câmpul <code>sa_sigaction</code> al structurii <code>sigaction</code> pentru a specifica handler-ul asociat semnalului. Handler-ul folosit primește în acest caz trei parametri și poate fi folosit pentru a transmite o informație utilă, o dată cu procesul. Al treilea argument (de tipul <code>void*</code>) este rar utilizat. Al doilea argument, de tipul <code>siginfo_t</code> definește o structură ce conține informații utile despre contextul apariției semnalului și alte informații pe care le poate furniza programatorul. Definiția structurii se găsește în pagina de manual a funcției <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html" rel="nofollow">sigaction</a>.
</p>
<pre class="code c"> siginfo_t <span class="br0">{</span>
               <span class="kw4">int</span>      si_signo<span class="sy0">;</span>    <span class="coMULTI">/* Signal number */</span>
               <span class="kw4">int</span>      si_errno<span class="sy0">;</span>    <span class="coMULTI">/* An errno value */</span>
               <span class="kw4">int</span>      si_code<span class="sy0">;</span>     <span class="coMULTI">/* Signal code */</span>
               <span class="kw4">int</span>      si_trapno<span class="sy0">;</span>   <span class="coMULTI">/* Trap number that caused
                                        hardware-generated signal
                                        (unused on most architectures) */</span>
               pid_t    si_pid<span class="sy0">;</span>      <span class="coMULTI">/* Sending process ID */</span>
               uid_t    si_uid<span class="sy0">;</span>      <span class="coMULTI">/* Real user ID of sending process */</span>
               <span class="kw4">int</span>      si_status<span class="sy0">;</span>   <span class="coMULTI">/* Exit value or signal */</span>
               clock_t  si_utime<span class="sy0">;</span>    <span class="coMULTI">/* User time consumed */</span>
               clock_t  si_stime<span class="sy0">;</span>    <span class="coMULTI">/* System time consumed */</span>
               sigval_t si_value<span class="sy0">;</span>    <span class="coMULTI">/* Signal value */</span>
               <span class="kw4">int</span>      si_int<span class="sy0">;</span>      <span class="coMULTI">/* POSIX.1b signal */</span>
               <span class="kw4">void</span>    <span class="sy0">*</span>si_ptr<span class="sy0">;</span>      <span class="coMULTI">/* POSIX.1b signal */</span>
               <span class="kw4">int</span>      si_overrun<span class="sy0">;</span>  <span class="coMULTI">/* Timer overrun count; POSIX.1b timers */</span>
               <span class="kw4">int</span>      si_timerid<span class="sy0">;</span>  <span class="coMULTI">/* Timer ID; POSIX.1b timers */</span>
               <span class="kw4">void</span>    <span class="sy0">*</span>si_addr<span class="sy0">;</span>     <span class="coMULTI">/* Memory location which caused fault */</span>
               <span class="kw4">long</span>     si_band<span class="sy0">;</span>     <span class="coMULTI">/* Band event (was int in
                                        glibc 2.3.2 and earlier) */</span>
               <span class="kw4">int</span>      si_fd<span class="sy0">;</span>       <span class="coMULTI">/* File descriptor */</span>
               <span class="kw4">short</span>    si_addr_lsb<span class="sy0">;</span> <span class="coMULTI">/* Least significant bit of address
                                        (since kernel 2.6.32) */</span>
<span class="br0">}</span></pre>

<p>
Membrii structurii sunt inițializați numai atunci când valorile lor sunt utile. Membrii <code>si_signo</code>, <code>si_errno</code> și <code>si_code</code> sunt întotdeauna definiți pentru toate semnalele. Restul structurii poate fi o uniune, așa că ar trebui citite numai câmpurile care au sens pentru semnalul primit. Spre exemplu, apelul de sistem <code>kill</code>, semnalele POSIX.1b și <code>SIGCHLD</code> completează <code>si_pid</code> și <code>si_uid</code>, iar <code>SIGILL</code>, <code>SIGFPE</code>, <code>SIGSEGV</code> și <code>SIGBUS</code> completează <code>si_addr</code> cu adresa care a provocat eroarea.
</p>

</div>

<h3 class="sectionedit11" id="semnalarea_proceselor">Semnalarea proceselor</h3>
<div class="level3">

<p>
Pentru transmiterea unui semnal, se poate folosi funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html" rel="nofollow">kill</a> sau funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigqueue.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigqueue.2.html" rel="nofollow">sigqueue</a>. Funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html" rel="nofollow">kill</a> are dezavantajul că <strong>nu</strong> garantează recepționarea semnalului de procesul destinație. Dacă este nevoie să se trimită un semnal unui proces și să se știe sigur că a ajuns se recomandă folosirea funcției <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigqueue.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigqueue.2.html" rel="nofollow">sigqueue</a>:
</p>
<pre class="code c"><span class="kw4">int</span> sigqueue<span class="br0">(</span>pid_t pid<span class="sy0">,</span> <span class="kw4">int</span> signo<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">union</span> sigval value<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Funcția trimite semnalul <code>signo</code>, cu parametrii specificați de <code>value</code>, procesului cu identificatorul <code>pid</code>. Dacă semnalul este zero, se fac verificări pentru cazurile de eroare posibile, dar nu se trimite niciun semnal. Semnalul nul poate fi folosit pentru a verifica faptul că pid-ul este valid.
</p>

<p>
Valoarea ce poate fi trimisă odată cu semnalul este un union:
</p>
<pre class="code c"><span class="kw4">union</span> sigval <span class="br0">{</span>
     <span class="kw4">int</span>   sival_int<span class="sy0">;</span>
     <span class="kw4">void</span> <span class="sy0">*</span>sival_ptr<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span></pre>

<p>
Un parametru trimis astfel apare în câmpul <code>si_value</code> al structurii <code>siginfo_t</code>, primite de handler-ul de semnal. În mod evident, <strong>nu</strong> are sens transmiterea de pointeri dintr-un proces în altul.
</p>

<p>
Condițiile cerute pentru ca un proces să aibă permisiunea de a trimite un semnal altui proces sunt aceleași ca și în cazul lui <code>kill</code>. Dacă semnalul specificat este blocat în acel moment, funcția va ieși imediat și dacă flagul <code>SA_SIGINFO</code> este setat și există resurse necesare, semnalul va fi pus în coadă în starea pending (un proces poate avea în coadă maxim <code>SIGQUEUE_MAX</code> semnale). De asemenea, când semnalul este primit, câmpul <code>si_code</code>, pasat structurii <code>siginfo</code>, va fi setat la <code>SI_QUEUE</code>, și <code>si_value</code> va fi setat la <code>value</code>.
</p>

<p>
Dacă flagul <code>SA_SIGINFO</code> nu este setat, atunci <code>signo</code>, dar nu în mod necesar și <code>value</code>, vor fi trimise, cel puțin o dată, procesului care trebuie să primească semnalul.
</p>

</div>

<h3 class="sectionedit12" id="asteptarea_unui_semnal">Așteptarea unui semnal</h3>
<div class="level3">
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Click to display ⇲
</p>
</div><div class="hiddenBody" style="display: none;">
<p>
În cazul în care se utilizează semnalele pentru comunicare și/sau sincronizare, există, deseori, nevoie să se aștepte ca un anumit tip de semnal să-i sosească procesului în cauză. Un mod simplu de a realiza acest lucru este o buclă, a cărei condiție de ieșire ar fi setarea corespunzătoare a unei variabile (variabila trebuie să fie de tipul <code>sig_atomic_t</code>). De exemplu:
</p>
<pre class="code c"><span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>signal_has_arrived<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Principalul dezavantaj al abordării de mai sus (de tip <em>busy-waiting</em>) este timpul de procesor pe care procesul considerat îl pierde în mod inutil. O variantă ar fi folosirea funcției <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/sleep.3.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man3/sleep.3.html" rel="nofollow">sleep</a>:
</p>
<pre class="code c"><span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>signal_has_arrived<span class="br0">)</span> <span class="br0">{</span>
    sleep<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>

<p>
O astfel de abordare nu ar mai ocupa timp inutil de procesor, dar timpul de răspuns în cazul sosirii unui semnal este destul de mare. O altă soluție a problemei este funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pause.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/pause.2.html" rel="nofollow">pause</a> (care blochează fluxul de execuție până când procesul curent este întrerupt de un semnal). Deși această abordare pare foarte simplă, ea introduce, adeseori, deadlock-uri, care blochează programul nedefinit. Un exemplu în acest sens este pseudosoluția de mai jos, la problema așteptării unui semnal:
</p>
<pre class="code c"><span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>signal_has_arrived<span class="br0">)</span> <span class="br0">{</span>
    pause<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>

<p>
Bucla este necesară pentru prevenirea situației în care procesul este întrerupt de alte semnale decât cel așteptat. Se poate întâmpla ca semnalul să ajungă <strong>după</strong> testarea variabilei și <strong>înainte</strong> de apelul funcției pause. În acest caz, procesul se blochează și, dacă nu apare un alt semnal care să cauzeze ieșirea din <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pause.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/pause.2.html" rel="nofollow">pause</a>, el va rămâne blocat nedefinit.
</p>
</div></div>
<p>
<br>

Soluția cea mai bună pentru a aștepta un semnal se poate realiza prin utilizarea funcției <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html" rel="nofollow">sigsuspend</a>:
</p>
<pre class="code c"><span class="kw4">int</span> sigsuspend<span class="br0">(</span><span class="kw4">const</span> sigset_t <span class="sy0">*</span>set<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Funcția înlocuiește masca de semnale blocate a procesului, cu <code>set</code>, și suspendă procesul până când este primit un semnal care nu este blocat de noua mască. La ieșire, funcția restaurează vechea mască de semnale.
</p>

<p>
În secvența de mai jos, funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html" rel="nofollow">sigsuspend</a> este folosită pentru a întrerupe procesul curent până la recepționarea semnalului <code>SIGINT</code>. Semnalele <code>SIGKILL</code> și <code>SIGSTOP</code>, deși prezente în masca de semnale, nu vor fi blocate:
</p>
<pre class="code c">sigset_t set<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* block all signals except SIGINT */</span>
sigfillset<span class="br0">(</span><span class="sy0">&amp;</span>set<span class="br0">)</span><span class="sy0">;</span>
sigdelset<span class="br0">(</span><span class="sy0">&amp;</span>set<span class="sy0">,</span> SIGINT<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* wait for SIGINT */</span>
sigsuspend<span class="br0">(</span><span class="sy0">&amp;</span>set<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h3 class="sectionedit13" id="considerente_privind_utilizarea_unui_handler_de_semnal">Considerente privind utilizarea unui handler de semnal</h3>
<div class="level3">
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Click to display ⇲
</p>
</div><div class="hiddenBody" style="display: none;">
<p>
Un obiect de tip semnal este atașat unui obiect de tip proces. Dacă procesul nu rulează în acel moment, sistemul de operare poate atașa unui proces numai un singur semnal care va rămâne în starea pending. Dacă procesul rula în acel moment, semnalul primit este deservit imediat și va întrerupe fluxul normal de execuție, permițându-se primirea, fără pierdere, a unui semnal de același tip.
</p>

<p>
Pentru că numărul de semnale de un anumit tip care poate fi primit de un proces într-un anumit timp este limitat și pentru a evita pierderea de semnale, un handler trebuie să se execute cât mai <strong>repede</strong>.
</p>

<p>
Fluxul de execuție al unui proces este văzut de către sistemul de operare ca o înșiruire de instrucțiuni pe care platforma le suportă. Unele operații din limbajele de programare de nivel înalt <strong>nu</strong> sunt atomice și indivizibile, fiind nevoie de mai multe instrucțiuni în cod mașină pentru a se efectua respectiva operație. Un exemplu simplu este atribuirea între variabile:
</p>
<pre class="code c">a <span class="sy0">=</span> b<span class="sy0">;</span></pre>

<p>
Majoritatea platformelor actuale nu permit instrucțiuni în care ambii operanzi să fie în memorie. Pe astfel de platforme, o implementare standard pentru această operație ar fi încărcarea valorii lui <code>b</code> într-un registru, după care ar urma încărcarea la adresa lui <code>a</code> a valorii salvate în registru :
</p>
<pre class="code asm">load registru_1<span class="sy1">,</span> b
store a<span class="sy1">,</span> registru_1</pre>

<p>
De aceea, este nevoie de atenție suplimentară atunci când un semnal folosește variabile care nu sunt locale funcției, deoarece semnalele pot întrerupe fluxul de execuție în orice punct al său, lăsând astfel unele variabile într-o stare <strong>inconsistentă</strong>. Pentru a fi siguri că o variabilă nu are valori inconsistente se recomandă folosirea tipului <code>sig_atomic_t</code> pentru variabilele din fluxul de execuție care interacționează cu handlerele de semnale. Acest tip este unul din tipurile întregi disponibile, putând varia de la o platformă la alta. Așadar operațiile ce se pot efectua cu acest tip, sunt aceleași cu cele ale unui întreg.
</p>
</div></div>
<p>
<br>

</p>

</div>

<h3 class="sectionedit14" id="timere_in_linux">Timere în Linux</h3>
<div class="level3">

<p>
În Linux, folosirea timer-elor este legată de folosirea semnalelor. Acest lucru se întâmplă întrucât cea mai mare parte a funcțiilor de tip timer folosesc semnale.
</p>

<p>
Un timer este, de obicei, un întreg a cărui valoare este decrementată în timp. În momentul în care întregul ajunge la 0, timer-ul expiră. În Linux, expirarea timer-ului are drept rezultat, în general, transmiterea unui semnal. Definirea unui “timer handler” (rutină apelată în momentul expirării timer-ului) este, astfel, echivalentă cu definirea unui handler pentru semnalul asociat.
</p>

<p>
Înregistrarea unui timer, în Linux, înseamnă specificarea unui interval după care un timer expiră și configurarea handler-ului care va rula. Configurarea handler-ului se poate realiza atât prin intermediul funcției <code>sigaction</code> (în momentul in care timer-ul expiră se generază un semnal, care la rândul lui generează rularea handler-ului asociat), sau direct prin intermediul parametrilor funcției <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html" rel="nofollow">timer_create</a>. 
</p>

<p>
Utilizarea unui timer presupune mai mulți pași:
</p>
<ul>
<li class="level1"><div class="li"> <strong>crearea unui timer</strong> - folosind funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html" rel="nofollow">timer_create</a>:</div>
</li>
</ul>
<pre class="code c"> <span class="kw4">int</span> timer_create<span class="br0">(</span>clockid_t clockid<span class="sy0">,</span> <span class="kw4">struct</span> sigevent <span class="sy0">*</span>evp<span class="sy0">,</span> timer_t <span class="sy0">*</span>timerid<span class="br0">)</span> </pre>

<p>
Timer-ul creat se identifică prin <code>timerid</code>. Prin intermediul structurii <code>sigevent</code> se setează modul în care va interacționa timer-ul cu procesul/thread-ul care l-a lansat. Exemplu de folosire:
</p>
<pre class="code c">timer_t timerid<span class="sy0">;</span>
<span class="kw4">struct</span> sigevent sev<span class="sy0">;</span>
&nbsp;
sev.<span class="me1">sigev_notify</span> <span class="sy0">=</span> SIGEV_SIGNAL<span class="sy0">;</span>             <span class="coMULTI">/* notification method */</span>
sev.<span class="me1">sigev_signo</span> <span class="sy0">=</span> SIGRTMIN<span class="sy0">;</span>                  <span class="coMULTI">/* Timer expiration signal */</span>
sev.<span class="me1">sigev_value</span>.<span class="me1">sival_ptr</span> <span class="sy0">=</span> <span class="sy0">&amp;</span>timerid<span class="sy0">;</span>        
timer_create<span class="br0">(</span>CLOCK_REALTIME<span class="sy0">,</span> <span class="sy0">&amp;</span>sev<span class="sy0">,</span> <span class="sy0">&amp;</span>timerid<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Prin intermediul primului argument se poate măsura timpul real al sistemului, timpul de rulare al procesului sau timpul de rulare al procesului în user-space și kernel-space. La timeout timer-ul va livra semnalul salvat în <code>sev.sigev_signo</code>
</p>
<ul>
<li class="level1"><div class="li"> <strong>armarea unui timer</strong> - folosind funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_settime.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_settime.2.html" rel="nofollow">timer_settime</a>:</div>
</li>
</ul>
<pre class="code c"><span class="kw4">int</span> timer_settime<span class="br0">(</span>timer_t timerid<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="sy0">,</span> 
                          <span class="kw4">const</span> <span class="kw4">struct</span> itimerspec <span class="sy0">*</span>new_value<span class="sy0">,</span>
                          <span class="kw4">struct</span> itimerspec <span class="sy0">*</span> old_value<span class="br0">)</span><span class="sy0">;</span> </pre>

<p>
Armarea timer-ului presupune completarea structurii <code>itimerspec</code> în care specifică timpul de pornire al timer-ului, cât și intervalul de expirare al timeout-ului (intervalele sunt măsurate în secunde și nanosecunde). 
Exemplu de folosire:
</p>
<pre class="code c">its.<span class="me1">it_value</span>.<span class="me1">tv_sec</span> <span class="sy0">=</span> freq_nanosecs <span class="sy0">/</span> <span class="nu0">1000000000</span><span class="sy0">;</span> <span class="coMULTI">/* Initial expiration in secs*/</span>
its.<span class="me1">it_value</span>.<span class="me1">tv_nsec</span> <span class="sy0">=</span> freq_nanosecs <span class="sy0">%</span> <span class="nu0">1000000000</span><span class="sy0">;</span><span class="coMULTI">/* Initial expiration in nsecs*/</span>
its.<span class="me1">it_interval</span>.<span class="me1">tv_sec</span> <span class="sy0">=</span> its.<span class="me1">it_value</span>.<span class="me1">tv_sec</span><span class="sy0">;</span>     <span class="coMULTI">/* Timer interval in secs */</span>
its.<span class="me1">it_interval</span>.<span class="me1">tv_nsec</span> <span class="sy0">=</span> its.<span class="me1">it_value</span>.<span class="me1">tv_nsec</span><span class="sy0">;</span>   <span class="coMULTI">/* Timer interval in nanosecs */</span> 
&nbsp;
timer_settime<span class="br0">(</span>timerid<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="sy0">&amp;</span>its<span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"><strong>ștergerea unui timer</strong> - folosind funcția <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_delete.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_delete.2.html" rel="nofollow">timer_delete</a></div>
</li>
</ul>
<pre class="code c"><span class="kw4">int</span> timer_delete<span class="br0">(</span>timer_t timerid<span class="br0">)</span><span class="sy0">;</span> </pre>

<p>
<strong>Important</strong> - pentru a folosi funcțiile de mai sus programul trebuie compilat cu <code>-lrt</code>
</p>

<p>
Una dintre formele de utilizare a timer-elor este implementarea funcțiilor de așteptare de tipul <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/sleep.3.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man3/sleep.3.html" rel="nofollow">sleep</a> sau <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/nanosleep.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/nanosleep.2.html" rel="nofollow">nanosleep</a>. Avantajul folosirii funcției <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/sleep.3.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man3/sleep.3.html" rel="nofollow">sleep</a> este simplitatea. Dezavantajele sunt rezoluția scăzută (secunde) și posibila interacțiune cu semnale (în special <code>SIGALRM</code>). <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/nanosleep.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/nanosleep.2.html" rel="nofollow">nanosleep</a> are un apel mai complex, dar oferă rezoluție până la ordinul nanosecundelor și este <em>signal-safe</em> (nu interacționează cu semnale).
</p>

</div>

<h2 class="sectionedit15" id="timere_sub_windows">Timere sub Windows</h2>
<div class="level2">

<p>
În Windows există mai multe mecanisme de notificare a proceselor: <a href="http://msdn.microsoft.com/en-us/library/ms682655(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682655(VS.85).aspx" rel="nofollow">evenimente</a>, <a href="http://msdn.microsoft.com/en-us/library/ms681951(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms681951(VS.85).aspx" rel="nofollow">APC-uri</a>, <a href="http://msdn.microsoft.com/en-us/library/ms682073%28VS.85%29.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682073%28VS.85%29.aspx" rel="nofollow">evenimente de consolă</a>, <a href="http://msdn.microsoft.com/en-us/library/ms687012(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687012(VS.85).aspx" rel="nofollow">timere</a>. <strong>Evenimentele</strong> sunt folosite pentru sincronizarea între thread-uri/procese. <strong>APC</strong>-urile sunt mecanisme de execuție asincronă în contextul unui proces/thread. Pot fi folosite pentru rularea unei secvențe de cod în combinație cu un timer.
</p>

</div>

<h3 class="sectionedit16" id="waitable_timer_objects">Waitable Timer Objects</h3>
<div class="level3">

<p>
Un obiect de tipul <strong>waitable timer</strong> este un obiect de sincronizare a cărui stare este semnalizată (<strong><em>signaled</em></strong>) atunci când timpul specificat se scurge. Există două tipuri de obiecte waitable timer ce pot fi create:
</p>
<ul>
<li class="level1"><div class="li">timer cu <strong>resetare manuală</strong>: un timer a cărui stare rămâne semnalizată până când un nou apel al funcției <a href="http://msdn.microsoft.com/en-us/library/ms686289(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686289(VS.85).aspx" rel="nofollow">SetWaitableTimer</a> setează un nou timp de așteptare;</div>
</li>
<li class="level1"><div class="li">timer cu <strong>resetare automată</strong>: un timer a cărui stare rămâne <em>signaled</em> până când un thread efectuează o operație de așteptare pe acel obiect.</div>
</li>
</ul>

<p>
Oricare dintre cele două tipuri de timer poate fi configurat ca un timer periodic. Un timer periodic este reactivat de fiecare dată când perioada de timp specificată expiră, până când timer-ul este setat din nou sau anulat. Operațiile care se pot efectua cu un timer sunt:
</p>
<ul>
<li class="level1"><div class="li"><strong>crearea</strong> unui timer - se realizează prin intermediul funcției <a href="http://msdn.microsoft.com/en-us/library/ms682492(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms682492(VS.85).aspx" rel="nofollow">CreateWaitableTimer</a></div>
</li>
<li class="level1"><div class="li"><strong>setarea</strong> unui timer - se poate face cu funcția <a href="http://msdn.microsoft.com/en-us/library/ms686289(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686289(VS.85).aspx" rel="nofollow">SetWaitableTimer</a></div>
</li>
<li class="level1"><div class="li"><strong>anularea</strong> - se realizează cu ajutorul funcției <a href="http://msdn.microsoft.com/en-us/library/ms681985.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms681985.aspx" rel="nofollow">CancelWaitableTimer</a></div>
</li>
<li class="level1"><div class="li"><strong>așteptarea</strong> -  folosind funcția <a href="http://msdn.microsoft.com/en-us/library/ms687032.aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms687032.aspx" rel="nofollow">WaitForSingleObject</a></div>
</li>
</ul>

<p>
În secvența de cod de mai jos, se folosește un timer pentru afișarea unui mesaj după 5 secunde:
</p>
<pre class="code c"><span class="co2">#define _WIN32_WINNT    0x0500</span>
<span class="co2">#include &lt;windows.h&gt;</span>
...
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
    HANDLE timerHandle<span class="sy0">;</span>
    LARGE_INTEGER dueTime<span class="sy0">;</span>
&nbsp;
    timerHandle <span class="sy0">=</span> CreateWaitableTimer<span class="br0">(</span>NULL<span class="sy0">,</span> FALSE<span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>timerHandle <span class="sy0">==</span> NULL<span class="br0">)</span> <span class="br0">{</span>
        <a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="kw3">fprintf</span></a><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"CreateWaitableTimer failed (%d)<span class="es1">\n</span>"</span><span class="sy0">,</span> GetLastError<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">(</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <span class="coMULTI">/* configure to expire in 5 seconds; base unit is 100ns */</span>
    dueTime.<span class="me1">QuadPart</span> <span class="sy0">=</span> <span class="sy0">-</span>50000000LL<span class="sy0">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>SetWaitableTimer<span class="br0">(</span>timerHandle<span class="sy0">,</span> <span class="sy0">&amp;</span>dueTime<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> NULL<span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span> <span class="sy0">==</span> FALSE<span class="br0">)</span> <span class="br0">{</span>
        <a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="kw3">fprintf</span></a><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"SetWaitableTimer failed (%d)<span class="es1">\n</span>"</span><span class="sy0">,</span> GetLastError<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">(</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">(</span>WaitForSingleObject<span class="br0">(</span>timerHandle<span class="sy0">,</span> INFINITE<span class="br0">)</span> <span class="sy0">!=</span> WAIT_OBJECT_0<span class="br0">)</span> <span class="br0">{</span>
        <a href="http://www.opengroup.org/onlinepubs/009695399/functions/fprintf.html"><span class="kw3">fprintf</span></a><span class="br0">(</span><span class="st0">"WaitForSingleObject failed (%d)<span class="es1">\n</span>"</span><span class="sy0">,</span> GetLastError<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">(</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"5 seconds timer expired<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>

</div>

<h2 class="sectionedit17" id="exercitii">Exerciții</h2>
<div class="level2">

<p>
În rezolvarea laboratorului folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab06-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab06-tasks.zip" rel="nofollow"> lab06-tasks.zip</a>
</p>

<p>
<strong>Observații</strong>: Pentru a vă ajuta la implementarea exercițiilor din laborator, în directorul <code>utils</code> din arhivă există un fișier <code>utils.h</code> cu funcții utile.
</p>

</div>

<h3 class="sectionedit18" id="linux">Linux</h3>
<div class="level3">

<p>
<strong>Atenție</strong>: La folosirea <code>sigaction</code>, veți inițializa, în general, câmpul <code>sa_flags</code> al structurii <code>struct sigaction</code> la <code>0</code>. 
</p>
<ol>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Intrați în directorul <code>1-hitme/</code>:</div>
<ul>
<li class="level2"><div class="li"> Analizați conținutul fișierului <code>hitme.c</code>, compilați și rulați programul.</div>
</li>
<li class="level2"><div class="li"> Folosiți comanda <code>kill -l</code> pentru a lista toate semnalele disponibile. Ce valoare are semnalul <code>SIGKILL</code>?</div>
</li>
<li class="level2"><div class="li"> Într-o altă consolă trimiteți programului <code>hitme</code> semnale cu valori cuprinse între 20 și 25 astfel:<pre class="code bash"><span class="kw2">kill</span> <span class="re5">-20</span> $<span class="br0">(</span><span class="kw2">pidof</span> hitme<span class="br0">)</span>
<span class="kw2">kill</span> <span class="re5">-21</span> $<span class="br0">(</span><span class="kw2">pidof</span> hitme<span class="br0">)</span>
<span class="kw2">kill</span> <span class="re5">-22</span> $<span class="br0">(</span><span class="kw2">pidof</span> hitme<span class="br0">)</span>
<span class="kw2">kill</span> <span class="re5">-23</span> $<span class="br0">(</span><span class="kw2">pidof</span> hitme<span class="br0">)</span>
<span class="kw2">kill</span> <span class="re5">-24</span> $<span class="br0">(</span><span class="kw2">pidof</span> hitme<span class="br0">)</span>
<span class="kw2">kill</span> <span class="re5">-25</span> $<span class="br0">(</span><span class="kw2">pidof</span> hitme<span class="br0">)</span></pre>
</div>
</li>
<li class="level2"><div class="li"> Încercați să trimiteți același semnal de două ori și explicați comportamentul. Ce ar trebui schimbat ca să se poată trimite același semnal de două ori.</div>
</li>
<li class="level2"><div class="li"> <strong>Hints:</strong></div>
<ul>
<li class="level3"><div class="li"> Analizați cu atenție <code>signals.sa_flags</code>.</div>
</li>
<li class="level3"><div class="li"> Puteți reveni la secțiunea <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#tratarea_semnalelor" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Tratarea semnalelor</a> sau să investigați structura <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html" rel="nofollow">sigaction</a></div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Normal signals vs Real-Time signals</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>2-signals</code> și urmăriți conținutul fișierului <code>signals.c</code>.</div>
</li>
<li class="level2"><div class="li"> Programul numără de câte ori se apelează handlerul de semnal în cazul trimiterii semnalelor <code>SIGINT</code> și <code>SIGRTMIN</code></div>
</li>
<li class="level2"><div class="li"> Porniți într-o consolă programul <code>signals</code>:<pre class="code bash">.<span class="sy0">/</span>signals</pre>
</div>
</li>
<li class="level2"><div class="li"> Pentru cazul semnalelor <code>normale</code>:</div>
<ul>
<li class="level3"><div class="li"> Într-o altă consolă rulați scriptul <code>send_normal.sh</code>:<pre class="code bash">.<span class="sy0">/</span>send_normal.sh</pre>
</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Pentru semnalele <code>real-time</code>:</div>
<ul>
<li class="level3"><div class="li"> Într-o altă consolă rulați scriptul <code>send_rt.sh</code>:<pre class="code bash">.<span class="sy0">/</span>send_rt.sh</pre>
</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Pentru a închide executabilul <code>signals</code> este trimis semnalul <code>SIGQUIT</code> </div>
</li>
<li class="level2"><div class="li"> De unde apare diferența ?</div>
</li>
<li class="level2"><div class="li"> <strong>Hint</strong></div>
<ul>
<li class="level3"><div class="li"> Revedeți secțiunea <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#tipuri_standard_de_semnale" title="so:laboratoare:laborator-06 ↵" class="wikilink1"> id
      * Tipuri standard de semnale</a></div>
</li>
<li class="level3"><div class="li"> Citiți din pagina de manual <code>man 7 signal</code> secțiunea “Real-time signals”.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Intrați în directorul <code>3-askexit</code>.</div>
<ul>
<li class="level2"><div class="li"> Programul face busy waiting, afișând la consolă numere consecutive.</div>
</li>
<li class="level2"><div class="li"> Trebuie să completați programul pentru a intercepta semnalele generate de <code>CTRL+\</code>, <code>CTRL+C</code> și <code>SIGUSR1</code> (folosiți comanda <code>kill</code>). Handler-ul asociat cu fiecare din semnale va fi <code>ask_handler</code>.</div>
</li>
<li class="level2"><div class="li"> Pentru fiecare semnal primit va întreba utilizatorul dacă dorește să încheie execuția sau nu.</div>
</li>
<li class="level2"><div class="li"> Testați funcționalitatea programului.</div>
</li>
<li class="level2"><div class="li"> Observați vreo problemă în folosirea funcțiilor <code>printf</code>, <code>scanf</code> în handlere de semnale?</div>
</li>
<li class="level2"><div class="li"> <strong>Hint</strong></div>
<ul>
<li class="level3"><div class="li"> Consultați secțiunea <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#tratarea_semnalelor" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Tratarea semnalelor</a>.  </div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Intrați în directorul <code>4-nohup</code>.</div>
<ul>
<li class="level2"><div class="li"> Realizați un program, denumit <code>mynohup</code>, care simulează comanda <a href="http://linux.die.net/man/1/nohup" class="urlextern" title="http://linux.die.net/man/1/nohup" rel="nofollow">nohup</a>.</div>
</li>
<li class="level2"><div class="li"> Programul primește, ca prim parametru, numele unei comenzi de executat.</div>
</li>
<li class="level2"><div class="li"> Restul parametrilor reprezintă argumentele cu care trebuie invocată comanda respectivă; lista de argumente poate fi nulă.</div>
</li>
<li class="level2"><div class="li"> Programul executat de <code>mynohup</code> trebuie să nu fie înștiințat de închiderea terminalului la care era conectat.</div>
<ul>
<li class="level3"><div class="li"> Va trebui să ignorați semnalul <code>SIGHUP</code>, livrat de shell procesului, în momentul încheierii sesiunii curente. </div>
</li>
<li class="level3"><div class="li"> <strong>Hint</strong>: </div>
<ul>
<li class="level4"><div class="li"> Revedeți secțiunea despre <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#tratarea_semnalelor" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Tratarea semnalelor</a>.  </div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Dacă fișierul standard de ieșire era legat la un terminal acesta trebuie redirectat într-un fișier definit prin macro-ul <code>NOHUP_OUT_FILE</code>.</div>
<ul>
<li class="level3"><div class="li"> Folosiți apelul <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/isatty.3.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man3/isatty.3.html" rel="nofollow">isatty</a>. </div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Testare:</div>
<ul>
<li class="level3"><div class="li"> Rulați <pre class="code bash">.<span class="sy0">/</span>mynohup gedit <span class="sy0">&amp;</span></pre>

<p>
 sau 
</p>
<pre class="code bash">.<span class="sy0">/</span>mynohup <span class="kw2">sleep</span> <span class="nu0">20</span> <span class="sy0">&amp;</span></pre>
</div>
</li>
<li class="level3"><div class="li"> După rulare închideți sesiunea de shell curentă.</div>
<ul>
<li class="level4"><div class="li"> Închideți fereastra terminalului în care rulează shell-ul (folosind mediul grafic).</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Dintr-o altă consolă rulați <pre class="code bash"><span class="kw2">ps</span> <span class="re5">-ef</span> <span class="sy0">|</span> <span class="kw2">grep</span> gedit </pre>

<p>
 respectiv 
</p>
<pre class="code bash"><span class="kw2">ps</span> <span class="re5">-ef</span> <span class="sy0">|</span> <span class="kw2">grep</span> <span class="kw2">sleep</span> </pre>
</div>
<ul>
<li class="level4"><div class="li"> Cine este noul părinte al procesului?</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Consultați secțiunea <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#tratarea_semnalelor" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Tratarea semnalelor</a> și secțiunile <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-03#inlocuirea_imaginii_unui_proces" class="wikilink1" title="so:laboratoare:laborator-03">Înlocuirea imaginii unui proces</a> și <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-02#redirectari" class="wikilink1" title="so:laboratoare:laborator-02">Redirectări</a> din laboratoarele precedente. </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Intrați în directorul <code>5-zombie</code>.</div>
<ul>
<li class="level2"><div class="li"> Urmăriți conținutul fișierelor <code>mkzombie.c</code> și <code>nozombie.c</code>.</div>
</li>
<li class="level2"><div class="li"> Fiecare program va crea câte un proces copil nou, care doar va apela <code>exit</code>.</div>
</li>
<li class="level2"><div class="li"> <code>mkzombie</code> va aștepta <code>TIMEOUT</code> secunde și va ieși.</div>
<ul>
<li class="level3"><div class="li"> Din altă consolă rulați <pre class="code bash"><span class="kw2">ps</span> <span class="re5">-eF</span> <span class="sy0">|</span> <span class="kw2">grep</span> zombie</pre>
</div>
</li>
<li class="level3"><div class="li"> Observați faptul că procesul copil, deși nu mai rulează, apare în lista de procese ca <code>&lt;defunct&gt;</code> și are un pid (unic în sistem la acel moment).</div>
</li>
<li class="level3"><div class="li"> Observați că, după moartea procesului părinte, dispare și procesul zombie. </div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <code>nozombie</code> va aștepta <code>TIMEOUT</code> secunde și va ieși.</div>
<ul>
<li class="level3"><div class="li"> Implementați <code>nozombie</code> fără a folosi funcțiile de așteptare de tipul <code>wait</code>, astfel încât procesul copil să nu treacă în starea de zombie.</div>
<ul>
<li class="level4"><div class="li"> Folosiți semnalul <code>SIGCHLD</code>. Informații găsiți în <a href="http://linux.die.net/man/2/sigaction" class="urlextern" title="http://linux.die.net/man/2/sigaction" rel="nofollow">sigaction(2)</a> și <a href="http://linux.die.net/man/3/wait" class="urlextern" title="http://linux.die.net/man/3/wait" rel="nofollow">wait(2)</a>.</div>
</li>
<li class="level4"><div class="li"> <strong>Pe scurt</strong>: dacă părintele ignoră în mod explicit semnalul SIGCHLD prin setarea handler-ului la SIG_IGN (în loc să ignore semnalul în mod implicit) informația despre exit status al copiilor va fi aruncată iar copiii nu vor deveni procese zombie.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Consultați secțiunile <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#tratarea_semnalelor" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Tratarea semnalelor</a> și <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-03#crearea_unui_proces" class="wikilink1" title="so:laboratoare:laborator-03">Crearea unui proces</a>. </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>3 puncte</strong>) Intrați în directorul <code>6-timer</code>.</div>
<ul>
<li class="level2"><div class="li"> Urmăriți conținutul fișierului <code>mytimer.c</code>.</div>
</li>
<li class="level2"><div class="li"> Exercițiul urmărește afișarea timpului curent la fiecare <code>TIMEOUT</code> secunde. Pentru a nu consuma inutil timpul de procesor, se va suspenda procesul curent până la apariția semnalului generat de timer.</div>
</li>
<li class="level2"><div class="li"> <strong>Hints</strong>: </div>
<ul>
<li class="level3"><div class="li"> Urmăriți secțiunile cu <code>TODO</code> din fișierul sursă.</div>
</li>
<li class="level3"><div class="li"> Folosiți <a href="http://linux.die.net/man/3/ctime" class="urlextern" title="http://linux.die.net/man/3/ctime" rel="nofollow">ctime</a> și <a href="http://linux.die.net/man/2/time" class="urlextern" title="http://linux.die.net/man/2/time" rel="nofollow">time</a> pentru afișarea timpului curent.</div>
<ul>
<li class="level4"><div class="li"> Puteți vedea un exemplu de folosire <a href="http://www.cplusplus.com/reference/clibrary/ctime/ctime/" class="urlextern" title="http://www.cplusplus.com/reference/clibrary/ctime/ctime/" rel="nofollow">aici</a></div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Folosiți <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html" rel="nofollow">timer_create</a> și <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_settime.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_settime.2.html" rel="nofollow">timer_settime</a> pentru a crea și arma timer-ul.</div>
</li>
<li class="level3"><div class="li"> <strong>Semnalul generat de timer va fi <code>SIGALRM</code></strong>.</div>
<ul>
<li class="level4"><div class="li"> Urmăriți secțiunea <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#timere_in_linux" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Timere în Linux</a> </div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Folosiți <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html" rel="nofollow">sigsupend</a> pentru a aștepta declanșarea semnalului generat de timer. </div>
<ul>
<li class="level4"><div class="li"> Obțineți, folosind <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigprocmask.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigprocmask.2.html" rel="nofollow">sigprocmask</a>, masca procesului curent și transmiteți-o ca argument către <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html" rel="nofollow">sigsupend</a>. </div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Urmăriți secțiunile <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#timere_in_linux" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Timere în Linux</a> și <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#asteptarea_unui_semnal" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Așteptarea unui semnal</a></div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>

<h3 class="sectionedit19" id="bonus_-_linux">BONUS - Linux</h3>
<div class="level3">
<ol>
<li class="level1"><div class="li"> (<strong>1 so karma</strong>) Ramâneți în directorul <code>6-timer</code>.</div>
<ul>
<li class="level2"><div class="li"> Modificați sursa de la exercițiul 6 astfel încât să configurați funcția de handler direct din parametrii funcției <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html" rel="nofollow">timer_create()</a>.</div>
</li>
<li class="level2"><div class="li"> Hint:</div>
<ul>
<li class="level3"><div class="li"> Urmariți conținutul structurii <code>sigevent</code>.</div>
</li>
<li class="level3"><div class="li"> Un exemplu găsiți <a href="http://davewilkinsonii.com/tutorials/linux/101.php" class="urlextern" title="http://davewilkinsonii.com/tutorials/linux/101.php" rel="nofollow">aici</a>.</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>

<h3 class="sectionedit20" id="bonus_-_windows">BONUS - Windows</h3>
<div class="level3">
<ol>
<li class="level1"><div class="li"> (<strong>2 so karma</strong>) Intrați în directorul <code>1-timer</code>.</div>
<ul>
<li class="level2"><div class="li"> Urmăriți conținutul fișierului <code>mytimer.c</code>.</div>
</li>
<li class="level2"><div class="li"> Realizați un program care afișează data curentă la fiecare <code>TIMEOUT</code> secunde.</div>
</li>
<li class="level2"><div class="li"> <strong>Hints</strong>: </div>
<ul>
<li class="level3"><div class="li"> Folosiți componenta <code>QuadPart</code> a tipului <code>LARGE_INTEGER</code> pentru specificarea timeout-ului. Timeout-ul este <strong>negativ</strong> și expiră la atingerea valorii <code>0</code>.</div>
</li>
<li class="level3"><div class="li"> Al treilea argument al <a href="http://msdn.microsoft.com/en-us/library/ms686289(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686289(VS.85).aspx" rel="nofollow">SetWaitableTimerObject</a> este timpul (în milisecunde) după care se va livra primul semnal de timer. </div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Folosiți un handler APC pentru tratarea timer-ului și afișarea mesajului.</div>
</li>
<li class="level2"><div class="li"> <strong>Hints</strong>: </div>
<ul>
<li class="level3"><div class="li"> Folosiți exemplul de utilizare a timer-elor cu APC-uri din <a href="http://msdn.microsoft.com/en-us/library/ms686898(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686898(VS.85).aspx" rel="nofollow">documentația MSDN</a>.</div>
</li>
<li class="level3"><div class="li"> Ignorați warning-urile de compilare. </div>
</li>
<li class="level3"><div class="li"> Completați funcțiile din fișierul sursă.</div>
</li>
<li class="level3"><div class="li"> Folosiți <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/ctime.3.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man3/ctime.3.html" rel="nofollow">ctime</a> și <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/time.2.html" class="urlextern" title="http://www.kernel.org/doc/man-pages/online/pages/man2/time.2.html" rel="nofollow">time</a> pentru afișarea timpului curent.</div>
<ul>
<li class="level4"><div class="li"> ctime adaugă un caracter new-line (<code>\n</code>) la sfârșitul șirului întors. </div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Folosiți <a href="http://msdn.microsoft.com/en-us/library/ms686307(VS.85).aspx" class="urlextern" title="http://msdn.microsoft.com/en-us/library/ms686307(VS.85).aspx" rel="nofollow">SleepEx</a> și argumentele <code>INFINITE</code>, pentru a aștepta nedefinit, și <code>TRUE</code>, pentru a forța intrarea procesului într-o stare <strong>alertabilă</strong> (care să declanșeze rularea APC-ului).</div>
</li>
<li class="level3"><div class="li"> Urmăriți secțiunea <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#waitable_timer_objects" title="so:laboratoare:laborator-06 ↵" class="wikilink1">Waitable Timer Objects</a>. </div>
</li>
</ul>
</li>
</ul>
</li>
</ol>

</div>

<h2 class="sectionedit21" id="solutii">Soluții</h2>
<div class="level2">

<p>
 <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab06-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab06-sol.zip" rel="nofollow"> Soluții exerciții laborator 6</a>
</p>

</div>

<h2 class="sectionedit22" id="resurse_utile">Resurse utile</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><code>TLPI</code> - Chapter 22: Signals - Advanced features</div>
</li>
<li class="level1"><div class="li"><code>TLPI</code> - Chapter 23: Timers and Sleeping </div>
</li>
<li class="level1"><div class="li"><code>WSP</code>  - Chapter 14: Asynchronous IO - Waitable Timers</div>
</li>
</ul>

</div>

        </div>
        <div class="right_sidebar">
          <form action="http://ocw.cs.pub.ro/courses/start" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search"><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]"><input type="submit" value="Search" class="button" title="Search"><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#laborator_06_-_semnale">Laborator 06 - Semnale</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#materiale_ajutatoare">Materiale ajutătoare</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#nice_to_read">Nice to read</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#semnale_in_linux">Semnale în Linux</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#generarea_semnalelor">Generarea semnalelor</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#transmiterea_si_primirea_semnalelor">Transmiterea și primirea semnalelor</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#tipuri_standard_de_semnale">Tipuri standard de semnale</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#mesaje_pentru_descrierea_semnalelor">Mesaje pentru descrierea semnalelor</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#masti_de_semnale_blocarea_semnalelor">Măști de semnale. Blocarea semnalelor</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#tratarea_semnalelor">Tratarea semnalelor</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#structura_siginfo_t">Structura siginfo_t</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#semnalarea_proceselor">Semnalarea proceselor</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#asteptarea_unui_semnal">Așteptarea unui semnal</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#considerente_privind_utilizarea_unui_handler_de_semnal">Considerente privind utilizarea unui handler de semnal</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#timere_in_linux">Timere în Linux</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#timere_sub_windows">Timere sub Windows</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#waitable_timer_objects">Waitable Timer Objects</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#exercitii">Exerciții</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#linux">Linux</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#bonus_-_linux">BONUS - Linux</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#bonus_-_windows">BONUS - Windows</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#solutii">Soluții</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#resurse_utile">Resurse utile</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
<div class="namespace_sidebar sidebar_box">



<h1 class="sectionedit23" id="informatii_generale_so">Informații generale SO</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_172087832651b89b52b968b',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_172087832651b89b52b968b" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/documentatie" class="wikilink1" title="so:info:documentatie">Documentație și alte resurse</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/feed" class="wikilink1" title="so:info:feed">Feed-uri RSS</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/hall" class="wikilink1" title="so:info:hall">Hall of SO</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/lista-discutii" class="wikilink1" title="so:info:lista-discutii">Listă de discuții</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/mv" class="wikilink1" title="so:info:mv">Mașini virtuale</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/trimitere-teme" class="wikilink1" title="so:info:trimitere-teme">Trimitere teme</a></div></li>
</ul>
</div>

</div>
<!-- EDIT23 SECTION "Informații generale SO" [12-175] -->
<h1 class="sectionedit24" id="informatii_so_2012-2013">Informații SO 2012-2013</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_72400001351b89b52bbacd',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_72400001351b89b52bbacd" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare" class="indexmenu_idx_head">Reguli generale și notare</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare/reguli-notare-ca-cc" class="wikilink1" title="so:2012-2013:notare:reguli-notare-ca-cc">Notare CA/CC</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare/reguli-notare-cb" class="wikilink1" title="so:2012-2013:notare:reguli-notare-cb">Notare CB</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/anunturi" class="wikilink1" title="so:2012-2013:anunturi">Anunțuri</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/calendar" class="wikilink1" title="so:2012-2013:calendar">Calendar</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/catalog" class="wikilink1" title="so:2012-2013:catalog">Catalog</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen" class="wikilink1" title="so:2012-2013:examen">Examen</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/need-to-know" class="wikilink1" title="so:2012-2013:need-to-know">SO Need to Know</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/orar" class="wikilink1" title="so:2012-2013:orar">Orar și împărțire pe semigrupe</a></div></li>
</ul>
</div>

</div>
<!-- EDIT24 SECTION "Informații SO 2012-2013" [176-248] -->
<h1 class="sectionedit25" id="laboratoare">Laboratoare</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_15476310551b89b52c0b48',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_15476310551b89b52c0b48" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse" class="indexmenu_idx_head">Resurse</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/c_tips" class="wikilink1" title="so:laboratoare:resurse:c_tips">C/SO Tips</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/die" class="wikilink1" title="so:laboratoare:resurse:die">Macro-ul DIE</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/gdb" class="wikilink1" title="so:laboratoare:resurse:gdb">GDB</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/home" class="wikilink1" title="so:laboratoare:resurse:home">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/injections" class="wikilink1" title="so:laboratoare:resurse:injections">Function Hooking and Windows Dll Injection</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/oprofile" class="wikilink1" title="so:laboratoare:resurse:oprofile">Oprofile</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/recapitulare" class="wikilink1" title="so:laboratoare:resurse:recapitulare">Recapitulare</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/threaduri_extra" class="wikilink1" title="so:laboratoare:resurse:threaduri_extra">Thread-uri - Extra</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/vs_tips" class="wikilink1" title="so:laboratoare:resurse:vs_tips">Visual Studio Tips and Tricks</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/windows-video" class="wikilink1" title="so:laboratoare:resurse:windows-video">windows-video</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-01" class="wikilink1" title="so:laboratoare:laborator-01">Laborator 01 - Introducere</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-02" class="wikilink1" title="so:laboratoare:laborator-02">Laborator 02 - Operații I/O simple</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-03" class="wikilink1" title="so:laboratoare:laborator-03">Laborator 03 - Procese</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-04" class="wikilink1" title="so:laboratoare:laborator-04">Laborator 04 - Gestiunea memoriei</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05" class="wikilink1" title="so:laboratoare:laborator-05">Laborator 05 - IPC</a></div></li>
<li class="level1"><div class="li"><span class="curid"><a href="./Laborator 06 - Semnale [CS Open CourseWare]_files/Laborator 06 - Semnale [CS Open CourseWare].htm" class="wikilink1" title="so:laboratoare:laborator-06">Laborator 06 - Semnale</a></span></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-07" class="wikilink1" title="so:laboratoare:laborator-07">Laborator 07 - Memoria virtuală</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08" class="wikilink1" title="so:laboratoare:laborator-08">Laborator 08 - Thread-uri Linux</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-09" class="wikilink1" title="so:laboratoare:laborator-09">Laborator 09 - Thread-uri Windows</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-10" class="wikilink1" title="so:laboratoare:laborator-10">Laborator 10 - Operații IO avansate - Windows</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-11" class="wikilink1" title="so:laboratoare:laborator-11">Laborator 11 - Operații IO avansate - Linux</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-12" class="wikilink1" title="so:laboratoare:laborator-12">Laborator 12 - Profiling</a></div></li>
</ul>
</div>

</div>
<!-- EDIT25 SECTION "Laboratoare" [249-309] -->
<h1 class="sectionedit26" id="cursuri">Cursuri</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_77833137251b89b52c7b40',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_77833137251b89b52c7b40" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-01" class="indexmenu_idx_head">Curs 01 - Introducere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-02" class="indexmenu_idx_head">Curs 02 - Sistemul de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-03" class="indexmenu_idx_head">Curs 03 - Procese</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-04" class="indexmenu_idx_head">Curs 04 - Planificarea execuției</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-05" class="indexmenu_idx_head">Curs 05 - Sincronizarea proceselor</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-06" class="indexmenu_idx_head">Curs 06 - Gestiunea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-07" class="indexmenu_idx_head">Curs 07 - Memoria virtuală</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-08" class="indexmenu_idx_head">Curs 08 - Fire de execuție</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-09" class="indexmenu_idx_head">Curs 09 - Dispozitive de intrare/ieșire</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-10" class="indexmenu_idx_head">Curs 10 - Implementarea sistemelor de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-11" class="indexmenu_idx_head">Curs 11 - Virtualizare</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-12" class="indexmenu_idx_head">Curs 12 - Securitatea sistemelor de operare</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-13" class="indexmenu_idx_head">Curs 13 - Android</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/quiz?idx=so:cursuri:quiz" class="indexmenu_idx">quiz</a></div></li>
</ul>
</div>

</div>
<!-- EDIT26 SECTION "Cursuri" [310-362] -->
<h1 class="sectionedit27" id="teme">Teme</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_161011538951b89b52c92f0',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_161011538951b89b52c92f0" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-asist" class="indexmenu_idx_head">Tema Asistenți - Guardian process</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/echipe" class="wikilink1" title="so:teme:echipe">Echipe tema 5</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/general" class="wikilink1" title="so:teme:general">Indicații generale teme</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-0" class="wikilink1" title="so:teme:tema-0">Tema 0 HashTable</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-1" class="wikilink1" title="so:teme:tema-1">Tema 1 Mini-shell</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-2" class="wikilink1" title="so:teme:tema-2">Tema 2 MPI</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-3" class="wikilink1" title="so:teme:tema-3">Tema 3 Memorie virtuală</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-4" class="wikilink1" title="so:teme:tema-4">Tema 4 Planificator de threaduri</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-5" class="wikilink1" title="so:teme:tema-5">Tema 5 Server web asincron</a></div></li>
</ul>
</div>

</div>
<!-- EDIT27 SECTION "Teme" [363-] -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          so/laboratoare/laborator-06.txt · Last modified: 2013/04/02 08:50 by larisa.grigore          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
        <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06?do=revisions" class="action revs" accesskey="o" rel="nofollow" title="Old revisions [O]">Old revisions</a>      </div>
      <div class="bar-right">
        <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06?do=media" class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06#dokuwiki__top" class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="./Laborator 06 - Semnale [CS Open CourseWare]_files/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported"></a></div>
  <a target="_blank" href="http://www.chimeric.de/" title="www.chimeric.de"><img src="./Laborator 06 - Semnale [CS Open CourseWare]_files/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0"></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="./Laborator 06 - Semnale [CS Open CourseWare]_files/button-css.png" width="80" height="15" alt="Valid CSS" border="0"></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="./Laborator 06 - Semnale [CS Open CourseWare]_files/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0"></a>

  <a target="_blank" href="http://www.firefox-browser.de/" title="do yourself a favour and use a real browser - get firefox"><img src="./Laborator 06 - Semnale [CS Open CourseWare]_files/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0"></a>
  
  <a target="_blank" href="http://ocw.cs.pub.ro/courses/feed.php" title="Recent changes RSS feed"><img src="./Laborator 06 - Semnale [CS Open CourseWare]_files/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0"></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="./Laborator 06 - Semnale [CS Open CourseWare]_files/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0"></a>
</div>

  </div>
</div>

<div class="no"><img src="./Laborator 06 - Semnale [CS Open CourseWare]_files/indexer.php" width="2" height="1" alt=""></div>


</body></html>