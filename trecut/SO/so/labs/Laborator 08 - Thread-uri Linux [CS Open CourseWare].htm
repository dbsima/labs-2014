<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0056)http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>
    Laborator 08 - Thread-uri Linux    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki">
<meta name="robots" content="index,follow">
<meta name="date" content="2013-04-20T22:39:29+0300">
<meta name="keywords" content="so,laboratoare,laborator-08">
<link rel="search" type="application/opensearchdescription+xml" href="http://ocw.cs.pub.ro/courses/lib/exe/opensearch.php" title="CS Open CourseWare">
<link rel="start" href="http://ocw.cs.pub.ro/courses/">
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="http://ocw.cs.pub.ro/courses/feed.php">
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://ocw.cs.pub.ro/courses/feed.php?mode=list&ns=so:laboratoare">
<link rel="alternate" type="text/html" title="Plain HTML" href="http://ocw.cs.pub.ro/courses/_export/xhtml/so/laboratoare/laborator-08">
<link rel="canonical" href="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/Laborator 08 - Thread-uri Linux [CS Open CourseWare].htm">
<link rel="stylesheet" type="text/css" href="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/css.php">
<script type="text/javascript">/*<![CDATA[*/var NS='so:laboratoare';var JSINFO = {"id":"so:laboratoare:laborator-08","namespace":"so:laboratoare"};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/js.php"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script><script src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/menu.js"></script>
<script type="text/javascript" charset="utf-8" src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/indexmenu.js"></script>
<script type="text/javascript" charset="utf-8">/*<![CDATA[*/var indexmenu_ID='so/laboratoare/laborator-08'
/*!]]>*/</script>

  <link rel="shortcut icon" href="http://ocw.cs.pub.ro/courses/lib/tpl/arctic/images/favicon.ico">

  
<script src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/nojsindex.js" type="text/javascript" charset="utf-8"></script></head>
<body>
<div id="wrapper" class="show">
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="http://ocw.cs.pub.ro/courses/so/"><img height="70" src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/sigla_so.png"> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="http://ocw.cs.pub.ro/courses/systems/"><img height="70" src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/systems.png" name="dokuwiki__top"></a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08?do=login&sectok=86b5e794b6fc7ff30ead55e0316f8781" class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h1 class="sectionedit1" id="laborator_08_-_thread-uri_linux">Laborator 08 - Thread-uri Linux</h1>
<div class="level1">

</div>

<h2 class="sectionedit2" id="materiale_ajutatoare">Materiale ajutătoare</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab08-slides.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab08-slides.pdf" rel="nofollow"> lab08-slides.pdf</a></div>
</li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/so/res/laboratoare/lab08-refcard.pdf" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab08-refcard.pdf" rel="nofollow"> lab08-refcard.pdf</a></div>
</li>
</ul>

</div>

<h3 class="sectionedit3" id="nice_to_read">Nice to read</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> TLPI - Chapter 29, Threads: Introduction</div>
</li>
<li class="level1"><div class="li"> TLPI - Chapter 30, Threads: Thread Synchronization</div>
</li>
<li class="level1"><div class="li"> TLPI - Chapter 31, Threads: Thread Safety and Per-Thread Storage</div>
</li>
</ul>

</div>

<h2 class="sectionedit4" id="prezentare_teoretica">Prezentare teoretică</h2>
<div class="level2">

<p>
În laboratoarele anterioare a fost prezentat conceptul de <strong>proces</strong>, acesta fiind unitatea elementară de alocare a resurselor utilizatorilor. În cadrul acestui laborator este prezentat conceptul de <strong>fir de execuție</strong> (sau <strong>thread</strong>), acesta fiind unitatea elementară de planificare într-un sistem. Ca și procesele, firele de execuție reprezintă un mecanism prin care un calculator poate sǎ ruleze mai multe task-uri simultan.
</p>

<p>
Un fir de execuție există în cadrul unui proces, și reprezintă o unitate de execuție mai fină decât acesta. În momentul în care un proces este creat, în cadrul lui există un singur fir de execuție, care execută programul secvențial. Acest fir poate la rândul lui sǎ creeze alte fire de execuție; aceste fire vor rula porțiuni ale binarului asociat cu procesul curent, posibil aceleași cu firul inițial (care le-a creat).
</p>

</div>

<h3 class="sectionedit5" id="diferente_dintre_fire_de_executie_si_procese">Diferențe dintre fire de execuție și procese</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li">procesele nu partajează resurse între ele (decât dacă programatorul folosește un mecanism special pentru asta - vezi IPC), pe când firele de execuție partajează în mod implicit majoritatea resurselor unui proces. Modificarea unei astfel de resurse dintr-un fir este vizibilă instantaneu și din celelalte fire:</div>
<ul>
<li class="level2"><div class="li">segmentele de memorie precum <code>.heap</code>, <code>.data</code> și <code>.bss</code> (deci și variabilele stocate în ele)</div>
</li>
<li class="level2"><div class="li">descriptorii de fișiere (așadar, închiderea unui fișier este vizibilă imediat pentru toate firele de execuție), indiferent de tipul fișierului:</div>
<ul>
<li class="level3"><div class="li">sockeți</div>
</li>
<li class="level3"><div class="li">fișiere normale</div>
</li>
<li class="level3"><div class="li">pipe-uri</div>
</li>
<li class="level3"><div class="li">fișiere ce reprezintă dispozitive hardware (de ex. <code>/dev/sda1</code>).</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li">fiecare fir are un context de execuție propriu, format din:</div>
<ul>
<li class="level2"><div class="li">stivă</div>
</li>
<li class="level2"><div class="li">set de regiștri (deci și un contor de program - registrul <code>(E)IP</code>)</div>
</li>
</ul>
</li>
</ul>

<p>
Procesele sunt folosite de SO pentru a grupa și aloca resurse, iar firele de execuție pentru a planifica execuția de cod care accesează (în mod partajat) aceste resurse.
</p>

</div>

<h3 class="sectionedit6" id="avantajele_firelor_de_executie">Avantajele firelor de execuție</h3>
<div class="level3">

<p>
Deoarece toate firele de execuție ale unui proces folosesc spațiul de adrese al procesului de care aparțin, folosirea lor are o serie de avantaje:
</p>
<ul>
<li class="level1"><div class="li">crearea/distrugerea unui fir de execuție durează mai puțin decât crearea/distrugerea unui proces</div>
</li>
<li class="level1"><div class="li">durata context switch-ului între firele de execuție aceluiași proces este foarte mică, întrucât nu e necesar să se “comute” și spațiul de adrese (pentru mai multe informații, căutați „TLB flush”)</div>
</li>
<li class="level1"><div class="li">comunicarea între fire de execuție are un overhead mai mic (realizată prin modificarea unor zone de memorie din spațiul comun de adrese)</div>
</li>
</ul>

<p>
Firele de execuție se pot dovedi utile în multe situații, de exemplu, pentru a îmbunătăți timpul de răspuns al aplicațiilor cu interfețe grafice (<abbr title="Graphical User Interface">GUI</abbr>), unde prelucrările CPU-intensive se fac de obicei într-un fir de execuție diferit de cel care afișează interfața. 
</p>

<p>
De asemenea, ele simplifică structura unui program și conduc la utilizarea unui număr mai mic de resurse (pentru că nu mai este nevoie de diversele forme de IPC pentru a comunica).
</p>

</div>

<h3 class="sectionedit7" id="tipuri_de_fire_de_executie">Tipuri de fire de execuție</h3>
<div class="level3">

<p>
Din punctul de vedere al implementării, există 3 categorii de fire de execuție:
</p>
<ul>
<li class="level1"><div class="li">Kernel Level Threads (KLT)</div>
</li>
<li class="level1"><div class="li">User Level Threads (ULT)</div>
</li>
<li class="level1"><div class="li">Fire de execuție hibride</div>
</li>
</ul>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Click to display ⇲
</p>
</div><div class="hiddenBody" style="display: none;">
<p>
<strong> Kernel Level Threads </strong>
</p>

<p>
Managementul și planificarea firelor de execuție sunt realizate în kernel; programele creează/distrug fire de execuție prin apeluri de sistem. Kernel-ul menține informații de context, atât pentru procese, cât și pentru firele de execuție din cadrul proceselor, iar planificarea execuției se face la nivel de fir.
</p>

<p>
<em class="u">Avantaje</em> :
</p>
<ul>
<li class="level1"><div class="li">dacă avem mai multe procesoare putem lansa în execuție simultană mai multe fire de execuție ale aceluiași proces;</div>
</li>
<li class="level1"><div class="li">blocarea unui fir nu înseamnă blocarea întregului proces;</div>
</li>
<li class="level1"><div class="li">putem scrie cod în kernel care să se bazeze pe fire de execuție.</div>
</li>
</ul>

<p>
<em class="u">Dezavantaje</em> :
</p>
<ul>
<li class="level1"><div class="li">comutarea contextului este efectuată de kernel (cu o viteză de comutare mai mică):</div>
<ul>
<li class="level2"><div class="li">se trece dintr-un fir de execuție în kernel</div>
</li>
<li class="level2"><div class="li">kernelul întoarce controlul unui alt fir de execuție.</div>
</li>
</ul>
</li>
</ul>

<p>
<strong> User Level Threads </strong>
</p>

<p>
Kernel-ul nu este conștient de existența firelor de execuție, iar managementul acestora este realizat de procesul în care ele există (implementarea managementului firelor de execuție este realizată de obicei în biblioteci). Schimbarea contextului nu necesită intervenția kernel-ului, iar algoritmul de planificare depinde de aplicație.
</p>

<p>
<em class="u">Avantaje</em> :
</p>
<ul>
<li class="level1"><div class="li">schimbarea de context nu implică kernelul ⇒ comutare rapidă</div>
</li>
<li class="level1"><div class="li">planificarea poate fi aleasă de aplicație; aplicația poate folosi acea planificare care favorizează creșterea performanțelor </div>
</li>
<li class="level1"><div class="li">firele de execuție pot rula pe orice SO, inclusiv pe SO care nu suportă fire de execuție la nivel kernel (au nevoie doar de biblioteca care implementează firele de execuție la nivel utilizator).</div>
</li>
</ul>

<p>
<em class="u">Dezavantaje</em> :
</p>
<ul>
<li class="level1"><div class="li">kernel-ul nu știe de fire de execuție ⇒ dacă un fir de execuție face un apel blocant toate firele de execuție planificate de aplicație vor fi blocate. Acest lucru poate fi un impediment întrucât majoritatea apelurilor de sistem sunt blocante. O soluție este utilizarea unor variante non-blocante pentru apelurile de sistem.</div>
</li>
<li class="level1"><div class="li">nu se pot utiliza la maximum resursele hardware: kernelul planifică firele de execuție de care știe, câte unul pe fiecare procesor. Kernelul nu este conștient de existența firelor de execuție user-level ⇒ el va vedea un singur fir de execuție ⇒ va planifica procesul respectiv pe maximum un procesor, chiar dacă aplicația ar avea mai multe fire de execuție planificabile în același timp.</div>
</li>
</ul>

<p>
<strong> Fire de execuție hibride </strong>
</p>

<p>
Aceste fire încearcă să combine avantajele firelor de execuție user-level cu cele ale firelor de execuție kernel-level. O modalitate de a face acest lucru este de a utiliza fire kernel-level pe care să fie multiplexate fire user-level. KLT sunt unitățile elementare care pot fi distribuite pe procesoare. De regulă, crearea firelor de execuție se face în user space și tot aici se face aproape toată planificarea și sincronizarea. Kernel-ul știe doar de KLT-urile pe care sunt multiplexate ULT, și doar pe acestea le planifică. Programatorul poate schimba eventual numărul de KLT alocate unui proces.
</p>
</div></div>
</div>

<h2 class="sectionedit8" id="suport_posix">Suport POSIX</h2>
<div class="level2">

<p>
În ceea ce privește firele de execuție, POSIX nu specifică dacă acestea trebuie implementate în user-space sau kernel-space. Linux le implementează în kernel-space, dar nu diferențiază firele de execuție de procese decât prin faptul că firele de execuție partajează spațiul de adresă (atât firele de execuție, cât și procesele, sunt un caz particular de “task”). Pentru folosirea firelor de execuție în Linux trebuie să includem header-ul <code>pthread.h</code> (unde se găsesc declarațiile funcțiilor și tipurilor de date necesare) și să utilizăm biblioteca <code>libpthread</code>.
</p>

</div>

<h3 class="sectionedit9" id="crearea_firelor_de_executie">Crearea firelor de execuție</h3>
<div class="level3">

<p>
Un fir de execuție este creat folosind <a href="http://linux.die.net/man/3/pthread_create" class="urlextern" title="http://linux.die.net/man/3/pthread_create" rel="nofollow">pthread_create</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_create<span class="br0">(</span>pthread_t <span class="sy0">*</span>tid<span class="sy0">,</span> <span class="kw4">const</span> pthread_attr_t <span class="sy0">*</span>tattr<span class="sy0">,</span> 
                   <span class="kw4">void</span><span class="sy0">*</span><span class="br0">(</span><span class="sy0">*</span>start_routine<span class="br0">)</span><span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span><span class="br0">)</span><span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>arg<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Noul fir creat va avea identificatorul <code>tid</code> și va rula concurent cu firul de execuție din care a fost creat. Acesta va executa codul specificat de funcția <code>start_routine</code> căreia i se va pasa argumentul <code>arg</code>. Dacă funcția de executat are nevoie de mai mulți parametri, aceștia pot fi agregați într-o structură, în câmpul <code>arg</code> punându-se un pointer către acea structură.
</p>

<p>
Prin parametrul <code>tattr</code> se stabilesc atributele noului fir de execuție. Dacă transmitem valoarea <code>NULL</code> firul de execuție va fi creat cu atributele implicite.
</p>

<p>
Pentru a determina identificatorul firului de execuție curent se poate folosi funcția <a href="http://linux.die.net/man/3/pthread_self" class="urlextern" title="http://linux.die.net/man/3/pthread_self" rel="nofollow">pthread_self</a>:
</p>
<pre class="code c">pthread_t pthread_self<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h3 class="sectionedit10" id="asteptarea_firelor_de_executie">Așteptarea firelor de execuție</h3>
<div class="level3">

<p>
Firele de execuție se așteaptă folosind funcția <a href="http://linux.die.net/man/3/pthread_join" class="urlextern" title="http://linux.die.net/man/3/pthread_join" rel="nofollow">pthread_join</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_join<span class="br0">(</span>pthread_t th<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">**</span>thread_return<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Primul parametru specifică identificatorul firului de execuție așteptat, iar al doilea parametru specifică unde se va plasa valoarea întoarsă de funcția copil (printr-un <a href="http://linux.die.net/man/3/pthread_exit" class="urlextern" title="http://linux.die.net/man/3/pthread_exit" rel="nofollow">pthread_exit</a> sau printr-un <code>return</code> din rutina utilizată la <a href="http://linux.die.net/man/3/pthread_create" class="urlextern" title="http://linux.die.net/man/3/pthread_create" rel="nofollow">pthread_create</a>).
</p>

<p>
Firele de execuție se împart în două categorii: <em class="u"><em>unificabile</em></em> și <em class="u"><em>detașabile</em></em>. Mai multe detalii: 
</p>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Click to display ⇲
</p>
</div><div class="hiddenBody" style="display: none;"><ul>
<li class="level1"><div class="li"><em>unificabile</em> :</div>
<ul>
<li class="level2"><div class="li">permit unificarea cu alte fire de execuție care apelează <a href="http://linux.die.net/man/3/pthread_join" class="urlextern" title="http://linux.die.net/man/3/pthread_join" rel="nofollow">pthread_join</a>.</div>
</li>
<li class="level2"><div class="li">resursele ocupate de fir nu sunt eliberate imediat după terminarea firului, ci sunt păstrate până când un alt fir de execuție va executa <a href="http://linux.die.net/man/3/pthread_join" class="urlextern" title="http://linux.die.net/man/3/pthread_join" rel="nofollow">pthread_join</a> (analog proceselor <em>zombie</em>)</div>
</li>
<li class="level2"><div class="li">implicit firele de execuție sunt unificabile</div>
</li>
</ul>
</li>
</ul>
<ul>
<li class="level1"><div class="li"><em>detașabile</em></div>
<ul>
<li class="level2"><div class="li">un fir de execuție este detașabil dacă :</div>
<ul>
<li class="level3"><div class="li">a fost creat detașabil.</div>
</li>
<li class="level3"><div class="li">i s-a schimbat acest atribut în timpul execuției prin apelul <a href="http://linux.die.net/man/3/pthread_detach" class="urlextern" title="http://linux.die.net/man/3/pthread_detach" rel="nofollow">pthread_detach</a>.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li">nu se poate executa un <a href="http://linux.die.net/man/3/pthread_join" class="urlextern" title="http://linux.die.net/man/3/pthread_join" rel="nofollow">pthread_join</a> pe ele</div>
</li>
<li class="level2"><div class="li">vor elibera resursele imediat ce se vor termina (analog cu ignorarea semnalului SIGCHLD în părinte la încheierea execuției proceselor copil)</div>
</li>
</ul>
</li>
</ul>
</div></div>
</div>

<h3 class="sectionedit11" id="terminarea_firelor_de_executie">Terminarea firelor de execuție</h3>
<div class="level3">

<p>
Un fir de execuție își încheie execuția:
</p>
<ul>
<li class="level1"><div class="li">la un apel al funcției <a href="http://linux.die.net/man/3/pthread_exit" class="urlextern" title="http://linux.die.net/man/3/pthread_exit" rel="nofollow">pthread_exit</a>: <pre class="code c"><span class="kw4">void</span> pthread_exit<span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span>retval<span class="br0">)</span><span class="sy0">;</span></pre>
</div>
</li>
<li class="level1"><div class="li">în mod automat, la sfârșitul codului firului de execuție.</div>
</li>
</ul>

<p>
Prin parametrul <code>retval</code> se comunică părintelui un mesaj despre modul de terminare al copilului. Această valoare va fi preluată de funcția <a href="http://linux.die.net/man/3/pthread_join" class="urlextern" title="http://linux.die.net/man/3/pthread_join" rel="nofollow">pthread_join</a>.
</p>

<p>
Metodele ca un fir de execuție să termine un alt fir sunt:
</p>
<ul>
<li class="level1"><div class="li">stabilirea unui protocol de terminare (spre exemplu, firul <strong>master</strong> setează o variabilă globală, pe care firul <strong>slave</strong> o verifică periodic).</div>
</li>
<li class="level1"><div class="li">mecanismul de “<strong>thread cancellation</strong>”, pus la dispozitie de <code>libpthread</code>. Totuși, această metodă nu este recomandată, pentru că este greoaie, și pune probleme foarte delicate la clean-up. Pentru mai multe detalii: <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/threaduri_extra" class="wikilink1" title="so:laboratoare:resurse:threaduri_extra">Terminarea thread-urilor</a></div>
</li>
</ul>

</div>

<h3 class="sectionedit12" id="thread_specific_data_tsd">Thread Specific Data (TSD)</h3>
<div class="level3">

<p>
Uneori este util ca o variabilă să fie specifică unui fir de execuție (invizibilă pentru celelalte fire). Linux permite memorarea de perechi (cheie, valoare) într-o zonă special desemnată din stiva fiecărui fir de execuție al procesului curent. Cheia are același rol pe care o are numele unei variabile: desemnează locația de memorie la care se află valoarea.
</p>

<p>
Fiecare fir de execuție va avea propria copie a unei “variabile” corespunzătoare unei chei <code>k</code>, pe care o poate modifica, fără ca acest lucru să fie observat de celelalte fire, sau să necesite sincronizare. De aceea, TSD este folosită uneori pentru a optimiza operațiile care necesită multă sincronizare între fire de execuție: fiecare fir calculează informația specifică, și există un singur pas de sincronizare la sfârșit, necesar pentru reunirea rezultatelor tuturor firelor de execuție.
</p>

<p>
Cheile sunt de tipul <code>pthread_key_t</code>, iar valorile asociate cu ele, de tipul generic <code>void *</code> (pointeri către locația de pe stivă unde este memorată variabila respectivă). Descriem în continuare operațiile disponibile cu variabilele din TSD:
</p>

</div>

<h4 id="crearea_si_stergerea_unei_variabile">Crearea și ștergerea unei variabile</h4>
<div class="level4">

<p>
O variabilă se creează folosind <a href="http://linux.die.net/man/3/pthread_key_create" class="urlextern" title="http://linux.die.net/man/3/pthread_key_create" rel="nofollow">pthread_key_create</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_key_create<span class="br0">(</span>pthread_key_t <span class="sy0">*</span>key<span class="sy0">,</span> <span class="kw4">void</span> <span class="br0">(</span><span class="sy0">*</span>destr_function<span class="br0">)</span> <span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Al doilea parametru reprezintă o funcție de cleanup. Acesta poate avea una din valorile:
</p>
<ul>
<li class="level1"><div class="li"><code>NULL</code> și este ignorat</div>
</li>
<li class="level1"><div class="li">pointer către o funcție de cleanup care se execută la terminarea firului de execuție</div>
</li>
</ul>

<p>
Pentru ștergerea unei variabile se apelează <a href="http://linux.die.net/man/3/pthread_key_delete" class="urlextern" title="http://linux.die.net/man/3/pthread_key_delete" rel="nofollow">pthread_key_delete</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_key_delete<span class="br0">(</span>pthread_key_t key<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Funcția nu apelează funcția de cleanup asociată variabilei.
</p>

</div>

<h4 id="modificarea_si_citirea_unei_variabile">Modificarea și citirea unei variabile</h4>
<div class="level4">

<p>
După crearea cheii, fiecare fir de execuție poate modifica propria copie a variabilei asociate folosind funcția <a href="http://linux.die.net/man/3/pthread_setspecific" class="urlextern" title="http://linux.die.net/man/3/pthread_setspecific" rel="nofollow">pthread_setspecific</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_setspecific<span class="br0">(</span>pthread_key_t key<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">void</span> <span class="sy0">*</span>pointer<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Pentru a determina valoarea unei variabile de tip TSD se folosește funcția <a href="http://linux.die.net/man/3/pthread_getspecific" class="urlextern" title="http://linux.die.net/man/3/pthread_getspecific" rel="nofollow">pthread_getspecific</a>:
</p>
<pre class="code c"><span class="kw4">void</span><span class="sy0">*</span> pthread_getspecific<span class="br0">(</span>pthread_key_t key<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h3 class="sectionedit13" id="functii_pentru_cleanup">Funcții pentru cleanup</h3>
<div class="level3">

<p>
Funcțiile de cleanup asociate TSD-urilor pot fi foarte utile pentru a asigura faptul că resursele sunt eliberate atunci când un fir se termină singur sau este terminat de către un alt fir. Uneori poate fi util să se poată specifica astfel de funcții fără a crea neapărat un TSD. Pentru acest scop există funcțiile de cleanup.
</p>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Click to display ⇲
</p>
</div><div class="hiddenBody" style="display: none;">
<p>
O astfel de funcție de cleanup este o funcție care este apelată când un fir de execuție se termină. Ea primește un singur parametru de tipul <code>void *</code> care este specificat la înregistrarea funcției.
</p>

<p>
O funcție de cleanup este folosită pentru a elibera o resursă numai în cazul în care un fir de execuție apelează <a href="http://linux.die.net/man/3/pthread_exit" class="urlextern" title="http://linux.die.net/man/3/pthread_exit" rel="nofollow">pthread_exit</a> sau este terminat de un alt fir folosind <a href="http://linux.die.net/man/3/pthread_cancel" class="urlextern" title="http://linux.die.net/man/3/pthread_cancel" rel="nofollow">pthread_cancel</a>. În circumstanțe normale, atunci când un fir nu se termină în mod forțat, resursa trebuie eliberată explicit, iar funcția de cleanup nu trebuie să fie apelată.
</p>

<p>
Pentru a înregistra o astfel de funcție de cleanup se folosește :
</p>
<pre class="code c"><span class="kw4">void</span> pthread_cleanup_push<span class="br0">(</span><span class="kw4">void</span> <span class="br0">(</span><span class="sy0">*</span>routine<span class="br0">)</span> <span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span><span class="br0">)</span><span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>arg<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Aceasta funcție primește ca parametri un pointer la funcția care este înregistrată și valoarea argumentului care va fi transmis acesteia. Funcția <code>routine</code> va fi apelată cu argumentul <code>arg</code> atunci când firul este terminat forțat. Daca sunt înregistrate mai multe funcții de cleanup, ele vor fi apelate în ordine LIFO (cea mai recent instalată va fi prima apelată).
</p>

<p>
Pentru fiecare apel <a href="http://linux.die.net/man/3/pthread_cleanup_push" class="urlextern" title="http://linux.die.net/man/3/pthread_cleanup_push" rel="nofollow">pthread_cleanup_push</a> trebuie să existe și apelul corespunzător <a href="http://linux.die.net/man/3/pthread_cleanup_pop" class="urlextern" title="http://linux.die.net/man/3/pthread_cleanup_pop" rel="nofollow">pthread_cleanup_pop</a> care deînregistrează o funcție de cleanup:
</p>
<pre class="code c"><span class="kw4">void</span> pthread_cleanup_pop<span class="br0">(</span><span class="kw4">int</span> execute<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Această funcție va deînregistra cea mai recent instalată funcție de cleanup, și dacă parametrul <code>execute</code> este nenul o va și executa.
</p>

<p>
<strong>Atentie!</strong> Un apel <a href="http://linux.die.net/man/3/pthread_cleanup_push" class="urlextern" title="http://linux.die.net/man/3/pthread_cleanup_push" rel="nofollow">pthread_cleanup_push</a> trebuie să aibă un apel corespunzător <a href="http://linux.die.net/man/3/pthread_cleanup_pop" class="urlextern" title="http://linux.die.net/man/3/pthread_cleanup_pop" rel="nofollow">pthread_cleanup_pop</a> în <em class="u">aceeași funcție</em> și la <em class="u">același nivel de imbricare</em>.
</p>

<p>
Un mic exemplu de folosire a funcțiilor de cleanup :
</p>
<dl class="code">
<dt><a href="http://ocw.cs.pub.ro/courses/_export/code/so/laboratoare/laborator-08?codeblock=10" title="Download Snippet" class="mediafile mf_c">th_cleanup.c</a></dt>
<dd><pre class="code c"><span class="kw4">void</span> <span class="sy0">*</span>alocare_buffer<span class="br0">(</span><span class="kw4">int</span> size<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">return</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span class="kw3">malloc</span></a><span class="br0">(</span>size<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> dealocare_buffer<span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span>buffer<span class="br0">)</span>
<span class="br0">{</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span class="kw3">free</span></a><span class="br0">(</span>buffer<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="coMULTI">/* functia apelata de un fir de execuție */</span>
&nbsp;
<span class="kw4">void</span> functie<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">void</span> <span class="sy0">*</span>buffer <span class="sy0">=</span> alocare_buffer<span class="br0">(</span><span class="nu0">512</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* inregistrarea functiei de cleanup */</span>
	pthread_cleanup_push<span class="br0">(</span>dealocare_buffer<span class="sy0">,</span> buffer<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* aici au loc prelucrari, si se poate apela pthread_exit
        sau firul poate fi terminat de un alt fir */</span>
&nbsp;
	<span class="coMULTI">/* deinregistrarea functiei de cleanup si executia ei 
        (parametrul dat este nenul) */</span>
&nbsp;
        pthread_cleanup_pop<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</dd></dl>
</div></div>
</div>

<h3 class="sectionedit14" id="atributele_unui_fir_de_executie">Atributele unui fir de execuție</h3>
<div class="level3">

<p>
Atributele reprezintă o modalitate de specificare a unui comportament diferit de comportamentul implicit. Atunci când un fir de execuție este creat cu <code>pthread_create</code> se poate specifica un atribut pentru respectivul fir de execuție. Atributele implicite sunt suficiente pentru marea majoritate a aplicațiilor. Cu ajutorul unui atribut se pot schimba:
</p>
<ul>
<li class="level1"><div class="li">starea: unificabil sau detașabil</div>
</li>
<li class="level1"><div class="li">politica de alocare a procesorului pentru firul de execuție respectiv (round robin, FIFO, sau system default)</div>
</li>
<li class="level1"><div class="li">prioritatea (cele cu prioritate mai mare vor fi planificate, în medie, mai des)</div>
</li>
<li class="level1"><div class="li">dimensiunea și adresa de start a stivei</div>
</li>
</ul>

<p>
Mai multe detalii puteți găsi în <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/threaduri_extra#lucrul_cu_atributele_unui_thread" class="wikilink1" title="so:laboratoare:resurse:threaduri_extra">secțiunea suplimentară dedicată</a>.
</p>

</div>

<h3 class="sectionedit15" id="cedarea_procesorului">Cedarea procesorului</h3>
<div class="level3">

<p>
Un fir de execuție cedează dreptul de execuție unui alt fir, în urma unuia din următoarele evenimente:
</p>
<ul>
<li class="level1"><div class="li">efectuează un apel blocant (cerere de I/O, sincronizare cu un alt fir de execuție) și kernel-ul decide că este <em>rentabil</em> să facă un context switch</div>
</li>
<li class="level1"><div class="li">i-a expirat cuanta de timp alocată de către kernel</div>
</li>
<li class="level1"><div class="li">cedează voluntar dreptul, folosind funcția <a href="http://linux.die.net/man/2/sched_yield" class="urlextern" title="http://linux.die.net/man/2/sched_yield" rel="nofollow">sched_yield</a>:<pre class="code c"><span class="kw4">int</span> sched_yield<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span><span class="sy0">;</span></pre>
</div>
</li>
</ul>

<p>
Dacă există alte procese interesate de procesor, unul dintre procese va acapara procesorul, iar dacă nu există nici un alt proces în așteptare pentru procesor, firul curent își continuă execuția.
</p>

</div>

<h3 class="sectionedit16" id="alte_operatii">Alte operații</h3>
<div class="level3">

<p>

Dacă dorim să fim siguri că un cod de inițializare se execută o singură dată putem folosi funcția :
</p>
<pre class="code c">pthread_once_t once_control <span class="sy0">=</span> PTHREAD_ONCE_INIT<span class="sy0">;</span>
<span class="kw4">int</span> pthread_once<span class="br0">(</span>pthread_once_t <span class="sy0">*</span>once_control<span class="sy0">,</span> <span class="kw4">void</span> <span class="br0">(</span><span class="sy0">*</span>init_routine<span class="br0">)</span> <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Scopul funcției <code>pthread_once</code> este de a asigura că o bucată de cod (de obicei folosită pentru inițializări) se execută o singură dată. Argumentul <code>once_control</code> este un pointer la o variabilă inițializată cu <code>PTHREAD_ONCE_INIT</code>. Prima oară când această funcție este apelată ea va apela funcția <code>init_routine</code> și va schimba valoarea variabilei <code>once_control</code> pentru a ține minte că inițializarea a avut loc. Următoarele apeluri ale acestei funcții cu același <code>once_control</code> nu vor face nimic.
</p>

<p>
Funcția <code>pthread_once</code> întoarce întotdeauna 0.
</p>

<p>
Pentru a determina dacă doi identificatori se referă la același fir de execuție se poate folosi :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_equal<span class="br0">(</span>pthread_t thread1<span class="sy0">,</span> pthread_t thread2<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Pentru aflarea/modificarea priorităților sunt disponibile următoarele apeluri :
</p>
<pre class="code c"><span class="kw4">int</span> pthread_setschedparam<span class="br0">(</span>pthread_t target_thread<span class="sy0">,</span> <span class="kw4">int</span> policy<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">struct</span> sched_param <span class="sy0">*</span>param<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_getschedparam<span class="br0">(</span>pthread_t target_thread<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>policy<span class="sy0">,</span> <span class="kw4">struct</span> sched_param <span class="sy0">*</span>param<span class="br0">)</span><span class="sy0">;</span></pre>



</div>

<h3 class="sectionedit17" id="compilare">Compilare</h3>
<div class="level3">

<p>
La compilare trebuie specificată și biblioteca <code>libpthread</code> (deci se va folosi argumentul <code>-lpthread</code>).
</p>

<p>
<strong>Atenție!</strong> Nu legați un program single-threaded cu această bibliotecă. Anumite apeluri din bibliotecile standard pot avea implementări mai ineficiente sau mai greu de depanat când se utilizează această bibliotecă.
</p>

</div>

<h3 class="sectionedit18" id="exemplu">Exemplu</h3>
<div class="level3">

<p>
În continuare, este prezentat un exemplu simplu în care sunt create 2 fire de execuție, fiecare afișând un caracter de un anumit număr de ori pe ecran.
</p>
<dl class="code">
<dt><a href="http://ocw.cs.pub.ro/courses/_export/code/so/laboratoare/laborator-08?codeblock=15" title="Download Snippet" class="mediafile mf_c">thread2.c</a></dt>
<dd><pre class="code c"><span class="co2">#include &lt;pthread.h&gt;</span>
<span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="coMULTI">/* parameter structure for every thread */</span>
<span class="kw4">struct</span> parameter <span class="br0">{</span>
	<span class="kw4">char</span> character<span class="sy0">;</span> <span class="coMULTI">/* printed character */</span>
	<span class="kw4">int</span> number<span class="sy0">;</span>     <span class="coMULTI">/* how many times */</span>
<span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* the function performed by every thread */</span>
<span class="kw4">void</span><span class="sy0">*</span> print_character<span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span>params<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> parameter<span class="sy0">*</span> p <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> parameter<span class="sy0">*</span><span class="br0">)</span> params<span class="sy0">;</span>
	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>p<span class="sy0">-&gt;</span>number<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"%c"</span><span class="sy0">,</span> p<span class="sy0">-&gt;</span>character<span class="br0">)</span><span class="sy0">;</span>
	<a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> NULL<span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	pthread_t fir1<span class="sy0">,</span> fir2<span class="sy0">;</span>
	<span class="kw4">struct</span> parameter fir1_args<span class="sy0">,</span> fir2_args<span class="sy0">;</span>
&nbsp;
	<span class="coMULTI">/* create one thread that will print 'x' 11 times */</span>
	fir1_args.<span class="me1">character</span> <span class="sy0">=</span> <span class="st0">'x'</span><span class="sy0">;</span>
	fir1_args.<span class="me1">number</span> <span class="sy0">=</span> <span class="nu0">11</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>pthread_create<span class="br0">(</span><span class="sy0">&amp;</span>fir1<span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="sy0">&amp;</span>print_character<span class="sy0">,</span> <span class="sy0">&amp;</span>fir1_args<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">(</span><span class="st0">"pthread_create"</span><span class="br0">)</span><span class="sy0">;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="coMULTI">/* create one thread that will print 'y' 13 times */</span>
	fir2_args.<span class="me1">character</span> <span class="sy0">=</span> <span class="st0">'y'</span><span class="sy0">;</span>
	fir2_args.<span class="me1">number</span> <span class="sy0">=</span> <span class="nu0">13</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>pthread_create<span class="br0">(</span><span class="sy0">&amp;</span>fir2<span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="sy0">&amp;</span>print_character<span class="sy0">,</span> <span class="sy0">&amp;</span>fir2_args<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">(</span><span class="st0">"pthread_create"</span><span class="br0">)</span><span class="sy0">;</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/exit.html"><span class="kw3">exit</span></a><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
&nbsp;
	<span class="coMULTI">/* wait for completion */</span>
	<span class="kw1">if</span> <span class="br0">(</span>pthread_join<span class="br0">(</span>fir1<span class="sy0">,</span> NULL<span class="br0">)</span><span class="br0">)</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">(</span><span class="st0">"pthread_join"</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>pthread_join<span class="br0">(</span>fir2<span class="sy0">,</span> NULL<span class="br0">)</span><span class="br0">)</span>
		<a href="http://www.opengroup.org/onlinepubs/009695399/functions/perror.html"><span class="kw3">perror</span></a><span class="br0">(</span><span class="st0">"pthread_join"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</dd></dl>

<p>
Comanda utilizată pentru a compila acest exemplu va fi:
</p>
<pre class="code bash"><span class="kw2">gcc</span> <span class="re5">-o</span> exemplu exemplu.c <span class="re5">-lpthread</span></pre>

</div>

<h2 class="sectionedit19" id="sincronizarea_firelor_de_executie">Sincronizarea firelor de execuție</h2>
<div class="level2">

<p>
Pentru sincronizarea firelor de execuție, avem la dispoziție:
</p>
<ul>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#mutex" title="so:laboratoare:laborator-08 ↵" class="wikilink1">mutex</a></div>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#semafor" title="so:laboratoare:laborator-08 ↵" class="wikilink1">semafoare</a></div>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#variabile_conditie" title="so:laboratoare:laborator-08 ↵" class="wikilink1">variabile de condiție</a></div>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#bariera" title="so:laboratoare:laborator-08 ↵" class="wikilink1">bariere</a></div>
</li>
</ul>

</div>

<h2 class="sectionedit20" id="mutex">Mutex</h2>
<div class="level2">

<p>
Mutex-urile (mutual exclusion locks) sunt obiecte de sincronizare utilizate pentru a asigura <strong>accesul exclusiv</strong> într-o secțiune de cod în care se utilizează <strong>date partajate</strong> între două sau mai multe fire de execuție. Un mutex are două stări posibile: <strong>ocupat</strong> și <strong>liber</strong>. Un mutex poate fi ocupat de un <strong>singur fir</strong> de execuție la un moment dat. Atunci când un mutex este ocupat de un fir de execuție, el nu mai poate fi ocupat de niciun alt fir. În acest caz, o cerere de ocupare venită din partea unui alt fir, în general, va <strong>bloca</strong> firul până în momentul în care mutex-ul devine liber.
</p>

</div>

<h3 class="sectionedit21" id="initializareadistrugerea_unui_mutex">Inițializarea/distrugerea unui mutex</h3>
<div class="level3">

<p>
Un mutex poate fi inițializat/distrus în mai multe moduri:
</p>
<ul>
<li class="level1"><div class="li">folosind o <strong>macrodefiniție</strong> <pre class="code c"><span class="co1">// initializare statica a unui mutex, cu atribute implicite</span>
<span class="co1">// NB: mutex-ul nu este eliberat, durata de viata a mutex-ului</span>
<span class="co1">//     este durata de viata a programului.</span>
pthread_mutex_t mutex_static <span class="sy0">=</span> PTHREAD_MUTEX_INITIALIZER<span class="sy0">;</span></pre>
</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">inițializat cu <strong>atribute implicite</strong> (<a href="http://linux.die.net/man/3/pthread_mutex_init" class="urlextern" title="http://linux.die.net/man/3/pthread_mutex_init" rel="nofollow">pthread_mutex_init</a>, <a href="http://linux.die.net/man/3/pthread_mutex_destroy" class="urlextern" title="http://linux.die.net/man/3/pthread_mutex_destroy" rel="nofollow">pthread_mutex_destroy</a>) <pre class="code c"><span class="co1">// semnaturile functiilor de initializare si distrugere de mutex:</span>
<span class="kw4">int</span> pthread_mutex_init   <span class="br0">(</span>pthread_mutex_t <span class="sy0">*</span>mutex<span class="sy0">,</span> <span class="kw4">const</span> pthread_mutexattr_t <span class="sy0">*</span>attr<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_mutex_destroy<span class="br0">(</span>pthread_mutex_t <span class="sy0">*</span>mutex<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> initializare_mutex_cu_atribute_implicite<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    pthread_mutex_t mutex_implicit<span class="sy0">;</span>
    pthread_mutex_init<span class="br0">(</span><span class="sy0">&amp;</span>mutex_implicit<span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// atrr=NULL -&gt; atribute implicite</span>
&nbsp;
    <span class="co1">// ... folosirea mutex-ului ...</span>
&nbsp;
    <span class="co1">// eliberare mutex</span>
    pthread_mutex_destroy<span class="br0">(</span><span class="sy0">&amp;</span>mutex_implicit<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li">inițializare cu <strong>atribute explicite</strong> </div>
</li>
</ul>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Click to display ⇲
</p>
</div><div class="hiddenBody" style="display: none;"><pre class="code c"><span class="co1">// NB: funcția pthread_mutexattr_settype și macro-ul PTHREAD_MUTEX_RECURSIVE </span>
<span class="co1">//     sunt disponibile doar dacă se definește _XOPEN_SOURCE la o valoare &gt;= 500  </span>
<span class="co1">//     **ÎNAINTE** de a include &lt;pthread.h&gt;.  </span>
<span class="co1">//     Pentru mai multe detalii consultați feature_test_macros(7).</span>
&nbsp;
<span class="co2">#define _XOPEN_SOURCE 500</span>
<span class="co2">#include &lt;pthread.h&gt;</span>
&nbsp;
<span class="kw4">void</span> initializare_mutex_recursiv<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// definim atribute, le inițializăm și marcăm tipul ca fiind recursiv.</span>
    pthread_mutexattr_t attr<span class="sy0">;</span>
    pthread_mutexattr_init<span class="br0">(</span><span class="sy0">&amp;</span>attr<span class="br0">)</span><span class="sy0">;</span>
    pthread_mutexattr_settype<span class="br0">(</span><span class="sy0">&amp;</span>attr<span class="sy0">,</span> PTHREAD_MUTEX_RECURSIVE<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// definim un mutex recursiv, îl inițializăm cu atributele definite anterior</span>
    pthread_mutex_t mutex_recursiv<span class="sy0">;</span>
    pthread_mutex_init<span class="br0">(</span><span class="sy0">&amp;</span>mutex_recursiv<span class="sy0">,</span> <span class="sy0">&amp;</span>attr<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// eliberăm resursele atributului după crearea mutex-ului</span>
    pthread_mutexattr_destroy<span class="br0">(</span><span class="sy0">&amp;</span>attr<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// ... folosirea mutex-ului ...</span>
&nbsp;
    <span class="co1">// eliberare mutex</span>
    pthread_mutex_destroy<span class="br0">(</span><span class="sy0">&amp;</span>mutex_recursiv<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
</div></div>
<p>
<strong>Atenție</strong>: Mutex-ul trebuie să fie <strong>liber</strong> pentru a putea fi <strong>distrus</strong>. În caz contrar, funcția va întoarce codul de eroare <code>EBUSY</code>. Întoarcerea valorii <code>0</code> semnifică succesul apelului.
</p>

</div>

<h3 class="sectionedit22" id="tipuri_de_mutex-uri">Tipuri de mutex-uri</h3>
<div class="level3">

<p>
Folosind atributele de inițializare se pot crea mutex-uri cu proprietăți speciale:
</p>
<ul>
<li class="level1"><div class="li">activarea <strong><a href="http://en.wikipedia.org/wiki/Priority_inheritance" class="urlextern" title="http://en.wikipedia.org/wiki/Priority_inheritance" rel="nofollow">moștenirii de prioritate</a></strong> (<em>priority inheritance</em>) pentru a preveni <strong><a href="http://en.wikipedia.org/wiki/Priority_inversion" class="urlextern" title="http://en.wikipedia.org/wiki/Priority_inversion" rel="nofollow">inversiunea de prioritate</a></strong> (<em>priority inversion</em>). Există trei protocoale de moștenire a priorității:</div>
<ul>
<li class="level2"><div class="li"> <code>PTHREAD_PRIO_NONE</code> – <strong>nu</strong> se moștenește prioritatea când deținem mutex-ul creat cu acest atribut</div>
</li>
<li class="level2"><div class="li"> <code>PTHREAD_PRIO_INHERIT</code> – dacă deținem un mutex creat cu acest atribut și dacă există fire de execuție blocate pe acel mutex, se moștenește prioritatea firului de execuție cu <strong>cea mai mare prioritate</strong></div>
</li>
<li class="level2"><div class="li"> <code>PTHREAD_PRIO_PROTECT</code> – dacă firul de execuție curent deține unul sau mai multe mutex-uri, acesta va executa la <strong>maximul priorităților</strong> specificate pentru toate mutex-urile deținute. </div>
</li>
</ul>
</li>
</ul>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Click to display ⇲
</p>
</div><div class="hiddenBody" style="display: none;"><pre class="code c"><span class="co2">#define _XOPEN_SOURCE 500</span>
<span class="co2">#include &lt;pthread.h&gt;</span>
&nbsp;
<span class="kw4">int</span> pthread_mutexattr_getprotocol<span class="br0">(</span><span class="kw4">const</span> pthread_mutexattr_t <span class="sy0">*</span>attr<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>protocol<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_mutexattr_setprotocol<span class="br0">(</span>pthread_mutexattr_t <span class="sy0">*</span>attr<span class="sy0">,</span> <span class="kw4">int</span> protocol<span class="br0">)</span><span class="sy0">;</span></pre>
<ul>
<li class="level1"><div class="li"> modul de comportare la <strong>preluări recursive</strong> ale mutex-ului</div>
<ul>
<li class="level2"><div class="li"> <code>PTHREAD_MUTEX_NORMAL</code> – <strong>nu</strong> se fac verificări, preluarea recursivă duce la <strong><em>deadlock</em></strong></div>
</li>
<li class="level2"><div class="li"> <code>PTHREAD_MUTEX_ERRORCHECK</code> – se fac verificări, preluarea recursivă duce la întoarcerea unei <strong>erori</strong></div>
</li>
<li class="level2"><div class="li"> <code>PTHREAD_MUTEX_RECURSIVE</code> – mutex-urile pot fi preluate recursiv, dar trebuie <strong>eliberate de același număr de ori</strong>. </div>
</li>
</ul>
</li>
</ul>
<pre class="code c"><span class="co2">#define _XOPEN_SOURCE 500</span>
<span class="co2">#include &lt;pthread.h&gt;</span>
&nbsp;
pthread_mutexattr_gettype<span class="br0">(</span><span class="kw4">const</span> pthread_mutexattr_t <span class="sy0">*</span>attr<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>protocol<span class="br0">)</span><span class="sy0">;</span>
pthread_mutexattr_settype<span class="br0">(</span>pthread_mutexattr_t <span class="sy0">*</span>attr<span class="sy0">,</span> <span class="kw4">int</span> protocol<span class="br0">)</span><span class="sy0">;</span></pre>
</div></div>
</div>

<h3 class="sectionedit23" id="ocupareaeliberarea_unui_mutex">Ocuparea/eliberarea unui mutex</h3>
<div class="level3">

<p>
Funcțiile de ocupare blocantă/eliberare a unui mutex (<a href="http://linux.die.net/man/3/pthread_mutex_lock" class="urlextern" title="http://linux.die.net/man/3/pthread_mutex_lock" rel="nofollow">pthread_mutex_lock</a>, <a href="http://linux.die.net/man/3/pthread_mutex_unlock" class="urlextern" title="http://linux.die.net/man/3/pthread_mutex_unlock" rel="nofollow">pthread_mutex_unlock</a>):
</p>
<pre class="code c"><span class="kw4">int</span> pthread_mutex_lock  <span class="br0">(</span>pthread_mutex_t <span class="sy0">*</span>mutex<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_mutex_unlock<span class="br0">(</span>pthread_mutex_t <span class="sy0">*</span>mutex<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Dacă mutex-ul este <strong>liber</strong> în momentul apelului, acesta va fi ocupat de firul apelant și funcția va întoarce imediat. Dacă mutex-ul este ocupat de un <strong>alt fir</strong>, apelul va bloca până la eliberarea mutex-ului. Dacă mutex-ul este deja ocupat de <strong>firul curent</strong> de execuție (lock recursiv), comportamentul funcției este dictat de tipul mutex-ului:
</p>
<div class="table sectionedit24"><table class="inline">
	<tbody><tr class="row0">
		<th class="col0 leftalign"> Tip mutex                    </th><th class="col1 leftalign"> Lock recursiv 	                   </th><th class="col2 leftalign"> Unlock             </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> <code>PTHREAD_MUTEX_NORMAL</code>     </td><td class="col1 leftalign"> deadlock 	                   </td><td class="col2"> eliberează mutex-ul </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <code>PTHREAD_MUTEX_ERRORCHECK</code> </td><td class="col1 leftalign"> returnează eroare                 </td><td class="col2"> eliberează mutex-ul </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> <code>PTHREAD_MUTEX_RECURSIVE</code>  </td><td class="col1"> incrementează contorul de ocupări </td><td class="col2"> decrementează contorul de ocupări (la zero eliberează mutex-ul) </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> <code>PTHREAD_MUTEX_DEFAULT</code>    </td><td class="col1 leftalign"> deadlock                          </td><td class="col2"> eliberează mutex-ul </td>
	</tr>
</tbody></table></div>

<p>
Nu este garantată o ordine FIFO de ocupare a unui mutex. <strong>Oricare din firele</strong> aflate în așteptare la deblocarea unui mutex pot să-l acapareze.
</p>

</div>

<h3 class="sectionedit25" id="incercarea_neblocanta_de_ocupare_a_unui_mutex">Încercarea neblocantă de ocupare a unui mutex</h3>
<div class="level3">

<p>
Pentru a încerca ocuparea unui mutex <strong>fără a aștepta</strong> eliberarea acestuia în cazul în care este deja ocupat, se va apela funcția <a href="http://linux.die.net/man/3/pthread_mutex_trylock" class="urlextern" title="http://linux.die.net/man/3/pthread_mutex_trylock" rel="nofollow">pthread_mutex_trylock</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_mutex_trylock<span class="br0">(</span>pthread_mutex_t <span class="sy0">*</span>mutex<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Exemplu:
</p>
<pre class="code c"><span class="kw4">int</span> rc <span class="sy0">=</span> pthread_mutex_trylock<span class="br0">(</span><span class="sy0">&amp;</span>mutex<span class="br0">)</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span>rc <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="coMULTI">/* successfully aquired the free mutex */</span>
<span class="br0">}</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>rc <span class="sy0">==</span> EBUSY<span class="br0">)</span> <span class="br0">{</span>
    <span class="coMULTI">/* mutex was held by someone else
       instead of blocking we return EBUSY */</span>
<span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
    <span class="coMULTI">/* some other error occured */</span>
<span class="br0">}</span></pre>

</div>

<h3 class="sectionedit26" id="exemplu_de_utilizare_a_mutex-urilor">Exemplu de utilizare a mutex-urilor</h3>
<div class="level3">

<p>
Un exemplu de utilizare a unui mutex pentru a serializa accesul la variabila globală <code>global_counter</code>:
</p>
<pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;pthread.h&gt;</span>
&nbsp;
<span class="co2">#define NUM_THREADS 5</span>
&nbsp;
<span class="coMULTI">/* global mutex */</span>
pthread_mutex_t mutex<span class="sy0">;</span>
<span class="kw4">int</span> global_counter <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> <span class="sy0">*</span>thread_routine<span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span>arg<span class="br0">)</span> 
<span class="br0">{</span>    
    <span class="coMULTI">/* acquire global mutex */</span>
    pthread_mutex_lock<span class="br0">(</span><span class="sy0">&amp;</span>mutex<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* print and modify global_counter */</span>
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"Thread %d says global_counter=%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> arg<span class="sy0">,</span> global_counter<span class="br0">)</span><span class="sy0">;</span>
    global_counter<span class="sy0">++;</span>
&nbsp;
    <span class="coMULTI">/* release mutex - now other threads can modify global_counter */</span>
    pthread_mutex_unlock<span class="br0">(</span><span class="sy0">&amp;</span>mutex<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> NULL<span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> 
<span class="br0">{</span>
    <span class="kw4">int</span> i<span class="sy0">;</span>
    pthread_t tids<span class="br0">[</span>NUM_THREADS<span class="br0">]</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* init mutex once, but use it in every thread */</span>
    pthread_mutex_init<span class="br0">(</span><span class="sy0">&amp;</span>mutex<span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* all threads execute thread_routine
       as args to the thread send a thread id 
       represented by a pointer to an integer */</span>
    <span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> NUM_THREADS<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        pthread_create<span class="br0">(</span><span class="sy0">&amp;</span>tids<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> NULL<span class="sy0">,</span> thread_routine<span class="sy0">,</span> <span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span><span class="br0">)</span> i<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* wait for all threads to finish */</span>
    <span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> NUM_THREADS<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        pthread_join<span class="br0">(</span>tids<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* dispose mutex */</span>
    pthread_mutex_destroy<span class="br0">(</span><span class="sy0">&amp;</span>mutex<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
<pre class="code bash"><span class="co4">so@spook$ </span><span class="kw2">gcc</span> <span class="re5">-Wall</span> mutex.c <span class="re5">-lpthread</span>
<span class="co4">so@spook$ </span>.<span class="sy0">/</span>a.out 
Thread <span class="nu0">1</span> says <span class="re2">global_counter</span>=<span class="nu0">0</span>
Thread <span class="nu0">2</span> says <span class="re2">global_counter</span>=<span class="nu0">1</span>
Thread <span class="nu0">3</span> says <span class="re2">global_counter</span>=<span class="nu0">2</span>
Thread <span class="nu0">4</span> says <span class="re2">global_counter</span>=<span class="nu0">3</span>
Thread <span class="nu0">0</span> says <span class="re2">global_counter</span>=<span class="nu0">4</span></pre>

</div>

<h2 class="sectionedit27" id="futex-uri">Futex-uri</h2>
<div class="level2">

<p>
Mutex-urile din firele de execuție POSIX sunt implementate cu ajutorul <strong><em>futex</em></strong>-urilor, din considerente de performanță. 
</p>

<p>
Optimizarea constă în testarea și setarea atomică a valorii mutex-ului (printr-o instrucțiune de tip <em>test-and-set-lock</em>) în user-space, <strong>eliminându-se trap-ul în kernel</strong> în cazul în care <strong>nu</strong> este necesară blocarea.
</p>
<div class="hiddenGlobal "><div class="hiddenOnHidden">
<p>
Click to display ⇲
</p>
</div><div class="hiddenOnVisible">
<p>
Click to hide ⇱
</p>
</div><div class="hiddenElements"></div><div class="hiddenHead  hiddenActive hiddenSinceBeginning">
<p>
Click to display ⇲
</p>
</div><div class="hiddenBody" style="display: none;">
<p>
Numele de <em>futex</em> vine de la <em>Fast User-space muTEX</em>. Ideea de la care a plecat implementarea <em>futex</em>-urilor a fost aceea de a <strong>optimiza</strong> operația de ocupare a unui mutex în cazul în care acesta <strong>nu este deja ocupat</strong>. Dacă mutex-ul nu este ocupat, el va fi ocupat fără ca procesul care îl ocupă să se blocheze. În acest caz, nefiind necesară blocarea, nu este necesar ca procesul să intre în kernel-mode (pentru a intra într-o stare de așteptare). Optimizarea constă în testarea și setarea atomică a valorii mutex-ului (printr-o instrucțiune de tip <em>test-and-set-lock</em>) în user-space, <strong>eliminându-se trap-ul în kernel</strong> în cazul în care <strong>nu</strong> este necesară blocarea.
</p>

<p>
<em>Futex</em>-ul poate fi orice variabilă dintr-o zonă de memorie partajată între mai multe fire de execuție sau procese. Așadar, operațiile efective cu <em>futex</em>-urile se fac prin intermediul funcției <code>do_futex</code>, disponibilă prin includerea headerului <code>linux/futex.h</code>. Signatura ei arată astfel:
</p>
<pre class="code c"><span class="kw4">long</span> do_futex<span class="br0">(</span><span class="kw4">unsigned</span> <span class="kw4">long</span> uaddr<span class="sy0">,</span> <span class="kw4">int</span> op<span class="sy0">,</span>
              <span class="kw4">int</span> val<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">long</span> timeout<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">long</span> uaddr2<span class="sy0">,</span> <span class="kw4">int</span> val2<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
În cazul în care este necesară blocarea, <code>do_futex</code> va face un apel de sistem - <code>sys_futex</code>. <em>Futex</em>-urile pot fi utile (și poate fi necesară utilizarea lor explicită) în cazul sincronizării proceselor, fiind alocate în variabile din zone de memorie partajată între procesele respective.
</p>
</div></div>
</div>

<h2 class="sectionedit28" id="semafor">Semafor</h2>
<div class="level2">

<p>
Semafoarele sunt obiecte de sincronizare ce reprezintă o generalizare a mutexurilor prin aceea că <strong>salvează numărul de operații de eliberare</strong> (incrementare) efectuate asupra lor. Practic, un semafor reprezintă un întreg care se incrementează/decrementează atomic. Valoarea unui semafor nu poate scădea sub 0. Dacă semaforul are valoarea 0, operația de decrementare se va bloca până când valoarea semaforului devine strict pozitivă. Mutexurile pot fi privite, așadar, ca niște semafoare binare.
</p>

<p>
Semafoarele POSIX au fost prezentate în cadrul <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05" class="wikilink1" title="so:laboratoare:laborator-05">Laboratorului 05 - IPC</a>.
</p>

<p>
Operațiile care pot fi efectuate asupra semafoarelor POSIX sunt multiple:
</p>

</div>

<h3 class="sectionedit29" id="semafoare_cu_nume_-_initializaredeinitializare">Semafoare cu nume - Inițializare/deinițializare</h3>
<div class="level3">
<pre class="code c"><span class="coMULTI">/* use named semaphore to synchronize processes */</span>
<span class="coMULTI">/* open */</span>
sem_t<span class="sy0">*</span> sem_open<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> oflag<span class="br0">)</span><span class="sy0">;</span>                                 
<span class="coMULTI">/* create */</span>
sem_t<span class="sy0">*</span> sem_open<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> oflag<span class="sy0">,</span> mode_t mode<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> value<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* closing named semaphore */</span>
<span class="kw4">int</span> sem_close<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* delete from system a names semaphore */</span>
<span class="kw4">int</span> sem_unlink<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="br0">)</span><span class="sy0">;</span>
&nbsp;</pre>

</div>

<h3 class="sectionedit30" id="semafoare_anonime_-_initializaredeinitializare">Semafoare anonime - Inițializare/deinițializare</h3>
<div class="level3">


<pre class="code c"><span class="kw4">int</span> sem_init<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="sy0">,</span> <span class="kw4">int</span> pshared<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> value<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* close unnamed semaphore */</span>
<span class="kw4">int</span> sem_destroy<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h3 class="sectionedit31" id="operatii_comune_pe_semafoare">Operații comune pe semafoare</h3>
<div class="level3">
<pre class="code c"><span class="coMULTI">/* increment/release semaphore (V) */</span>
<span class="kw4">int</span> sem_post<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* decrement/acquire semaphore (P) */</span>
<span class="kw4">int</span> sem_wait<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* non-blocking decrement/acquire */</span>
<span class="kw4">int</span> sem_trywait<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* getting the semaphore count */</span>
<span class="kw4">int</span> sem_getvalue<span class="br0">(</span>sem_t <span class="sy0">*</span>sem<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>pvalue<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h2 class="sectionedit32" id="variabile_conditie">Variabile condiție</h2>
<div class="level2">

<p>
Variabilele condiție pun la dispoziție un sistem de notificare pentru fire de execuție, permițându-i unui fir să se blocheze în așteptarea unui semnal din partea unui alt fir. Folosirea corectă a variabilelor condiție presupune un protocol cooperativ între firele de execuție.
</p>

<p>
Mutex-urile și semafoarele permit blocarea <strong>altor fire</strong> de execuție. Variabilele de condiție se folosesc pentru a bloca <strong>firul curent</strong> până la îndeplinirea unei condiții.
</p>

<p>
Variabilele condiție sunt obiecte de sincronizare care-i permit unui fir de execuție să-și suspende execuția până când o condiție (predicat logic) <strong>devine adevărată</strong>. Când un fir de execuție determină că predicatul a devenit adevărat, va semnala variabila condiție, deblocând astfel unul sau toate firele de execuție blocate la acea variabilă condiție (în funcție de intenție).
</p>

<p>
O variabilă condiție trebuie întotdeauna folosită <strong>împreună cu un mutex</strong> pentru evitarea race-ului care se produce când un fir se pregătește să aștepte la variabila condiție în urma evaluării predicatului logic, iar alt fir semnalizează variabila condiție chiar înainte ca primul fir să se blocheze, pierzându-se astfel semnalul. Așadar, operațiile de semnalizare, testare a condiției logice și blocare la variabila condiție trebuie efectuate având <strong>ocupat</strong> mutexul asociat variabilei condiție. Condiția logică este testată sub protecția mutexului, iar dacă nu este îndeplinită, firul apelant se blochează la variabila condiție, eliberând atomic mutexul. În momentul deblocării, un fir de execuție va încerca să ocupe mutexul asociat variabilei condiție. De asemenea, testarea predicatului logic trebuie făcută într-o <strong>buclă</strong>, deoarece, dacă sunt eliberate mai multe fire deodată, doar unul va reuși să ocupe mutexul asociat condiției. Restul vor aștepta ca acesta să-l elibereze, însă este posibil ca firul care a ocupat mutexul să <strong>schimbe</strong> valoarea predicatului logic pe durata deținerii mutexului. Din acest motiv celelalte fire trebuie să testeze din nou predicatul pentru că, altfel, și-ar începe execuția presupunând predicatul adevărat, când el este, de fapt, fals.
</p>

</div>

<h3 class="sectionedit33" id="initializareadistrugerea_unei_variabile_de_conditie">Inițializarea/distrugerea unei variabile de condiție</h3>
<div class="level3">

<p>
Inițializarea unei variabile de condiție se face folosind macro-ul PTHREAD_COND_INITIALIZER sau funcția <a href="http://linux.die.net/man/3/pthread_cond_init" class="urlextern" title="http://linux.die.net/man/3/pthread_cond_init" rel="nofollow">pthread_cond_init</a>. Distrugerea unei variabile de condiție se face prin funcția <a href="http://linux.die.net/man/3/pthread_cond_destroy" class="urlextern" title="http://linux.die.net/man/3/pthread_cond_destroy" rel="nofollow">pthread_cond_destroy</a>.
</p>
<pre class="code c"><span class="co1">// initializare statica a unei variabile de condiție cu atribute implicite</span>
<span class="co1">// NB: variabila de conditie nu este eliberata, </span>
<span class="co1">//     durata de viata a variabilei de condiție este durata de viata a programului.</span>
pthread_cond_t cond <span class="sy0">=</span> PTHREAD_COND_INITIALIZER<span class="sy0">;</span>
&nbsp;
<span class="co1">// semnaturile functiilor de initializare si eliberare de variabile de condiție:</span>
<span class="kw4">int</span> pthread_cond_init   <span class="br0">(</span>pthread_cond_t <span class="sy0">*</span>cond<span class="sy0">,</span> pthread_condattr_t <span class="sy0">*</span>attr<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> pthread_cond_destroy<span class="br0">(</span>pthread_cond_t <span class="sy0">*</span>cond<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Ca și la mutex-uri:
</p>
<ul>
<li class="level1"><div class="li">dacă parametrul <code>attr</code> este nul, se folosesc atribute implicite</div>
</li>
<li class="level1"><div class="li">trebuie să nu existe nici un fir de execuție în așteptare pe variabila de condiție atunci când aceasta este distrusă, altfel se întoarce <code>EBUSY</code>. </div>
</li>
</ul>

</div>

<h3 class="sectionedit34" id="blocarea_la_o_variabila_conditie">Blocarea la o variabilă condiție</h3>
<div class="level3">

<p>
Pentru a-și suspenda execuția și a aștepta la o variabilă condiție, un fir de execuție va apela funcția <a href="http://linux.die.net/man/3/pthread_cond_wait" class="urlextern" title="http://linux.die.net/man/3/pthread_cond_wait" rel="nofollow">pthread_cond_wait</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_cond_wait<span class="br0">(</span>pthread_cond_t <span class="sy0">*</span>cond<span class="sy0">,</span> pthread_mutex_t <span class="sy0">*</span>mutex<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Firul de execuție apelant trebuie să fi <strong>ocupat</strong> deja mutexul asociat, în momentul apelului. Funcția <code>pthread_cond_wait</code> va <strong>elibera</strong> mutexul și se va <strong>bloca</strong>, așteptând ca variabila condiție să fie <strong>semnalizată</strong> de un alt fir de execuție. Cele două operații sunt efectuate <strong>atomic</strong>. În momentul în care variabila condiție este semnalizată, se va încerca ocuparea mutexului asociat, și după <strong>ocuparea</strong> acestuia, apelul funcției va întoarce. Observați că firul de execuție apelant poate fi suspendat, după deblocare, în așteptarea ocupării mutexului asociat, timp în care predicatul logic, adevărat în momentul deblocării firului, poate fi modificat de alte fire. De aceea, apelul <code>pthread_cond_wait</code> trebuie efectuat într-o buclă în care se testează valoarea de adevăr a predicatului logic asociat variabilei condiție, pentru a asigura o serializare corectă a firelor de execuție. Un alt argument pentru testarea în buclă a predicatului logic este acela că un apel <code>pthread_cond_wait</code> poate fi <strong>întrerupt</strong> de un semnal asincron (vezi laboratorul de semnale), înainte ca predicatul logic să devină adevărat. Dacă firele de execuție care așteptau la variabila condiție nu ar testa din nou predicatul logic, și-ar continua execuția presupunând greșit că acesta e adevărat.
</p>

</div>

<h3 class="sectionedit35" id="blocarea_la_o_variabila_conditie_cu_timeout">Blocarea la o variabilă condiție cu timeout</h3>
<div class="level3">

<p>
Pentru a-și suspenda execuția și a aștepta la o variabilă condiție, nu mai târziu de un moment specificat de timp, un fir de execuție va apela <a href="http://linux.die.net/man/3/pthread_cond_timedwait" class="urlextern" title="http://linux.die.net/man/3/pthread_cond_timedwait" rel="nofollow">pthread_cond_timedwait</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_cond_timedwait<span class="br0">(</span>pthread_cond_t <span class="sy0">*</span>cond<span class="sy0">,</span> pthread_mutex_t <span class="sy0">*</span>mutex<span class="sy0">,</span> 
                           <span class="kw4">const</span> <span class="kw4">struct</span> timespec <span class="sy0">*</span>abstime<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Funcția se comportă la fel ca <code>pthread_cond_wait</code>, cu excepția faptului că, dacă variabila condiție nu este semnalizată mai devreme de <code>abstime</code>, firul apelant este deblocat, și, după ocuparea mutexului asociat, funcția se întoarce cu eroarea <code>ETIMEDOUT</code>. Parametrul <code>abstime</code> este absolut și reprezintă numărul de secunde trecute de la 1 ianuarie 1970, ora 00:00.
</p>

</div>

<h3 class="sectionedit36" id="deblocarea_unui_singur_fir_blocat_la_o_variabila_conditie">Deblocarea unui singur fir blocat la o variabilă condiție</h3>
<div class="level3">

<p>
Pentru a debloca un singur fir de execuție blocat la o variabilă condiție se va semnaliza variabila condiție folosind <a href="http://linux.die.net/man/3/pthread_cond_signal" class="urlextern" title="http://linux.die.net/man/3/pthread_cond_signal" rel="nofollow">pthread_cond_signal</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_cond_signal<span class="br0">(</span>pthread_cond_t <span class="sy0">*</span>cond<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Dacă la variabila condiție nu așteaptă niciun fir de execuție, apelul funcției nu are efect și semnalizarea se va <strong>pierde</strong>. Dacă la variabila condiție așteaptă mai multe fire de execuție, va fi deblocat doar unul dintre acestea. Alegerea firului care va fi deblocat este făcută de planificatorul de fire de execuție. Nu se poate presupune că firele care așteaptă vor fi deblocate în ordinea în care și-au început așteptarea. Firul de execuție apelant trebuie să dețină <strong>mutexul</strong> asociat variabilei condiție în momentul apelului acestei funcții.
</p>

<p>
Exemplu:
</p>
<pre class="code c">pthread_mutex_t count_lock<span class="sy0">;</span>
pthread_cond_t  count_nonzero<span class="sy0">;</span>
<span class="kw4">unsigned</span>        count<span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> decrement_count<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    pthread_mutex_lock<span class="br0">(</span><span class="sy0">&amp;</span>count_lock<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span> <span class="br0">(</span>count <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        pthread_cond_wait<span class="br0">(</span><span class="sy0">&amp;</span>count_nonzero<span class="sy0">,</span> <span class="sy0">&amp;</span>count_lock<span class="br0">)</span><span class="sy0">;</span>
    count <span class="sy0">=</span> count <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
    pthread_mutex_unlock<span class="br0">(</span><span class="sy0">&amp;</span>count_lock<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> increment_count<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    pthread_mutex_lock<span class="br0">(</span><span class="sy0">&amp;</span>count_lock<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span> <span class="br0">(</span>count <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span>
        pthread_cond_signal<span class="br0">(</span><span class="sy0">&amp;</span>count_nonzero<span class="br0">)</span><span class="sy0">;</span>
    count <span class="sy0">=</span> count <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
    pthread_mutex_unlock<span class="br0">(</span><span class="sy0">&amp;</span>count_lock<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>

</div>

<h3 class="sectionedit37" id="deblocarea_tuturor_firelor_blocate_la_o_variabila_conditie">Deblocarea tuturor firelor blocate la o variabilă condiție</h3>
<div class="level3">

<p>
Pentru a debloca toate firele de execuție blocate la o variabilă condiție, se semnalizează variabila condiție folosind <a href="http://linux.die.net/man/3/pthread_cond_broadcast" class="urlextern" title="http://linux.die.net/man/3/pthread_cond_broadcast" rel="nofollow">pthread_cond_broadcast</a>:
</p>
<pre class="code c"><span class="kw4">int</span> pthread_cond_broadcast<span class="br0">(</span>pthread_cond_t <span class="sy0">*</span>cond<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Dacă la variabila condiție nu așteaptă niciun fir de execuție, apelul funcției nu are efect și semnalizarea se va <strong>pierde</strong>. Dacă la variabila condiție așteaptă fire de execuție, toate acestea vor fi deblocate, dar vor <strong>concura</strong> pentru ocuparea mutexului asociat variabilei condiție. Firul de execuție apelant trebuie să dețină mutexul asociat variabilei condiție în momentul apelului acestei funcții.
</p>

</div>

<h3 class="sectionedit38" id="exemplu_de_utilizare_a_variabilelor_de_conditie">Exemplu de utilizare a variabilelor de condiție</h3>
<div class="level3">

<p>
În următorul program se utilizează o barieră pentru a sincroniza firele de execuție ale programului. Bariera este implementată cu ajutorului unei variabile de condiție.
</p>
<pre class="code c"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;pthread.h&gt;</span>
&nbsp;
<span class="co2">#define NUM_THREADS 5</span>
&nbsp;
<span class="co1">// implementarea unei bariere *nereentrante* cu variabile de conditie</span>
<span class="kw4">struct</span> my_barrier_t <span class="br0">{</span>
    <span class="co1">// mutex folosit pentru a serializa accesele la datele interne ale barierei</span>
    pthread_mutex_t lock<span class="sy0">;</span>
&nbsp;
    <span class="co1">// variabila de conditie pe care se astepta sosirea tuturor firelor de executie</span>
    pthread_cond_t  cond<span class="sy0">;</span>
&nbsp;
    <span class="co1">// numar de fire de executie care trebuie sa mai vina pentru a elibera bariera</span>
    <span class="kw4">int</span> nr_still_to_come<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">struct</span> my_barrier_t bar<span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> my_barrier_init<span class="br0">(</span><span class="kw4">struct</span> my_barrier_t <span class="sy0">*</span>bar<span class="sy0">,</span> <span class="kw4">int</span> nr_still_to_come<span class="br0">)</span> <span class="br0">{</span>
    pthread_mutex_init<span class="br0">(</span><span class="sy0">&amp;</span>bar<span class="sy0">-&gt;</span>lock<span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
    pthread_cond_init<span class="br0">(</span><span class="sy0">&amp;</span>bar<span class="sy0">-&gt;</span>cond<span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// cate fire de executie sunt asteptate la bariera.</span>
    bar<span class="sy0">-&gt;</span>nr_still_to_come <span class="sy0">=</span> nr_still_to_come<span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> my_barrier_destroy<span class="br0">(</span><span class="kw4">struct</span> my_barrier_t <span class="sy0">*</span>bar<span class="br0">)</span> <span class="br0">{</span>
    pthread_cond_destroy<span class="br0">(</span><span class="sy0">&amp;</span>bar<span class="sy0">-&gt;</span>cond<span class="br0">)</span><span class="sy0">;</span>
    pthread_mutex_destroy<span class="br0">(</span><span class="sy0">&amp;</span>bar<span class="sy0">-&gt;</span>lock<span class="br0">)</span><span class="sy0">;</span>  
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> <span class="sy0">*</span>thread_routine<span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span>arg<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">int</span> thd_id <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> arg<span class="sy0">;</span>
&nbsp;
    <span class="co1">// inainte de a lucra cu datele interne ale barierei trebuie sa preluam mutexul</span>
    pthread_mutex_lock<span class="br0">(</span><span class="sy0">&amp;</span>bar.<span class="me1">lock</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"thd %d: before the barrier<span class="es1">\n</span>"</span><span class="sy0">,</span> thd_id<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// suntem ultimul fir de executie care a sosit la bariera?  </span>
    <span class="kw4">int</span> is_last_to_arrive <span class="sy0">=</span> <span class="br0">(</span>bar.<span class="me1">nr_still_to_come</span> <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// decrementam numarul de fire de executie asteptate la bariera</span>
    bar.<span class="me1">nr_still_to_come</span> <span class="sy0">--;</span>
&nbsp;
    <span class="co1">// cat timp mai sunt fire de execuție care nu au ajuns la bariera, asteptam.</span>
    <span class="kw1">while</span> <span class="br0">(</span>bar.<span class="me1">nr_still_to_come</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="co1">// lockul se elibereaza automat inainte de a incepe asteptarea</span>
        pthread_cond_wait<span class="br0">(</span><span class="sy0">&amp;</span>bar.<span class="me1">cond</span><span class="sy0">,</span> <span class="sy0">&amp;</span>bar.<span class="me1">lock</span><span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
    <span class="co1">// ultimul fir de execuție ajuns la bariera va semnaliza celelalte fire </span>
    <span class="kw1">if</span> <span class="br0">(</span>is_last_to_arrive<span class="br0">)</span> <span class="br0">{</span>
        <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"    let the flood in<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
        pthread_cond_broadcast<span class="br0">(</span><span class="sy0">&amp;</span>bar.<span class="me1">cond</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"thd %d: after the barrier<span class="es1">\n</span>"</span><span class="sy0">,</span> thd_id<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// la iesirea din functia de asteptare se preia automat mutexul, trebuie eliberat.</span>
    pthread_mutex_unlock<span class="br0">(</span><span class="sy0">&amp;</span>bar.<span class="me1">lock</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> NULL<span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">int</span> i<span class="sy0">;</span>
    pthread_t tids<span class="br0">[</span>NUM_THREADS<span class="br0">]</span><span class="sy0">;</span>
&nbsp;
    my_barrier_init<span class="br0">(</span><span class="sy0">&amp;</span>bar<span class="sy0">,</span> NUM_THREADS<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> NUM_THREADS<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        pthread_create<span class="br0">(</span><span class="sy0">&amp;</span>tids<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> NULL<span class="sy0">,</span> thread_routine<span class="sy0">,</span> <span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span><span class="br0">)</span> i<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> NUM_THREADS<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        pthread_join<span class="br0">(</span>tids<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    my_barrier_destroy<span class="br0">(</span><span class="sy0">&amp;</span>bar<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
<pre class="code bash"><span class="co4">so@spook$ </span><span class="kw2">gcc</span> <span class="re5">-Wall</span> cond_var.c <span class="re5">-pthread</span>
<span class="co4">so@spook$ </span>.<span class="sy0">/</span>a.out 
thd <span class="nu0">0</span>: before the barrier
thd <span class="nu0">2</span>: before the barrier
thd <span class="nu0">3</span>: before the barrier
thd <span class="nu0">4</span>: before the barrier
thd <span class="nu0">1</span>: before the barrier
    <span class="kw3">let</span> the flood <span class="kw1">in</span>
thd <span class="nu0">1</span>: after the barrier
thd <span class="nu0">2</span>: after the barrier
thd <span class="nu0">3</span>: after the barrier
thd <span class="nu0">4</span>: after the barrier
thd <span class="nu0">0</span>: after the barrier</pre>

<p>
Din execuția programului se observă:
</p>
<ul>
<li class="level1"><div class="li">ordinea în care sunt planificate firele de execuție <strong>nu</strong> este neapărat cea a creării lor</div>
</li>
<li class="level1"><div class="li">ordinea în care sunt trezite firele de execuție ce așteaptă la o variabilă de condiție <strong>nu</strong> este neapărat ordinea în care acestea au intrat în așteptare. </div>
</li>
</ul>

</div>

<h2 class="sectionedit39" id="bariera">Bariera</h2>
<div class="level2">

<p>
Standardul POSIX definește și un set de funcții și structuri de date de lucru cu bariere. Aceste funcții sunt disponibile dacă se definește macro-ul <code>_XOPEN_SOURCE</code> la o valoare &gt;= 600.
</p>

</div>

<h3 class="sectionedit40" id="initializareadistrugerea_unei_bariere">Inițializarea/distrugerea unei bariere</h3>
<div class="level3">

<p>
Bariera se va inițializa folosind <a href="http://linux.die.net/man/3/pthread_barrier_init" class="urlextern" title="http://linux.die.net/man/3/pthread_barrier_init" rel="nofollow">pthread_barrier_init</a> și se va distruge folosind <a href="http://linux.die.net/man/3/pthread_barrier_destroy" class="urlextern" title="http://linux.die.net/man/3/pthread_barrier_destroy" rel="nofollow">pthread_barrier_destroy</a>.
</p>
<pre class="code c"><span class="co1">// pentru a folosi funcțiile de lucru cu bariere e nevoie să se definească </span>
<span class="co1">// _XOPEN_SOURCE la o valoare &gt;= 600. Pentru detalii consultați feature_test_macros(7).</span>
<span class="co2">#define _XOPEN_SOURCE 600</span>
<span class="co2">#include &lt;pthread.h&gt;</span>
&nbsp;
<span class="co1">// attr    -&gt; un set de adribute, poate fi NULL (se folosesc atribute implicite)</span>
<span class="co1">// count   -&gt; numărul de fire de execuție care trebuie să ajungă</span>
<span class="co1">//            la barieră pentru ca aceasta să fie eliberată</span>
<span class="kw4">int</span> pthread_barrier_init<span class="br0">(</span>pthread_barrier_t <span class="sy0">*</span> barrier<span class="sy0">,</span> 
                         <span class="kw4">const</span> pthread_barrierattr_t <span class="sy0">*</span> attr<span class="sy0">,</span> 
                         <span class="kw4">unsigned</span> count<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// trebuie să nu existe fire de execuție în așteptare la barieră</span>
<span class="co1">// înainte de a apela funcția _destroy, altfel, se întoarce EBUSY </span>
<span class="co1">// și nu se distruge bariera.</span>
<span class="kw4">int</span> pthread_barrier_destroy<span class="br0">(</span>pthread_barrier_t <span class="sy0">*</span>barrier<span class="br0">)</span><span class="sy0">;</span></pre>

</div>

<h3 class="sectionedit41" id="asteptarea_la_o_bariera">Așteptarea la o barieră</h3>
<div class="level3">

<p>
Așteptarea la barieră se face prin apelul <a href="http://linux.die.net/man/3/pthread_barrier_wait" class="urlextern" title="http://linux.die.net/man/3/pthread_barrier_wait" rel="nofollow">pthread_barrier_wait</a>:
</p>
<pre class="code c"><span class="co2">#define _XOPEN_SOURCE 600</span>
<span class="co2">#include &lt;pthread.h&gt;</span>
<span class="kw4">int</span> pthread_barrier_wait<span class="br0">(</span>pthread_barrier_t <span class="sy0">*</span>barrier<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
Dacă bariera a fost creată cu <code>count=N</code>, primele <code>N-1</code> fire de execuție care apelează <code>pthread_barrier_wait</code> se blochează. Când sosește <strong>ultimul</strong> (al <code>N</code>-lea), va debloca toate cele <code>N-1</code> fire de execuție. Funcția <code>pthread_barrier_wait</code> întoarce trei valori:
</p>
<ul>
<li class="level1"><div class="li"><code>EINVAL</code> – în cazul în care bariera nu este inițializată (singura eroare definită)</div>
</li>
<li class="level1"><div class="li"><code>PTHREAD_BARRIER_SERIAL_THREAD</code> – în caz de succes, un singur fir de execuție va întoarce valoarea aceasta – nu e specificat care este acel fir de execuție (nu e obligatoriu să fie ultimul ajuns la barieră)</div>
</li>
<li class="level1"><div class="li"><code>0</code> – valoare întoarsă în caz de succes de celelalte <code>N-1</code> fire de execuție. </div>
</li>
</ul>

</div>

<h3 class="sectionedit42" id="exemplu_de_utilizare_a_barierei">Exemplu de utilizare a barierei</h3>
<div class="level3">

<p>
Cu bariere POSIX, programul de mai sus poate fi simplificat:
</p>
<pre class="code c"><span class="co2">#define _XOPEN_SOURCE 600</span>
<span class="co2">#include &lt;pthread.h&gt;</span>
<span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="co2">#define NUM_THREADS 5</span>
&nbsp;
pthread_barrier_t barrier<span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> <span class="sy0">*</span>thread_routine<span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span>arg<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">int</span> thd_id <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> arg<span class="sy0">;</span>
    <span class="kw4">int</span> rc<span class="sy0">;</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"thd %d: before the barrier<span class="es1">\n</span>"</span><span class="sy0">,</span> thd_id<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// toate firele de executie asteapta la bariera.</span>
    rc <span class="sy0">=</span> pthread_barrier_wait<span class="br0">(</span><span class="sy0">&amp;</span>barrier<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>rc <span class="sy0">==</span> PTHREAD_BARRIER_SERIAL_THREAD<span class="br0">)</span> <span class="br0">{</span>
        <span class="co1">// un singur fir de execuție (posibil ultimul) va intoarce PTHREAD_BARRIER_SERIAL_THREAD</span>
        <span class="co1">// restul firelor de execuție întorc 0 în caz de succes.</span>
        <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"   let the flood in<span class="es1">\n</span>"</span><span class="sy0">,</span> thd_id<span class="br0">)</span><span class="sy0">;</span> 
    <span class="br0">}</span>
&nbsp;
    <a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span><span class="st0">"thd %d: after the barrier<span class="es1">\n</span>"</span><span class="sy0">,</span> thd_id<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> NULL<span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> 
<span class="br0">{</span>
    <span class="kw4">int</span> i<span class="sy0">;</span>
    pthread_t tids<span class="br0">[</span>NUM_THREADS<span class="br0">]</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// bariera este initializata o singura data si folosita de toate firele de executie</span>
    pthread_barrier_init<span class="br0">(</span><span class="sy0">&amp;</span>barrier<span class="sy0">,</span> NULL<span class="sy0">,</span> NUM_THREADS<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// firele de executie vor executa codul functiei 'thread_routine'.</span>
    <span class="co1">// in locul unui pointer la date utile, se trimite in ultimul argument</span>
    <span class="co1">// un intreg - identificatorul firului de executie</span>
    <span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> NUM_THREADS<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
    pthread_create<span class="br0">(</span><span class="sy0">&amp;</span>tids<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> NULL<span class="sy0">,</span> thread_routine<span class="sy0">,</span> <span class="br0">(</span><span class="kw4">void</span> <span class="sy0">*</span><span class="br0">)</span> i<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// asteptam ca toate firele de executie sa se termine</span>
    <span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> NUM_THREADS<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        pthread_join<span class="br0">(</span>tids<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> NULL<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// eliberam resursele barierei</span>
    pthread_barrier_destroy<span class="br0">(</span><span class="sy0">&amp;</span>barrier<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
<pre class="code bash"><span class="co4">so@spook$ </span><span class="kw2">gcc</span> <span class="re5">-Wall</span> barrier.c <span class="re5">-lpthread</span>
<span class="co4">so@spook$ </span>.<span class="sy0">/</span>a.out 
thd <span class="nu0">0</span>: before the barrier
thd <span class="nu0">2</span>: before the barrier
thd <span class="nu0">1</span>: before the barrier
thd <span class="nu0">3</span>: before the barrier
thd <span class="nu0">4</span>: before the barrier
   <span class="kw3">let</span> the flood <span class="kw1">in</span>
thd <span class="nu0">4</span>: after the barrier
thd <span class="nu0">2</span>: after the barrier
thd <span class="nu0">3</span>: after the barrier
thd <span class="nu0">0</span>: after the barrier
thd <span class="nu0">1</span>: after the barrier</pre>

</div>

<h2 class="sectionedit43" id="exercitii_de_laborator">Exercitii de laborator</h2>
<div class="level2">

<p>
În rezolvarea laboratorului folosiți arhiva de sarcini <a href="http://elf.cs.pub.ro/so/res/laboratoare/lab08-tasks.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab08-tasks.zip" rel="nofollow"> lab08-tasks.zip</a>
</p>

<p>
<strong>Observații</strong>: Pentru a vă ajuta la implementarea exercițiilor din laborator, în directorul <code>utils</code> din arhivă există un fișier <code>utils.h</code> cu funcții utile.
</p>

</div>

<h2 class="sectionedit44" id="linux">Linux</h2>
<div class="level2">

<p>
</p><p></p><div class="noteclassic">Pentru a instala paginile de manual pentru 'pthreads'
<p></p>
<pre class="code bash"><span class="kw2">sudo</span> <span class="kw2">apt-get install</span> manpages-posix manpages-posix-dev</pre>

<p>

</p></div><p></p>
<p></p>
<ol>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Thread Stack</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>1-th_stack</code> și inspectați sursa.</div>
</li>
<li class="level2"><div class="li"> Compilați și rulați programul.</div>
</li>
<li class="level2"><div class="li"> Urmăriți cu <code>pmap</code> cum se modifică spațiul de adresă al programului.</div>
<ul>
<li class="level3"><div class="li"> Hint:</div>
<ul>
<li class="level4"><div class="li"> Puteți rula comanda: <pre class="code bash"> <span class="kw2">watch</span> <span class="re5">-d</span> pmap $<span class="br0">(</span><span class="kw2">pidof</span> th_stack<span class="br0">)</span></pre>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Ce reprezintă zonele de memorie care se creează după fiecare apel <code>pthread_create</code>?</div>
</li>
<li class="level2"><div class="li"> Câte fire de execuție se crează? Ce cod execută fiecare fir? </div>
</li>
<li class="level2"><div class="li"> Folosiți <code>Ctrl+C</code> pentru a termina programul. </div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Fire de execuție vs. Procese</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>2-th_vs_proc</code> și inspectați sursele.</div>
</li>
<li class="level2"><div class="li"> Ambele programe simulează un server care creează fire de execuție/procese.</div>
</li>
<li class="level2"><div class="li"> Compilați și rulați pe rând ambele programe. </div>
</li>
<li class="level2"><div class="li"> Afișați câte fire de execuție/procese s-au creat în ambele situații. Dar pentru procesul <code>init</code>?</div>
<ul>
<li class="level3"><div class="li"> Hint: </div>
<ul>
<li class="level4"><div class="li"> Folosiți utilitarul <code>ps</code>.</div>
</li>
<li class="level4"><div class="li"> Căutați parametrul '-L'.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Ce credeți că se întâmplă dacă la un moment dat un fir de execuție moare? Dar dacă moare un proces?</div>
<ul>
<li class="level3"><div class="li"> Hint:</div>
<ul>
<li class="level4"><div class="li"> Testați utilizând funcția <code>do_bad_task</code> la fiecare al 4-lea fir de execuție/process.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Thread safe</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>3-safety</code> și inspectați sursa <code>vars.c</code></div>
</li>
<li class="level2"><div class="li"> Sunt funcțiile <code>thread_function</code> și <code>main</code> thread-safe relativ la variabilele a, b, c?</div>
</li>
<li class="level2"><div class="li"> Hint:</div>
<ul>
<li class="level3"><div class="li"> Revedeți ce înseamnă <code><a href="http://en.wikipedia.org/wiki/Thread_safety" class="urlextern" title="http://en.wikipedia.org/wiki/Thread_safety" rel="nofollow"> thread safe</a></code>.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Observați ce se întâmplă cu memoria alocată pentru variabila <code>rez</code> după ce se face join. Cum explicați?</div>
</li>
<li class="level2"><div class="li"> Este funcția <code>malloc</code> thread-safe?</div>
</li>
<li class="level2"><div class="li"> Hint:</div>
<ul>
<li class="level3"><div class="li"> Sursa <code>malloc.c</code> testează apelul malloc realizat din mai multe fire de execuție.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Parallel <a href="http://linux.die.net/man/1/fgrep" class="urlextern" title="http://linux.die.net/man/1/fgrep" rel="nofollow"> fgrep</a> </div>
<ul>
<li class="level2"><div class="li"> Implementați un progam similar cu <a href="http://linux.die.net/man/1/fgrep" class="urlextern" title="http://linux.die.net/man/1/fgrep" rel="nofollow"> fgrep</a>, care să realizeze numărarea aparițiilor unui string într-un fișier în paralel.</div>
</li>
<li class="level2"><div class="li"> Porniți de la sursa <code>pfgrep.c</code> din directorul <code>4-pfgrep</code>.</div>
</li>
<li class="level2"><div class="li"> Hint:</div>
<ul>
<li class="level3"><div class="li"> Revedeți secțiunile <em>TODO</em>. Fiecare fir de execuție va căuta un șir într-o zonă de fișier, și va întoarce numărul de apariții. Firul de execuție principal va colecta rezultatele și va afișa numărul total de apariții.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Fișierul este mapat înainte de pornirea firelor de execuție. Este nevoie de sincronizarea accesului la citire?</div>
</li>
<li class="level2"><div class="li"> Comparați timpii de execuție obținuți cu varianta serială.</div>
</li>
<li class="level2"><div class="li"> Hints:</div>
<ul>
<li class="level3"><div class="li"> Întâi generați un fișier mare, pe care să puteți testa: <pre class="code bash"><span class="kw2">ls</span> <span class="re5">-R</span> <span class="sy0">/</span> <span class="sy0">&gt;</span> big_file.txt</pre>
</div>
</li>
<li class="level3"><div class="li"> Pentru a măsura timpul de execuție al unui program folosiți comanda <code>time</code>.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) – <code>Blocked</code></div>
<ul>
<li class="level2"><div class="li"> Inspectați fișierul <code>blocked.c</code> din directorul <code>5-blocked</code>, compilați și executați binarul (repetați până detectați blocarea programului). </div>
</li>
<li class="level2"><div class="li"> Programul crează două fire de execuție care caută un număr magic, fiecare în intervalul propriu.</div>
</li>
<li class="level2"><div class="li"> Fiecare fir de execuție, pentru fiecare valoare din intervalul propriu, verifică dacă este valoarea căutată:</div>
<ul>
<li class="level3"><div class="li"> Dacă da, marchează un câmp found pentru a înștiința și celălalt fir de execuție că a găsit numărul căutat.</div>
</li>
<li class="level3"><div class="li"> Dacă nu, inspectează câmpul <code>found</code> al structurii celuilalt fir de execuție, pentru a vedea dacă acesta a găsit deja numărul căutat. </div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> Determinați cauza blocării, reparați programul și explicați soluția.</div>
</li>
<li class="level2"><div class="li"> Hints:</div>
<ul>
<li class="level3"><div class="li"> Puteți utiliza <code>helgrind</code>, unul din tool-urile <code>valgrind</code>, pentru a detecta problema: <pre class="code bash"><span class="co4">$ </span><span class="kw2">valgrind</span> <span class="re5">--tool</span>=helgrind .<span class="sy0">/</span>blocked </pre>
</div>
</li>
<li class="level3"><div class="li"> Chiar dacă, aparent, programul nu se blochează, citiți mesajele afișate de valgrind.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 punct</strong>) Implementare comportament <code><a href="http://linux.die.net/man/3/pthread_once" class="urlextern" title="http://linux.die.net/man/3/pthread_once" rel="nofollow"> pthread_once()</a></code></div>
<ul>
<li class="level2"><div class="li"> Aveți o funcție de inițializare pe care vreți să o apelați o singură dată. </div>
</li>
<li class="level2"><div class="li"> Pornind de la sursa <code>once.c</code> din directorul <code>6-once</code>, asigurați-vă că funcția <code>init_func()</code> este apelată o singură dată.</div>
</li>
<li class="level2"><div class="li"> Nu modificați funcția <code>init_func()</code> si nu folositi <code>pthread_once()</code>.</div>
</li>
<li class="level2"><div class="li"> Hint:</div>
<ul>
<li class="level3"><div class="li"> Citiți despre funcționalitatea <a href="http://linux.die.net/man/3/pthread_once" class="urlextern" title="http://linux.die.net/man/3/pthread_once" rel="nofollow"> pthread_once()</a>.</div>
</li>
<li class="level3"><div class="li"> Revedeți secțiunea despre <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#mutex" title="so:laboratoare:laborator-08 ↵" class="wikilink1"> mutex</a>.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>2 puncte</strong>) Producător - Consumator</div>
<ul>
<li class="level2"><div class="li"> Intrați în directorul <code>7-prodcons</code> </div>
</li>
<li class="level2"><div class="li"> Compilați și rulați sursa. Ce observați ?</div>
</li>
<li class="level2"><div class="li"> Sincronizați accesul folosind variabile de condiție.</div>
<ul>
<li class="level3"><div class="li"> Hints:</div>
<ul>
<li class="level4"><div class="li"> Revedeți sectiunea despre <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#variabile_conditie" title="so:laboratoare:laborator-08 ↵" class="wikilink1"> variabile de condiție</a>.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>



</div>

<h3 class="sectionedit45" id="bonus">BONUS</h3>
<div class="level3">
<ol>
<li class="level1"><div class="li"> (<strong>1 so-karma</strong>) fork() vs pthread_create()</div>
<ul>
<li class="level2"><div class="li"> Ce se întâmplă dacă într-un proces care a creat fire de execuție se apelează <a href="http://linux.die.net/man/2/fork" class="urlextern" title="http://linux.die.net/man/2/fork" rel="nofollow">fork()</a>?</div>
</li>
<li class="level2"><div class="li"> Intrați în directorul <code>8-fork_thread</code> și inspectați sursa.</div>
</li>
<li class="level2"><div class="li"> Programul creează un fir de execuție, care nu își termină execuția până la apelul <a href="http://linux.die.net/man/2/fork" class="urlextern" title="http://linux.die.net/man/2/fork" rel="nofollow">fork()</a>.</div>
</li>
<li class="level2"><div class="li"> Verificați ce se întamplă rulând programul. Cum explicați?</div>
</li>
<li class="level2"><div class="li"> Hint:</div>
<ul>
<li class="level3"><div class="li"> Folosiți <a href="http://linux.die.net/man/1/strace" class="urlextern" title="http://linux.die.net/man/1/strace" rel="nofollow"> strace</a> pentru a vedea ce apeluri de sistem de fac. </div>
</li>
<li class="level3"><div class="li"> Apare apelul de sistem fork()?</div>
</li>
<li class="level3"><div class="li"> Folosiți următoarea comandă pentru a urmări apelul de sistem <a href="http://linux.die.net/man/2/clone" class="urlextern" title="http://linux.die.net/man/2/clone" rel="nofollow">clone()</a>:<pre class="code bash"> <span class="kw2">ltrace</span> <span class="re5">-S</span> <span class="re5">-n</span> <span class="nu0">8</span> .<span class="sy0">/</span>ft </pre>
</div>
</li>
<li class="level3"><div class="li"> Citiți pagina de manual a apelului <a href="http://linux.die.net/man/2/clone" class="urlextern" title="http://linux.die.net/man/2/clone" rel="nofollow">clone()</a>.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 so-karma</strong>) Thread Specific Data</div>
<ul>
<li class="level2"><div class="li"> Fișierul <code>9-tsd/tsd.c</code> conține o aplicație ce împarte un task între mai multe fire de execuție.</div>
</li>
<li class="level2"><div class="li"> Fiecare fir de execuție are un fișier de log în care va înregistra mesaje despre progresul său.</div>
</li>
<li class="level2"><div class="li"> <strong> Observați:</strong></div>
<ul>
<li class="level3"><div class="li"> Crearea de fire de execuție.</div>
</li>
<li class="level3"><div class="li"> Așteptarea terminării acestora.</div>
</li>
<li class="level3"><div class="li"> Cum se creează / folosește / șterge o variabilă specifică unui fir de execuție - <code>thread_log_key</code>.</div>
</li>
<li class="level3"><div class="li"> Utilitatea unei funcții de cleanup - <code>close_thread_log</code>.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> De ce <code>thread_function</code> nu mai trebuie să închidă fișierele de log?</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> (<strong>1 so-karma</strong>) Mutex vs. Spinlock</div>
<ul>
<li class="level2"><div class="li"> Care varianta este mai eficientă pentru a proteja incrementarea unei variabile? </div>
</li>
<li class="level2"><div class="li"> Intrați în directorul <code>10-spin</code> și inspectați sursa <code>spin.c</code></div>
</li>
<li class="level2"><div class="li"> Compilați sursa. În urma compilării vor rezulta doua executabile, unul care folosește mutex pentru sincronizare, respectiv spinlock.</div>
</li>
<li class="level2"><div class="li"> Obțineți timpul de execuție pentru fiecare program. Cum explicați diferența?</div>
</li>
<li class="level2"><div class="li"> Încercați să înlocuiți incrementarea variabilei cu un cod mai costisitor. Ce observați?</div>
</li>
<li class="level2"><div class="li"> Hint:</div>
<ul>
<li class="level3"><div class="li"> Ce se întâmplă dacă un fir de execuție găsește mutex-ul ocupat?</div>
</li>
<li class="level3"><div class="li"> Ce se întâmplă dacă un fir de execuție găsește spinlock-ul ocupat?</div>
</li>
</ul>
</li>
</ul>
</li>
</ol>



</div>

<h2 class="sectionedit46" id="solutii">Soluții</h2>
<div class="level2">

<p>
<a href="http://elf.cs.pub.ro/so/res/laboratoare/lab08-sol.zip" class="urlextern" title="http://elf.cs.pub.ro/so/res/laboratoare/lab08-sol.zip" rel="nofollow"> lab08-sol.zip</a>
</p>

</div>

<h2 class="sectionedit47" id="resurse_utile">Resurse utile</h2>
<div class="level2">

<p>
<a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html" class="urlextern" title="http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html" rel="nofollow"> LinuxTutorialPosixThreads </a>
</p>

<p>
<a href="https://computing.llnl.gov/tutorials/pthreads/" class="urlextern" title="https://computing.llnl.gov/tutorials/pthreads/" rel="nofollow"> POSIX Threads Programming</a>
</p>

</div>

        </div>
        <div class="right_sidebar">
          <form action="http://ocw.cs.pub.ro/courses/start" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search"><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]"><input type="submit" value="Search" class="button" title="Search"><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#laborator_08_-_thread-uri_linux">Laborator 08 - Thread-uri Linux</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#materiale_ajutatoare">Materiale ajutătoare</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#nice_to_read">Nice to read</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#prezentare_teoretica">Prezentare teoretică</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#diferente_dintre_fire_de_executie_si_procese">Diferențe dintre fire de execuție și procese</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#avantajele_firelor_de_executie">Avantajele firelor de execuție</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#tipuri_de_fire_de_executie">Tipuri de fire de execuție</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#suport_posix">Suport POSIX</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#crearea_firelor_de_executie">Crearea firelor de execuție</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#asteptarea_firelor_de_executie">Așteptarea firelor de execuție</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#terminarea_firelor_de_executie">Terminarea firelor de execuție</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#thread_specific_data_tsd">Thread Specific Data (TSD)</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#crearea_si_stergerea_unei_variabile">Crearea și ștergerea unei variabile</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#modificarea_si_citirea_unei_variabile">Modificarea și citirea unei variabile</a></div></li>
</ul>
</li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#functii_pentru_cleanup">Funcții pentru cleanup</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#atributele_unui_fir_de_executie">Atributele unui fir de execuție</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#cedarea_procesorului">Cedarea procesorului</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#alte_operatii">Alte operații</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#compilare">Compilare</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#exemplu">Exemplu</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#sincronizarea_firelor_de_executie">Sincronizarea firelor de execuție</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#mutex">Mutex</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#initializareadistrugerea_unui_mutex">Inițializarea/distrugerea unui mutex</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#tipuri_de_mutex-uri">Tipuri de mutex-uri</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#ocupareaeliberarea_unui_mutex">Ocuparea/eliberarea unui mutex</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#incercarea_neblocanta_de_ocupare_a_unui_mutex">Încercarea neblocantă de ocupare a unui mutex</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#exemplu_de_utilizare_a_mutex-urilor">Exemplu de utilizare a mutex-urilor</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#futex-uri">Futex-uri</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#semafor">Semafor</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#semafoare_cu_nume_-_initializaredeinitializare">Semafoare cu nume - Inițializare/deinițializare</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#semafoare_anonime_-_initializaredeinitializare">Semafoare anonime - Inițializare/deinițializare</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#operatii_comune_pe_semafoare">Operații comune pe semafoare</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#variabile_conditie">Variabile condiție</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#initializareadistrugerea_unei_variabile_de_conditie">Inițializarea/distrugerea unei variabile de condiție</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#blocarea_la_o_variabila_conditie">Blocarea la o variabilă condiție</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#blocarea_la_o_variabila_conditie_cu_timeout">Blocarea la o variabilă condiție cu timeout</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#deblocarea_unui_singur_fir_blocat_la_o_variabila_conditie">Deblocarea unui singur fir blocat la o variabilă condiție</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#deblocarea_tuturor_firelor_blocate_la_o_variabila_conditie">Deblocarea tuturor firelor blocate la o variabilă condiție</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#exemplu_de_utilizare_a_variabilelor_de_conditie">Exemplu de utilizare a variabilelor de condiție</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#bariera">Bariera</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#initializareadistrugerea_unei_bariere">Inițializarea/distrugerea unei bariere</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#asteptarea_la_o_bariera">Așteptarea la o barieră</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#exemplu_de_utilizare_a_barierei">Exemplu de utilizare a barierei</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#exercitii_de_laborator">Exercitii de laborator</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#linux">Linux</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#bonus">BONUS</a></div></li>
</ul>
</li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#solutii">Soluții</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#resurse_utile">Resurse utile</a></div></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
<div class="namespace_sidebar sidebar_box">



<h1 class="sectionedit48" id="informatii_generale_so">Informații generale SO</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_153488420651b89b74615d4',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_153488420651b89b74615d4" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/documentatie" class="wikilink1" title="so:info:documentatie">Documentație și alte resurse</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/feed" class="wikilink1" title="so:info:feed">Feed-uri RSS</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/hall" class="wikilink1" title="so:info:hall">Hall of SO</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/lista-discutii" class="wikilink1" title="so:info:lista-discutii">Listă de discuții</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/mv" class="wikilink1" title="so:info:mv">Mașini virtuale</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/trimitere-teme" class="wikilink1" title="so:info:trimitere-teme">Trimitere teme</a></div></li>
</ul>
</div>

</div>
<!-- EDIT48 SECTION "Informații generale SO" [12-175] -->
<h1 class="sectionedit49" id="informatii_so_2012-2013">Informații SO 2012-2013</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_156276979051b89b7463dee',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_156276979051b89b7463dee" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare" class="indexmenu_idx_head">Reguli generale și notare</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare/reguli-notare-ca-cc" class="wikilink1" title="so:2012-2013:notare:reguli-notare-ca-cc">Notare CA/CC</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare/reguli-notare-cb" class="wikilink1" title="so:2012-2013:notare:reguli-notare-cb">Notare CB</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/anunturi" class="wikilink1" title="so:2012-2013:anunturi">Anunțuri</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/calendar" class="wikilink1" title="so:2012-2013:calendar">Calendar</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/catalog" class="wikilink1" title="so:2012-2013:catalog">Catalog</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen" class="wikilink1" title="so:2012-2013:examen">Examen</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/need-to-know" class="wikilink1" title="so:2012-2013:need-to-know">SO Need to Know</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/orar" class="wikilink1" title="so:2012-2013:orar">Orar și împărțire pe semigrupe</a></div></li>
</ul>
</div>

</div>
<!-- EDIT49 SECTION "Informații SO 2012-2013" [176-248] -->
<h1 class="sectionedit50" id="laboratoare">Laboratoare</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_143879173351b89b7468bdc',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_143879173351b89b7468bdc" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse" class="indexmenu_idx_head">Resurse</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/c_tips" class="wikilink1" title="so:laboratoare:resurse:c_tips">C/SO Tips</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/die" class="wikilink1" title="so:laboratoare:resurse:die">Macro-ul DIE</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/gdb" class="wikilink1" title="so:laboratoare:resurse:gdb">GDB</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/home" class="wikilink1" title="so:laboratoare:resurse:home">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/injections" class="wikilink1" title="so:laboratoare:resurse:injections">Function Hooking and Windows Dll Injection</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/oprofile" class="wikilink1" title="so:laboratoare:resurse:oprofile">Oprofile</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/recapitulare" class="wikilink1" title="so:laboratoare:resurse:recapitulare">Recapitulare</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/threaduri_extra" class="wikilink1" title="so:laboratoare:resurse:threaduri_extra">Thread-uri - Extra</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/vs_tips" class="wikilink1" title="so:laboratoare:resurse:vs_tips">Visual Studio Tips and Tricks</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/windows-video" class="wikilink1" title="so:laboratoare:resurse:windows-video">windows-video</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-01" class="wikilink1" title="so:laboratoare:laborator-01">Laborator 01 - Introducere</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-02" class="wikilink1" title="so:laboratoare:laborator-02">Laborator 02 - Operații I/O simple</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-03" class="wikilink1" title="so:laboratoare:laborator-03">Laborator 03 - Procese</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-04" class="wikilink1" title="so:laboratoare:laborator-04">Laborator 04 - Gestiunea memoriei</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05" class="wikilink1" title="so:laboratoare:laborator-05">Laborator 05 - IPC</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06" class="wikilink1" title="so:laboratoare:laborator-06">Laborator 06 - Semnale</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-07" class="wikilink1" title="so:laboratoare:laborator-07">Laborator 07 - Memoria virtuală</a></div></li>
<li class="level1"><div class="li"><span class="curid"><a href="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/Laborator 08 - Thread-uri Linux [CS Open CourseWare].htm" class="wikilink1" title="so:laboratoare:laborator-08">Laborator 08 - Thread-uri Linux</a></span></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-09" class="wikilink1" title="so:laboratoare:laborator-09">Laborator 09 - Thread-uri Windows</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-10" class="wikilink1" title="so:laboratoare:laborator-10">Laborator 10 - Operații IO avansate - Windows</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-11" class="wikilink1" title="so:laboratoare:laborator-11">Laborator 11 - Operații IO avansate - Linux</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-12" class="wikilink1" title="so:laboratoare:laborator-12">Laborator 12 - Profiling</a></div></li>
</ul>
</div>

</div>
<!-- EDIT50 SECTION "Laboratoare" [249-309] -->
<h1 class="sectionedit51" id="cursuri">Cursuri</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_175197805751b89b746f9c7',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_175197805751b89b746f9c7" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-01" class="indexmenu_idx_head">Curs 01 - Introducere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-02" class="indexmenu_idx_head">Curs 02 - Sistemul de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-03" class="indexmenu_idx_head">Curs 03 - Procese</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-04" class="indexmenu_idx_head">Curs 04 - Planificarea execuției</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-05" class="indexmenu_idx_head">Curs 05 - Sincronizarea proceselor</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-06" class="indexmenu_idx_head">Curs 06 - Gestiunea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-07" class="indexmenu_idx_head">Curs 07 - Memoria virtuală</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-08" class="indexmenu_idx_head">Curs 08 - Fire de execuție</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-09" class="indexmenu_idx_head">Curs 09 - Dispozitive de intrare/ieșire</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-10" class="indexmenu_idx_head">Curs 10 - Implementarea sistemelor de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-11" class="indexmenu_idx_head">Curs 11 - Virtualizare</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-12" class="indexmenu_idx_head">Curs 12 - Securitatea sistemelor de operare</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-13" class="indexmenu_idx_head">Curs 13 - Android</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/quiz?idx=so:cursuri:quiz" class="indexmenu_idx">quiz</a></div></li>
</ul>
</div>

</div>
<!-- EDIT51 SECTION "Cursuri" [310-362] -->
<h1 class="sectionedit52" id="teme">Teme</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_116409789051b89b7471166',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_116409789051b89b7471166" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-asist" class="indexmenu_idx_head">Tema Asistenți - Guardian process</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/echipe" class="wikilink1" title="so:teme:echipe">Echipe tema 5</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/general" class="wikilink1" title="so:teme:general">Indicații generale teme</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-0" class="wikilink1" title="so:teme:tema-0">Tema 0 HashTable</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-1" class="wikilink1" title="so:teme:tema-1">Tema 1 Mini-shell</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-2" class="wikilink1" title="so:teme:tema-2">Tema 2 MPI</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-3" class="wikilink1" title="so:teme:tema-3">Tema 3 Memorie virtuală</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-4" class="wikilink1" title="so:teme:tema-4">Tema 4 Planificator de threaduri</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-5" class="wikilink1" title="so:teme:tema-5">Tema 5 Server web asincron</a></div></li>
</ul>
</div>

</div>
<!-- EDIT52 SECTION "Teme" [363-] -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          so/laboratoare/laborator-08.txt · Last modified: 2013/04/20 22:39 by laura.gheorghe          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
        <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08?do=revisions" class="action revs" accesskey="o" rel="nofollow" title="Old revisions [O]">Old revisions</a>      </div>
      <div class="bar-right">
        <a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08?do=media" class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08#dokuwiki__top" class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported"></a></div>
  <a target="_blank" href="http://www.chimeric.de/" title="www.chimeric.de"><img src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0"></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/button-css.png" width="80" height="15" alt="Valid CSS" border="0"></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0"></a>

  <a target="_blank" href="http://www.firefox-browser.de/" title="do yourself a favour and use a real browser - get firefox"><img src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0"></a>
  
  <a target="_blank" href="http://ocw.cs.pub.ro/courses/feed.php" title="Recent changes RSS feed"><img src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0"></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0"></a>
</div>

  </div>
</div>

<div class="no"><img src="./Laborator 08 - Thread-uri Linux [CS Open CourseWare]_files/indexer.php" width="2" height="1" alt=""></div>


</body></html>