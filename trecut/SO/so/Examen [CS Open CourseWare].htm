<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0048)http://ocw.cs.pub.ro/courses/so/2012-2013/examen -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>
    Examen    [CS Open CourseWare]
  </title>

  <meta name="generator" content="DokuWiki">
<meta name="robots" content="noindex,nofollow">
<meta name="date" content="2013-06-10T10:34:52+0300">
<meta name="keywords" content="so,2012-2013,examen">
<link rel="search" type="application/opensearchdescription+xml" href="http://ocw.cs.pub.ro/courses/lib/exe/opensearch.php" title="CS Open CourseWare">
<link rel="start" href="http://ocw.cs.pub.ro/courses/">
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="http://ocw.cs.pub.ro/courses/feed.php">
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://ocw.cs.pub.ro/courses/feed.php?mode=list&ns=so:2012-2013">
<link rel="alternate" type="text/html" title="Plain HTML" href="http://ocw.cs.pub.ro/courses/_export/xhtml/so/2012-2013/examen">
<link rel="canonical" href="./Examen [CS Open CourseWare]_files/Examen [CS Open CourseWare].htm">
<link rel="stylesheet" type="text/css" href="./Examen [CS Open CourseWare]_files/css.php">
<script type="text/javascript">/*<![CDATA[*/var NS='so:2012-2013';var JSINFO = {"id":"so:2012-2013:examen","namespace":"so:2012-2013"};
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="./Examen [CS Open CourseWare]_files/js.php"></script>
<script type="text/javascript">/*<![CDATA[*/
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		  
/*!]]>*/</script><script src="./Examen [CS Open CourseWare]_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">/*<![CDATA[*/
var pageTracker = _gat._getTracker("UA-38383934-1");
pageTracker._initData();
pageTracker._trackPageview();
		  
/*!]]>*/</script>
<script type="text/javascript" charset="utf-8" src="./Examen [CS Open CourseWare]_files/menu.js"></script>
<script type="text/javascript" charset="utf-8" src="./Examen [CS Open CourseWare]_files/indexmenu.js"></script>
<script type="text/javascript" charset="utf-8">/*<![CDATA[*/var indexmenu_ID='so/2012-2013/examen'
/*!]]>*/</script>

  <link rel="shortcut icon" href="http://ocw.cs.pub.ro/courses/lib/tpl/arctic/images/favicon.ico">

  
<script src="./Examen [CS Open CourseWare]_files/nojsindex.js" type="text/javascript" charset="utf-8"></script></head>
<body>
<div id="wrapper" class="show">
  <div class="dokuwiki">

    
    <div class="stylehead">
      <div class="header">
        <div class="pagename">
          <a href="http://ocw.cs.pub.ro/courses/so/"><img height="70" src="./Examen [CS Open CourseWare]_files/sigla_so.png"> </a>        </div>
        <div class="logo">
          <a style="color: #AAA !important;" href="http://ocw.cs.pub.ro/courses/systems/"><img height="70" src="./Examen [CS Open CourseWare]_files/systems.png" name="dokuwiki__top"></a>        </div>
      </div>
    
       
      <div class="breadcrumbs">
              </div>
      
            </div>

                  <div class="bar" id="bar__top">
        <div class="bar-left">
                  </div>
        <div class="bar-right">
          <a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen?do=login&sectok=86b5e794b6fc7ff30ead55e0316f8781" class="action login" rel="nofollow" title="Login">Login</a>        </div>
    </div>
        
    
    
    
              <div class="left_page">
          
<h2 class="sectionedit1" id="examen">Examen</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Urmăriți precizările din <a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare/reguli-notare-ca-cc" class="wikilink1" title="so:2012-2013:notare:reguli-notare-ca-cc">pagina de reguli</a>.</div>
</li>
</ul>

</div>

<h3 class="sectionedit2" id="examen_final">Examen final</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Examenele finale ale cursului de Sisteme de Operare se vor desfășura astfel:</div>
<ul>
<li class="level2"><div class="li"> 27 mai 2013, ora 11:00, sala EC002 - 333CB</div>
</li>
<li class="level2"><div class="li"> 27 mai 2013, ora 14:00, sala EC105 - studenții care au restanță</div>
</li>
<li class="level2"><div class="li"> 28 mai 2013, ora 08:00, sala EC002 - 331CB</div>
</li>
<li class="level2"><div class="li"> 3 iunie 2013, ora 11:00, sala EC004 - studenții care au restanță</div>
</li>
<li class="level2"><div class="li"> 9 iunie 2013, ora 08:00, sala EC004 - 334CB</div>
</li>
<li class="level2"><div class="li"> 10 iunie 2013, ora 11:00, sala EC002 - 332CB</div>
</li>
<li class="level2"><div class="li"> 10 iunie 2013, ora 14:00, sălile EC004 + EC105 - 331CA, 334CA, 333CC, 334CC, studenți seria CB transferați la CA/CC</div>
</li>
<li class="level2"><div class="li"> 14 iunie 2013, ora 14:00, sălile AN034 + EG301 - 331CC, 332CC, 332CA, 333CA, studenți seria CB transferați la CA/CC</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Rugăm să veniți în intervalul stabilit grupei voastre. Dacă, din motive obiective, nu puteți participa în data repartizată, trimiteți-i un e-mail lui <a href="mailto:traian.popeea@gmail.com" class="mail" title="traian.popeea@gmail.com">Traian</a> cu subiectul ”[SO] Transfer examen - Prenume Nume, Grupa”.</div>
</li>
<li class="level1"><div class="li"> Puteți participa la <strong>un singur</strong> examen.</div>
</li>
</ul>

</div>

<h3 class="sectionedit3" id="lucrari">Lucrări</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Nu există sesiune de contestații pentru lucrările de curs. În cazul în care considerați că au fost lipsuri la corectarea lucrării, trimiteți un e-mail lui <a href="mailto:traian.popeea@gmail.com" class="mail" title="traian.popeea@gmail.com">Traian</a>.</div>
<ul>
<li class="level2"><div class="li"> Folosiți subiectul [SO][Lucrare X] Prenume Nume - grupa; de exemplu [SO][Lucrare 1] Andreea Popescu - 332CA.</div>
</li>
</ul>
</li>
</ul>

</div>

<h4 id="lucrare_1">Lucrare 1</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> 12 martie, 14:05-14:15, EC101, seria CA</div>
</li>
<li class="level1"><div class="li"> 13 martie, 17:05-17:15, EC105, seria CC</div>
</li>
</ul>

</div>

<h5 id="ca_nr_1">3CA, nr. 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Fie P0 procesul părinte al procesului P1, T0 momentul de timp la care P0 execută apelul wait() și T1 momentul de timp la care P1 execută apelul exit(). În ce stare vor fi cele două procese în intervalul (T0, T1) dacă T0&lt;T1?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Procesul P0 este în starea WAITING, în așteptarea semnalului de la copil. Procesul P1 poate fi în orice stare, în funcție de codul său, dar va trece, cu siguranță, prin starea RUNNING pentru a putea executa apelul exit().</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Știind că apelul write(42, “X”, 1), executat în procesul P, se întoarce cu succes, care este numărul minim de fișiere deschise <strong>de</strong> procesul P? De ce? Antetul apelului write este write(fd, *buf, count).</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Numărul minim de fișiere deschise <strong>de</strong> procesul P este 0, deoarece este posibil ca toate fișierele să fi fost deschise de părintele lui P. Numărul minim de fișiere deschise <strong>în</strong> procesul P este 1, și anume fișierul cu descriptorul 42, deoarece este posibil ca toți ceilalți descriptori de fișier să fie închiși.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Prezentați un avantaj al mapării spațiului de memorie al kernel-ului în spațiul de adresă al fiecărui proces.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Prin maparea spațiului de memorie al kernel-ului în spațiul de adresă al fiecărui proces se evită schimbarea de context la fiecare apel de sistem, inclusiv apelul schedule().</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_nr_2">3CA, nr. 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Fie P0 procesul părinte al procesului P1, T0 momentul de timp la care P0 execută apelul wait() și T1 momentul de timp la care P1 execută apelul exit(). În ce stare vor fi cele două procese în intervalul (T1, T0) dacă T1&lt;T0?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Procesul P0 poate fi în orice stare, în funcție de codul său, dar va trece, cu siguranță, prin starea RUNNING pentru a putea executa apelul wait(). Procesul P1 este în starea TERMINATED (zombie), deoarece și-a încheiat execuția și așteaptă să îi fie citită valoarea de ieșire de către părinte.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Fie secvența de pseudocod:<pre class="code">for (i = 0; i &lt; 42; i++)
      printf(...);</pre>

<p>
Care este numărul minim, respectiv numărul maxim de apeluri de sistem din secvența de mai sus?
</p>
</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Numărul minim de apeluri de sistem din secvența de mai sus este 0. Dacă printf scrie la terminal, este line buffered și nu se va executa apel de sistem dacă nu se umple buffer-ul sau nu a fost primit caracterul '\n'. Numărul maxim de apeluri de sistem este 42, dacă în fiecare iterație a for-ului se umple buffer-ul sau a fost primit caracterul '\n'.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce un proces orfan nu poate deveni zombie?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Deoarece un proces orfan este adoptat imediat de init, este imposibil ca el să devină zombie. Acesta execută wait pentru fiecare proces copil al său, care și-a încheiat execuția, împiedicând ca acesta să devină zombie.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_nr_1">3CC, nr. 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce apelul fclose realizează în spate apel de sistem, dar apelul printf nu întotdeauna?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Apelul fclose realizează în spate apel de sistem, deoarece închide un fișier, modificând tabela de descriptori din proces. Apelul fclose se mapează pe apelul de sistem close. Apelul printf scrie într-un buffer, iar apelul de sistem write se realizează dacă se umple buffer-ul sau a fost primit caracterul '\n'.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Fie P1 și P2 două procese diferite. Când este posibil ca modificarea cursorului de fișier pentru un descriptor din P1 să conducă la modificarea cursorului de fișier pentru un descriptor din P2?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Această situație este posibilă dacă cele două procese au un proces “strămoș” comun și descriptorul de fișier nu a fost închis de niciunul dintre procese. Atunci, modificarea cursorului de fișier pentru un descriptor din P1 poate conduce la modificarea cursorului de fișier pentru același descriptor din P2.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Fie P un proces zombie. Ce procese îl pot elimina din sistem prin apelul wait()?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Procesele care pot elimina din sistem un proces zombie prin apelul wait() sunt: părintele său (dacă nu și-a încheiat execuția) și procesul init (care adoptă procesele orfane și execută wait pentru fiecare proces copil al său, care și-a încheiat execuția.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_nr_2">3CC, nr. 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> În urma unui apel fork() pot rezulta între X și Y procese <strong>noi</strong>. Ce valori au X și Y?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Dacă apelul fork() eșuează nu va fi creat niciun proces nou. Dacă apelul se execută cu succes, va fi creat un proces nou, copil al procesului care a executat fork(). Astfel, pot rezulta între 0 și 1 procese <strong>noi</strong>. X=0. Y=1.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este numărul minim de descriptori de fișier valizi în cadrul unui proces? În ce situație este posibilă această valoare?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Numărul minim de descriptori de fișier valizi în cadrul unui proces este 0, în cazul în care un proces închide toți descriptori de fișier, inclusiv stdin, stdout, stderr. Un astfel de proces este numit daemon.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Dați două exemple de resurse care pot aparține unui proces, dar nu pot aparține unui program.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Procesul reprezintă o instanță activă activă a unui program. Resursele care pot aparține unui proces, dar nu pot aparține unui program sunt: memoria, CPU-ul, PCB-ul (PID, spațiul de adresă - zonele de date, cod, heap, stivă, tabela de descriptori, masca de semnale, etc.).</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="lucrare_2">Lucrare 2</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> 2 aprilie, 14:05-14:15, EC101, seria CA</div>
</li>
<li class="level1"><div class="li"> 3 aprilie, 17:05-17:15, EC105, seria CC</div>
</li>
</ul>

</div>

<h5 id="ca_nr_11">3CA, nr. 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce un planificator echitabil (fair) nu este, în general, productiv (nu oferă un throughput mare)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Un planificator echitabil implică schimbări de context dese, astfel că este petrecut un timp relativ mare cu schimbările de context, scăzând productivitatea.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce este necesară folosirea mutex-urilor, și nu a spinlock-urilor, pentru regiunile critice cu operații de I/O?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Regiunile critice cu operații de I/O sunt, de obicei, lungi. De asemenea, operatiile I/O pot duce la blocarea thread-ului, caz în care nu poate fi folosit spinlock-ul.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce numărul de pagini virtuale dintr-un sistem este mai mare decât numărul de pagini fizice?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Numărul de pagini fizice este limitat de dimensiunea memoriei RAM, în timp ce numărul de pagini virtuale este determinat de numărul de procese. În cazul memoriei partajate de două sau mai multe procese, pot exista mai multe pagini virtuale mapate pe aceeași pagină fizică.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_nr_21">3CA, nr. 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> În ce situație este posibil ca un proces să treacă <strong>direct</strong> din starea WAITING în starea TERMINATED?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Un proces va trece direct din starea WAITING în starea TERMINATED dacă primește un semnal care nu poate fi ignorat sau suprascris, precum SIGKILL sau SIGQUIT, care conduce la terminarea procesului, indiferent de context.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În ce situație este posibilă apariția unui deadlock pe o singură resursă critică?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Fie procesul P1 care a acaparat resursa critică și procesele P2, P3, … , Pn care așteaptă eliberarea resursei respective. Un deadlock pe resursa respectivă va apărea dacă procesul P1 nu va elibera resursa critică, fie datorită codului său (nu există instrucțiunea de release/unlock, intră într-un ciclu infinit, etc.), fie deoarece a fost terminat prin semnal SIGKILL.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce paginarea ierarhică are un overhead de prelucrare mai mare decât paginarea neierarhică?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> În cazul paginării neierarhice, numărul paginii virtuale este și indexul în tabela de pagini, deci va exista un singur acces la memorie pentru aflarea paginii fizice. În cazul paginării ierarhice se vor face atâtea accese la memorie, cât numărul de niveluri ierarhice.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_nr_11">3CC, nr. 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce nu mai este folosită planificarea cooperativă în sistemele desktop moderne?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> În sistemele desktop moderne accentul este pus pe interactivitate. Planificarea cooperativă se bazează pe cedarea voluntară a procesorului și nu poate oferi interactivitate.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care este principală sursă de overhead la schimbarea de context între două procese?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Principală sursă de overhead la schimbarea de context între două procese este repopularea TLB-ului. În urma unei schimbări de context, intrările din TLB sunt invalidate și este necesară translatarea adreselor virtuale în adrese fizice pe baza tabelei de pagini a noului proces. Acest lucru implică numeroase accesări ale memoriei, la o viteză mult mai mică decât viteza TLB-ului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce nu este necesară eliminarea paginilor de memorie ale kernel-ului din TLB în cazul unei schimbări de context?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Eliminarea paginilor de memorie ale kernel-ului din TLB în cazul unei schimbări de context nu este necesară deoarece toate procesele au mapate pe aceleași pagini virtuale tot spațiul kernel.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_nr_21">3CC, nr. 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce, pe un sistem desktop, de obicei, sunt mai multe procese în starea WAITING decât în starea READY?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Pe un sistem desktop, majoritatea proceselor așteaptă inputul utilizatorului, deci sunt procese I/O bound.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Descrieți două diferențe între un mutex și un semafor binar.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> </div>
</li>
<li class="level2"><div class="li"> Mutexul este folosit pentru acces exclusiv, semaforul binar este folosit pentru sincronizare</div>
</li>
<li class="level2"><div class="li"> Mutexul poate fi eliberat doar de procesul care l-a ocupat, în timp ce orice proces poate incrementa semaforul.</div>
</li>
<li class="level2"><div class="li"> Mutexul este mereu inițializat unlocked, semaforul binar poate fi inițializat la valoarea 0.</div>
</li>
<li class="level2"><div class="li"> Mutexul are un overhead mai mic decât semaforul binar.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Fie un sistem cu paginare ierarhică pe două niveluri, fără TLB. Pot două pagini de memorie virtuală referi aceeași pagină de memorie fizică?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Da, două pagini de memorie virtuală pot referi aceeași pagină.</div>
</li>
<li class="level2"><div class="li"> În această situație, în cadrul unui proces, în tabela de pagini, unor intrări diferite (indexate de pagina virtuală A și pagina virtuală B) le corespunde aceeași pagină fizică.</div>
</li>
<li class="level2"><div class="li"> În cazul a două procese este vorba de implementarea mecanismului de shared memory.</div>
</li>
<li class="level2"><div class="li"> Afirmațiile sunt valabile pentru orice tip de paginare: ierarhică, neierarhică, inversată, indiferent de prezența / absența TLB-ului.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="lucrare_3">Lucrare 3</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> 23 aprilie, 14:05-14:15, EC101, seria CA</div>
</li>
<li class="level1"><div class="li"> 24 aprilie, 17:05-17:15, EC105, seria CC</div>
</li>
</ul>

</div>

<h5 id="ca_nr_12">3CA, nr. 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Presupunând dimensiunea unei pagini de 4096, câte pagini fizice (frame-uri) noi vor fi alocate în urma apelului malloc(6000)? De ce?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Apelul malloc folosește demand paging, alocând memorie pur virtuală, fără suport în memoria fizică. Totuși, pentru alocări de dimensiuni mici, este posibil să fie alocate și paginile fizice aferente. Deoarece 4096 &lt; 6000 &lt; 2 * 4096, se vor aloca maxim două pagini.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce overhead-ul creării unui nou thread este independent de utilizarea mecanismului copy-on-write?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Copy-on-write are sens doar între două tabele de pagini diferite, adică între două procese diferite, întrucât se partajează paginile fizice între pagini virtuale din procese diferite. Thread-urile din același proces partajează tabela de pagină, astfel că overhead-ul creării unui nou thread este independent de copy-on-write.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Cu ce diferă o operație I/O sincronă de o operație I/O blocantă?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> O operație sincronă întoarce rezultatele prezente în acel moment, indiferent dacă operația s-a încheiat sau nu. O operație blocantă blochează procesul curent.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_nr_22">3CA, nr. 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> De ce este mecanismul de mapare a fișierelor esențial în rularea proceselor pe sisteme de operare moderne?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Mecanismul de mapare a fișierelor este esențial deoarece rularea proceselor se face prin maparea executabilului în memorie și folosirea demand-paging pentru încărcarea zonelor de date și cod la nevoie.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Câte fire de execuție va avea un proces multithreaded în urma executării unui apel din familia exec()?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> În urma executării unui apel din familia exec(), spațiul de adresă al procesului existent va fi înlocuit cu spațiul de adresă al noului proces. Acesta va avea inițial n singur fir de execuție.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Care sunt cele două argumente ale unei instrucțiuni de tipul IN sau OUT (pentru lucrul cu port-mapped I/O)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Cele două argumente sunt registrul procesorului și portul dispozitivului I/O.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_nr_12">3CC, nr. 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Fie afirmația “Toate procesele vor genera page fault-uri în urma unui apel din familia exec().” Precizați și justificați valoarea de adevăr a afirmației.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Afirmația este adevărată deoarece în urma apelului exec(), vor fi încărcate zonele de date și cod, folosind demand-paging.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Fie un program multithreaded care rulează pe un sistem uniprocesor cu sistem de operare cu suport multithreaded. În ce situație este mai eficientă folosirea user-level threads în fața kernel-level threads?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Folosirea user-level threads este mai eficientă în cazul în care procesul face multe operații CPU intensive, deoarece este mai rapid context switch-ul.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce nu are sens sortarea operațiilor I/O pentru dispozitive caracter (char devices)?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Dispozitivele de tip caracter obțin datele în format secvențial, astfel că operațiile I/O nu pot fi sortate.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_nr_22">3CC, nr. 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Fie afirmația: “Un apel fork() modifică numărul de pagini virtuale și numărul de pagini fizice alocate într-un sistem.” Precizați și justificați valoarea de adevăr a afirmației.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Afirmația este adevărată. Numărul paginilor virtuale crește, deoarece apare un nou spațiu de adresă. Crește și numărul de pagini fizice, întrucât se alocă structuri interne nucleului, printre care noua tabelă de pagini pentru procesul copil.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Fie f o funcție care nu este reentrantă. Cum trebuie aceasta apelată pentru a fi thread-safe?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Pentru a fi thread-safe, trebuie apelată folosind un mecanism de acces exclusiv. Dacă se pune lock, un singur thread va putea accesa funcția, care devine, astfel, thread-safe.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Prezentați un avantaj al folosirii întreruperilor în fața polling-ului.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Polling-ul este un mecanism de tip busy-waiting, deci procesorul va fi ținut ocupat în așteptarea datelor. În schimb, întreruperile nu țin procesorul ocupat, oferind o utilizare mai bună a acestuia.</div>
</li>
</ul>
</li>
</ol>

</div>

<h4 id="lucrare_4">Lucrare 4</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> 21 mai, 14:05-14:15, EC101, seria CA</div>
</li>
<li class="level1"><div class="li"> 22 mai, 17:05-17:15, EC105, seria CC</div>
</li>
</ul>

</div>

<h5 id="ca_nr_13">3CA, nr. 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Cum se modifică numărul de inode-uri ocupate, respectiv numărul de dentry-uri de pe o partiție în cazul creării unui fișier nou obișnuit (regular file)? Explicați.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> În cazul creării unui fișier nou obișnuit (regular file), se va crea un dentry nou, în cadrul directorului părinte, și va fi ocupat un inode.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce o soluție de virtualizare bazată pe OpenVZ are un overhead mai mic decât VMware Workstation?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Deoarece nu există un nivel intermediar de hypervisor (cu hypercall-uri sau trap-uri în hypervisor) și un kernel suplimentar în cazul OpenVZ. Toate procesele rulează “nativ” peste nucleul principal, fiind doar “îngrădite” (contained).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce NU previne flag-ul NX (No eXecute) atacurile de tipul return-to-libc?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Flag-ul NX marchează regiuni specifice (stiva, de exemplu) ca neexecutabile. Un atac de tipul return-to-libc forțează un jump nevalid la o adresă din zona de cod (text) care este executabilă și nu este afectată de prezența sau nu a flag-ului NX.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="ca_nr_23">3CA, nr. 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Fie afirmația “Spațiul ocupat pe disc de un director este constant.” Precizați și justificați valoarea de adevăr a afirmației.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Afirmația este falsă. Spațiului unui director pe disc crește pe măsură ce apar intrări noi (dentry-uri) în cadrul directorului.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Din ce cauză NU este afectat sistemul gazdă (host) în cazul apariției unei erori fatale la nivelul nucleului unei mașini virtuale VMware Workstation?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Deoarece trap-ul generat de eroarea în cauză afectează doar nucleul mașinii virtuale care rulează în user space-ului hypervisor-ului VMware. Hypervisor-ul, adică sistemul gazdă, nu este afectat și poate reporni mașina virtuală.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> În ce mod protejează chroot împotriva atacurilor de tip shellcode?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong>  În chroot jail nu este adăugat executabil de shell (/bin/bash sau /bin/sh). În acest caz, nu se poate executa un shell dintr-un program chroot-at și, deci, nici un shellcode.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_nr_13">3CC, nr. 1</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Cum se modifică numărul de inode-uri, respectiv dentry-uri de pe o partiție în cazul creării unui director nou? Explicați.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> În cazul creării unui director nou, se vor crea trei dentry-uri noi (unul în cadrul directorului părinte și două: ”.” și ”..” în cadrul directorului nou creat), și va fi ocupat un inode.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce este necesară rescrierea instrucțiunilor neprivilegiate în cazul virtualizării folosind VMware Workstation?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Deoarece există instrucțiuni sensibile neprivilegiate. Rularea acestora în mașina virtuală nu va genera trap și este posibil să conducă la comportament nevalid. Folosind tehnici de binary translation, instrucțiunile neprivilegiate sensibile sunt suprascrise.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce NU este stocată valoarea “salt” și în fișierul /etc/passwd?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Deoarece valoarea este corelată cu hash-ul, care se stochează în /etc/shadow. De asemenea, din considerente de securitate, nu ar trebui să fie stocată într-un fișier care poate fi citit de orice user.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="cc_nr_23">3CC, nr. 2</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Cum se modifică numărul de inode-uri, respectiv dentry-uri de pe o partiție în cazul creării unui hard-link? Explicați.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> În cazul creării unui hard-link, se va crea un dentry nou, în cadrul directorului părinte, fără a se modifica numărul de inode-uri.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Fie afirmația “Modul în care este tratat un page fault din cadrul unui container OpenVZ este diferit de modul în care este tratat un page fault din cadrul mașinii gazdă.” Precizați și justificați valoarea de adevăr a afirmației.</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Afirmația este falsă, deoarece toate containerele OpenVZ folosesc același kernel, astfel page fault-urile sunt tratate identic, indiferent de container-ul sursă.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> De ce are tehnica ASLR impact redus pe un sistem pe 32 de biți?</div>
<ul>
<li class="level2"><div class="li"> <strong>Răspuns</strong> Tehnica ASLR împiedică atacatorul să cunoască adresa funcției dorite din cadrul zonei de cod prin maparea acestora în puncte aleatoare din spațiul de adresă. Pentru sisteme pe 32 de biți, spațiul virtual nu este suficient de mare, atacatorii putând “căuta” adresa dorită pentru a realiza atacuri de tipul return-to-libc.</div>
</li>
</ul>
</li>
</ol>

</div>

<h5 id="examene_anterioare">Examene anterioare</h5>
<div class="level5">

</div>

        </div>
        <div class="right_sidebar">
          <form action="http://ocw.cs.pub.ro/courses/start" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input type="hidden" name="do" value="search"><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]"><input type="submit" value="Search" class="button" title="Search"><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>          <div class="toc_sidebar sidebar_box">
<!-- TOC START -->
<div id="sb__right__dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen#examen">Examen</a></div>
<ul class="toc">
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen#examen_final">Examen final</a></div></li>
<li class="level3"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen#lucrari">Lucrări</a></div>
<ul class="toc">
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen#lucrare_1">Lucrare 1</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen#lucrare_2">Lucrare 2</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen#lucrare_3">Lucrare 3</a></div></li>
<li class="level4"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen#lucrare_4">Lucrare 4</a></div></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->
</div>
<div class="namespace_sidebar sidebar_box">



<h1 class="sectionedit4" id="informatii_generale_so">Informații generale SO</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_2132385351b8ce152755a',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_2132385351b8ce152755a" class="indexmenu_nojs">

<ul class="idx">
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/documentatie" class="wikilink1" title="so:info:documentatie">Documentație și alte resurse</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/feed" class="wikilink1" title="so:info:feed">Feed-uri RSS</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/hall" class="wikilink1" title="so:info:hall">Hall of SO</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/lista-discutii" class="wikilink1" title="so:info:lista-discutii">Listă de discuții</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/mv" class="wikilink1" title="so:info:mv">Mașini virtuale</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/info/trimitere-teme" class="wikilink1" title="so:info:trimitere-teme">Trimitere teme</a></div></li>
</ul>
</div>

</div>
<!-- EDIT4 SECTION "Informații generale SO" [12-175] -->
<h1 class="sectionedit5" id="informatii_so_2012-2013">Informații SO 2012-2013</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_34731828551b8ce1529666',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_34731828551b8ce1529666" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare" class="indexmenu_idx_head">Reguli generale și notare</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare/reguli-notare-ca-cc" class="wikilink1" title="so:2012-2013:notare:reguli-notare-ca-cc">Notare CA/CC</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/notare/reguli-notare-cb" class="wikilink1" title="so:2012-2013:notare:reguli-notare-cb">Notare CB</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/anunturi" class="wikilink1" title="so:2012-2013:anunturi">Anunțuri</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/calendar" class="wikilink1" title="so:2012-2013:calendar">Calendar</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/catalog" class="wikilink1" title="so:2012-2013:catalog">Catalog</a></div></li>
<li class="level1"><div class="li"><span class="curid"><a href="./Examen [CS Open CourseWare]_files/Examen [CS Open CourseWare].htm" class="wikilink1" title="so:2012-2013:examen">Examen</a></span></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/need-to-know" class="wikilink1" title="so:2012-2013:need-to-know">SO Need to Know</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/orar" class="wikilink1" title="so:2012-2013:orar">Orar și împărțire pe semigrupe</a></div></li>
</ul>
</div>

</div>
<!-- EDIT5 SECTION "Informații SO 2012-2013" [176-248] -->
<h1 class="sectionedit6" id="laboratoare">Laboratoare</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_209651501651b8ce152e079',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_209651501651b8ce152e079" class="indexmenu_nojs">

<ul class="idx">
<li class="open"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse" class="indexmenu_idx_head">Resurse</a></div>
<ul class="idx">
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/c_tips" class="wikilink1" title="so:laboratoare:resurse:c_tips">C/SO Tips</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/die" class="wikilink1" title="so:laboratoare:resurse:die">Macro-ul DIE</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/gdb" class="wikilink1" title="so:laboratoare:resurse:gdb">GDB</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/home" class="wikilink1" title="so:laboratoare:resurse:home">Resurse</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/injections" class="wikilink1" title="so:laboratoare:resurse:injections">Function Hooking and Windows Dll Injection</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/oprofile" class="wikilink1" title="so:laboratoare:resurse:oprofile">Oprofile</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/recapitulare" class="wikilink1" title="so:laboratoare:resurse:recapitulare">Recapitulare</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/threaduri_extra" class="wikilink1" title="so:laboratoare:resurse:threaduri_extra">Thread-uri - Extra</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/vs_tips" class="wikilink1" title="so:laboratoare:resurse:vs_tips">Visual Studio Tips and Tricks</a></div></li>
<li class="level2"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/resurse/windows-video" class="wikilink1" title="so:laboratoare:resurse:windows-video">windows-video</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-01" class="wikilink1" title="so:laboratoare:laborator-01">Laborator 01 - Introducere</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-02" class="wikilink1" title="so:laboratoare:laborator-02">Laborator 02 - Operații I/O simple</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-03" class="wikilink1" title="so:laboratoare:laborator-03">Laborator 03 - Procese</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-04" class="wikilink1" title="so:laboratoare:laborator-04">Laborator 04 - Gestiunea memoriei</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-05" class="wikilink1" title="so:laboratoare:laborator-05">Laborator 05 - IPC</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-06" class="wikilink1" title="so:laboratoare:laborator-06">Laborator 06 - Semnale</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-07" class="wikilink1" title="so:laboratoare:laborator-07">Laborator 07 - Memoria virtuală</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-08" class="wikilink1" title="so:laboratoare:laborator-08">Laborator 08 - Thread-uri Linux</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-09" class="wikilink1" title="so:laboratoare:laborator-09">Laborator 09 - Thread-uri Windows</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-10" class="wikilink1" title="so:laboratoare:laborator-10">Laborator 10 - Operații IO avansate - Windows</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-11" class="wikilink1" title="so:laboratoare:laborator-11">Laborator 11 - Operații IO avansate - Linux</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/laboratoare/laborator-12" class="wikilink1" title="so:laboratoare:laborator-12">Laborator 12 - Profiling</a></div></li>
</ul>
</div>

</div>
<!-- EDIT6 SECTION "Laboratoare" [249-309] -->
<h1 class="sectionedit7" id="cursuri">Cursuri</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_178519851851b8ce1534203',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_178519851851b8ce1534203" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-01" class="indexmenu_idx_head">Curs 01 - Introducere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-02" class="indexmenu_idx_head">Curs 02 - Sistemul de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-03" class="indexmenu_idx_head">Curs 03 - Procese</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-04" class="indexmenu_idx_head">Curs 04 - Planificarea execuției</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-05" class="indexmenu_idx_head">Curs 05 - Sincronizarea proceselor</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-06" class="indexmenu_idx_head">Curs 06 - Gestiunea memoriei</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-07" class="indexmenu_idx_head">Curs 07 - Memoria virtuală</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-08" class="indexmenu_idx_head">Curs 08 - Fire de execuție</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-09" class="indexmenu_idx_head">Curs 09 - Dispozitive de intrare/ieșire</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-10" class="indexmenu_idx_head">Curs 10 - Implementarea sistemelor de fișiere</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-11" class="indexmenu_idx_head">Curs 11 - Virtualizare</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-12" class="indexmenu_idx_head">Curs 12 - Securitatea sistemelor de operare</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/curs-13" class="indexmenu_idx_head">Curs 13 - Android</a></div></li>
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/cursuri/quiz?idx=so:cursuri:quiz" class="indexmenu_idx">quiz</a></div></li>
</ul>
</div>

</div>
<!-- EDIT7 SECTION "Cursuri" [310-362] -->
<h1 class="sectionedit8" id="teme">Teme</h1>
<div class="level1">
<script type="text/javascript" charset="utf-8">
<!--//--><![CDATA[//><!--
indexmenu_nojsqueue.push(new Array('indexmenu_180394203651b8ce15356fc',''));
addInitEvent(function(){indexmenu_loadJs(DOKU_BASE+'lib/plugins/indexmenu/nojsindex.js');});
//--><!]]>
</script>

<div id="nojs_indexmenu_180394203651b8ce15356fc" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-asist" class="indexmenu_idx_head">Tema Asistenți - Guardian process</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/echipe" class="wikilink1" title="so:teme:echipe">Echipe tema 5</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/general" class="wikilink1" title="so:teme:general">Indicații generale teme</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-0" class="wikilink1" title="so:teme:tema-0">Tema 0 HashTable</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-1" class="wikilink1" title="so:teme:tema-1">Tema 1 Mini-shell</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-2" class="wikilink1" title="so:teme:tema-2">Tema 2 MPI</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-3" class="wikilink1" title="so:teme:tema-3">Tema 3 Memorie virtuală</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-4" class="wikilink1" title="so:teme:tema-4">Tema 4 Planificator de threaduri</a></div></li>
<li class="level1"><div class="li"><a href="http://ocw.cs.pub.ro/courses/so/teme/tema-5" class="wikilink1" title="so:teme:tema-5">Tema 5 Server web asincron</a></div></li>
</ul>
</div>

</div>
<!-- EDIT8 SECTION "Teme" [363-] -->
</div>
        </div>
      
    
      <div class="stylefoot">
        <div class="meta">
          <div class="user">
                    </div>
          <div class="doc">
          so/2012-2013/examen.txt · Last modified: 2013/06/10 10:34 by traian.popeea          </div>
        </div>
      </div>

    <div class="clearer"></div>

    
                <div class="bar" id="bar__bottom">
      <div class="bar-left">
        <a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen?do=revisions" class="action revs" accesskey="o" rel="nofollow" title="Old revisions [O]">Old revisions</a>      </div>
      <div class="bar-right">
        <a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen?do=media" class="action media" rel="nofollow" title="Media Manager">Media Manager</a><a href="http://ocw.cs.pub.ro/courses/so/2012-2013/examen#dokuwiki__top" class="action top" accesskey="t" rel="nofollow" title="Back to top [T]">Back to top</a>      </div>
    </div>
    <div class="clearer"></div>
            
    <div align="center" class="footerinc">
  <div class="license"><a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="./Examen [CS Open CourseWare]_files/cc-by-sa.png" alt="CC Attribution-Share Alike 3.0 Unported"></a></div>
  <a target="_blank" href="http://www.chimeric.de/" title="www.chimeric.de"><img src="./Examen [CS Open CourseWare]_files/button-chimeric-de.png" width="80" height="15" alt="www.chimeric.de" border="0"></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="./Examen [CS Open CourseWare]_files/button-css.png" width="80" height="15" alt="Valid CSS" border="0"></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="./Examen [CS Open CourseWare]_files/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0"></a>

  <a target="_blank" href="http://www.firefox-browser.de/" title="do yourself a favour and use a real browser - get firefox"><img src="./Examen [CS Open CourseWare]_files/button-firefox.png" width="80" height="15" alt="do yourself a favour and use a real browser - get firefox!!" border="0"></a>
  
  <a target="_blank" href="http://ocw.cs.pub.ro/courses/feed.php" title="Recent changes RSS feed"><img src="./Examen [CS Open CourseWare]_files/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0"></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="./Examen [CS Open CourseWare]_files/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0"></a>
</div>

  </div>
</div>

<div class="no"><img src="./Examen [CS Open CourseWare]_files/indexer.php" width="2" height="1" alt=""></div>


</body></html>